<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pan Docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <!-- Open Graph tags-->
        <meta name="og:site_name" content="Pan Docs" />
        <meta name="og:image" content="https://gbdev.io/pandocs/favicon.png" />
        <meta name="og:title" content="Pan Docs" />
        <meta name="og:description" content="The single, most comprehensive technical reference to Game Boy available to the public." />
        
        <!-- Twitter meta tags -->
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@gbdev0" />
        
        <!-- MathML polyfill for Chrome -->
        <script src="https://fred-wang.github.io/mathml.css/mspace.js"></script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The single, most comprehensive technical reference to Game Boy available to the public.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom/style.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="About.html">Foreword</a></li><li class="chapter-item affix "><a href="Authors.html">Acknowledgements</a></li><li class="chapter-item affix "><a href="History.html">History</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Overview</li><li class="chapter-item "><a href="Specifications.html"><strong aria-hidden="true">1.</strong> Specifications</a></li><li class="chapter-item "><a href="Memory_Map.html"><strong aria-hidden="true">2.</strong> Memory Map</a></li><li class="chapter-item affix "><li class="part-title">I/O Ports</li><li class="chapter-item "><a href="Hardware_Reg_List.html"><strong aria-hidden="true">3.</strong> Summary</a></li><li class="chapter-item "><a href="Rendering.html"><strong aria-hidden="true">4.</strong> Rendering</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Tile_Data.html"><strong aria-hidden="true">4.1.</strong> Tile Data</a></li><li class="chapter-item "><a href="Tile_Maps.html"><strong aria-hidden="true">4.2.</strong> Tile Maps</a></li><li class="chapter-item "><a href="OAM.html"><strong aria-hidden="true">4.3.</strong> OAM</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="OAM_DMA_Transfer.html"><strong aria-hidden="true">4.3.1.</strong> OAM DMA Transfer</a></li></ol></li><li class="chapter-item "><a href="LCDC.html"><strong aria-hidden="true">4.4.</strong> LCD Control</a></li><li class="chapter-item "><a href="STAT.html"><strong aria-hidden="true">4.5.</strong> LCD Status</a></li><li class="chapter-item "><a href="Scrolling.html"><strong aria-hidden="true">4.6.</strong> Scrolling</a></li><li class="chapter-item "><a href="Palettes.html"><strong aria-hidden="true">4.7.</strong> Palettes</a></li><li class="chapter-item "><a href="pixel_fifo.html"><strong aria-hidden="true">4.8.</strong> Pixel FIFO</a></li></ol></li><li class="chapter-item "><a href="Audio.html"><strong aria-hidden="true">5.</strong> Audio</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Audio_Registers.html"><strong aria-hidden="true">5.1.</strong> Audio Registers</a></li><li class="chapter-item "><a href="Audio_details.html"><strong aria-hidden="true">5.2.</strong> Audio Details</a></li></ol></li><li class="chapter-item "><a href="Joypad_Input.html"><strong aria-hidden="true">6.</strong> Joypad Input</a></li><li class="chapter-item "><a href="Serial_Data_Transfer_(Link_Cable).html"><strong aria-hidden="true">7.</strong> Serial Data Transfer</a></li><li class="chapter-item "><a href="Timer_and_Divider_Registers.html"><strong aria-hidden="true">8.</strong> Timer and Divider Registers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Timer_Obscure_Behaviour.html"><strong aria-hidden="true">8.1.</strong> Timer Obscure Behaviour</a></li></ol></li><li class="chapter-item "><a href="Interrupts.html"><strong aria-hidden="true">9.</strong> Interrupts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Interrupt_Sources.html"><strong aria-hidden="true">9.1.</strong> Interrupt Sources</a></li><li class="chapter-item "><a href="halt.html"><strong aria-hidden="true">9.2.</strong> HALT</a></li></ol></li><li class="chapter-item "><a href="CGB_Registers.html"><strong aria-hidden="true">10.</strong> CGB Registers</a></li><li class="chapter-item "><a href="IR.html"><strong aria-hidden="true">11.</strong> Infrared Communication</a></li><li class="chapter-item "><a href="SGB_Functions.html"><strong aria-hidden="true">12.</strong> SGB Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="SGB_Unlocking.html"><strong aria-hidden="true">12.1.</strong> Unlocking and Detecting SGB Functions</a></li><li class="chapter-item "><a href="SGB_Command_Packet.html"><strong aria-hidden="true">12.2.</strong> Command Packet Transfers</a></li><li class="chapter-item "><a href="SGB_VRAM_Transfer.html"><strong aria-hidden="true">12.3.</strong> VRAM Transfers</a></li><li class="chapter-item "><a href="SGB_Color_Palettes.html"><strong aria-hidden="true">12.4.</strong> Color Palettes Overview</a></li><li class="chapter-item "><a href="SGB_Command_Summary.html"><strong aria-hidden="true">12.5.</strong> Command Summary</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="SGB_Command_Palettes.html"><strong aria-hidden="true">12.5.1.</strong> Palette Commands</a></li><li class="chapter-item "><a href="SGB_Command_Attribute.html"><strong aria-hidden="true">12.5.2.</strong> Color Attribute Commands</a></li><li class="chapter-item "><a href="SGB_Command_Sound.html"><strong aria-hidden="true">12.5.3.</strong> Sound Functions</a></li></ol></li><li class="chapter-item "><a href="SGB_Command_System.html"><strong aria-hidden="true">12.6.</strong> System Control Commands</a></li><li class="chapter-item "><a href="SGB_Command_Multiplayer.html"><strong aria-hidden="true">12.7.</strong> Multiplayer Command</a></li><li class="chapter-item "><a href="SGB_Command_Border.html"><strong aria-hidden="true">12.8.</strong> Border and OBJ Commands</a></li><li class="chapter-item "><a href="SGB_Command_Undocumented.html"><strong aria-hidden="true">12.9.</strong> Undocumented SGB commands</a></li></ol></li><li class="chapter-item "><li class="part-title">CPU Specifications</li><li class="chapter-item "><a href="CPU_Registers_and_Flags.html"><strong aria-hidden="true">13.</strong> CPU Registers and Flags</a></li><li class="chapter-item "><a href="CPU_Instruction_Set.html"><strong aria-hidden="true">14.</strong> CPU Instruction Set</a></li><li class="chapter-item "><a href="CPU_Comparison_with_Z80.html"><strong aria-hidden="true">15.</strong> CPU Comparison with Z80</a></li><li class="chapter-item affix "><li class="part-title">Cartridges</li><li class="chapter-item "><a href="The_Cartridge_Header.html"><strong aria-hidden="true">16.</strong> The Cartridge Header</a></li><li class="chapter-item "><a href="MBCs.html"><strong aria-hidden="true">17.</strong> MBCs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="nombc.html"><strong aria-hidden="true">17.1.</strong> No MBC</a></li><li class="chapter-item "><a href="MBC1.html"><strong aria-hidden="true">17.2.</strong> MBC1</a></li><li class="chapter-item "><a href="MBC2.html"><strong aria-hidden="true">17.3.</strong> MBC2</a></li><li class="chapter-item "><a href="MBC3.html"><strong aria-hidden="true">17.4.</strong> MBC3</a></li><li class="chapter-item "><a href="MBC5.html"><strong aria-hidden="true">17.5.</strong> MBC5</a></li><li class="chapter-item "><a href="MBC6.html"><strong aria-hidden="true">17.6.</strong> MBC6</a></li><li class="chapter-item "><a href="MBC7.html"><strong aria-hidden="true">17.7.</strong> MBC7</a></li><li class="chapter-item "><a href="MMM01.html"><strong aria-hidden="true">17.8.</strong> MMM01</a></li><li class="chapter-item "><a href="M161.html"><strong aria-hidden="true">17.9.</strong> M161</a></li><li class="chapter-item "><a href="HuC1.html"><strong aria-hidden="true">17.10.</strong> HuC1</a></li><li class="chapter-item "><a href="HuC3.html"><strong aria-hidden="true">17.11.</strong> HuC-3</a></li><li class="chapter-item "><a href="othermbc.html"><strong aria-hidden="true">17.12.</strong> Other MBCs</a></li></ol></li><li class="chapter-item "><li class="part-title">Accessories</li><li class="chapter-item "><a href="Gameboy_Printer.html"><strong aria-hidden="true">18.</strong> Game Boy Printer</a></li><li class="chapter-item "><a href="Gameboy_Camera.html"><strong aria-hidden="true">19.</strong> Game Boy Camera</a></li><li class="chapter-item "><a href="Four_Player_Adapter.html"><strong aria-hidden="true">20.</strong> 4-Player Adapter</a></li><li class="chapter-item "><a href="Shark_Cheats.html"><strong aria-hidden="true">21.</strong> Game Genie/Shark Cheats</a></li><li class="chapter-item affix "><li class="part-title">Other</li><li class="chapter-item "><a href="Power_Up_Sequence.html"><strong aria-hidden="true">22.</strong> Power-Up Sequence</a></li><li class="chapter-item "><a href="Reducing_Power_Consumption.html"><strong aria-hidden="true">23.</strong> Reducing Power Consumption</a></li><li class="chapter-item "><a href="Accessing_VRAM_and_OAM.html"><strong aria-hidden="true">24.</strong> Accessing VRAM and OAM</a></li><li class="chapter-item "><a href="OAM_Corruption_Bug.html"><strong aria-hidden="true">25.</strong> OAM Corruption Bug</a></li><li class="chapter-item "><a href="External_Connectors.html"><strong aria-hidden="true">26.</strong> External Connectors</a></li><li class="chapter-item "><a href="GBC_Approval_Process.html"><strong aria-hidden="true">27.</strong> GBC Approval Process</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="References.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pan Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gbdev/pandocs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>This document, started in early 1995, is considered the single most comprehensive technical reference to Game Boy available to the public.</p>
<p>You are reading a new version of it, maintained in the Markdown format and enjoying renewed <a href="https://gbdev.io">community</a> attention, correcting and updating it with recent findings. To learn more about the legacy and the mission of this initiative, check <a href="./History.html">History</a>.</p>
<div class="box tip">
<p class="box-title">SCOPE</p><p>The information here is targeted at homebrew development.
Emulator developers may be also interested in the <a href="https://gekkio.fi/files/gb-docs/gbctr.pdf">Game Boy: Complete Technical Reference</a> document.</p>
</div>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>This project is open source, released under the <a href="https://raw.githubusercontent.com/gbdev/pandocs/master/LICENSE">CC0 license</a>. Everyone is welcome to help, provide feedback and propose additions or improvements. The git repository is hosted at <a href="https://github.com/gbdev/pandocs">github.com/gbdev/pandocs</a>, where you can learn more about how you can <a href="https://github.com/gbdev/pandocs/blob/master/CONTRIBUTING.md">contribute</a>, find detailed contribution guidelines and procedures, file Issues and send Pull Requests.</p>
<p>There is a <a href="https://gbdev.io/chat">Discord chat</a> dedicated to the gbdev community.</p>
<p>Finally, you can also contact us and send patches via email: <code>pandocs (at) gbdev.io</code>.</p>
<h2 id="using-this-document"><a class="header" href="#using-this-document">Using this document</a></h2>
<p>In the top navigation bar, you will find a series of icons.</p>
<p>By clicking on the <i class="fa fa-bars"></i> icon you will toggle an interactive table of contents to navigate the document. You can also use <kbd>→</kbd> and <kbd>←</kbd> keys on your keyboard to go to the following and previous page.</p>
<p>The <i class="fa fa-paint-brush"></i> lets you choose among 5 different themes and color schemes to please your reading experience.</p>
<p>You can search anywhere by pressing <kbd>s</kbd> on your keyboard or clicking the <i class="fa fa-search"></i> icon.</p>
<p>The <i class="fa fa-edit"></i> icon allows you to suggest an edit on the current page by directly opening the source file in the git repository.</p>
<p><a href="single.html">One-page</a> and <a href="print.html">printable</a> versions of this document are also available.</p>
<p><br><br><small>This document version was produced from git commit <a href="https://github.com/gbdev/pandocs/tree/4814bb2814265242d24551b48eba1cbd152a351b"><code>4814bb2</code></a> (2023-03-07 20:55:26 +0100). </small></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h1>
<p>The maintenance and expansion of this project wouldn’t be possible without the continued commitment and support of:</p>
<ul>
<li>The <a href="https://gbdev.io">gbdev community</a>, for providing precious feedback, content, support and invaluable knowledge.</li>
<li><a href="https://github.com/gbdev/pandocs/graphs/contributors">Contributors</a> of code and content on the Pan Docs project.</li>
<li><a href="https://www.digitalocean.com/">DigitalOcean</a>, for sponsoring this initiative and lifting us from any hosting and infrastructural cost in the last few years.</li>
<li><a href="https://opencollective.com/gbdev">Backers</a>, for allowing us to push the community projects further and spread open culture while staying independent and free.</li>
</ul>
<h2 id="authors"><a class="header" href="#authors">Authors</a></h2>
<p>Antonio Niño Díaz, Antonio Vivace, Beannaich, Cory Sandlin, Eldred “ISSOtm” Habert, Elizafox, Furrtek, Gekkio, Jeff Frohwein, John Harrison, Lior “LIJI32” Halphon, Mantidactyle, Marat Fayzullin, Martin “nocash” Korth, Pan of ATX, Pascal Felber, Paul Robson, T4g1, TechFalcon, endrift, exezin, jrra, kOOPa, mattcurrie, nitro2k01, pinobatch, Pat Fagan, Alvaro Burnett.</p>
<h2 id="special-thanks"><a class="header" href="#special-thanks">Special thanks</a></h2>
<p>FrankenGraphics, zeta0134.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="history"><a class="header" href="#history">History</a></h1>
<p>Pan Docs - also known as <code>GAMEBOY.TXT</code> or <code>GBSPEC.TXT</code> - is an old document dating back to early 1995, originally written by <em>Pan of Anthrox</em>. It has been one of the most important references for Game Boy hackers, emulators and homebrew developers during the last 25 years.</p>
<p align="center">
<img src="https://raw.githubusercontent.com/gbdev/pandocs/master/historical/1995-Jan-28-ATX-GBI/ADDRESS1.png">
<br>
  <i>ADDRESS1.PCX, one of the diagrams attached to the first version, released January 28th, 1995</i>
</p>
<p>After its release (1995-2008), it received a number of revisions, corrections and updates, maintaining its <strong>TXT format</strong>. This <a href="https://github.com/gbdev/pandocs/tree/master/historical">folder</a> provides a historical archive of those versions.</p>
<p>In 2008, a <strong>wikified</strong> version (using Martin Korth’s 2001 revision as a baseline) has been published. The document was split into different articles and it continued being maintained and updated in that form.</p>
<p>In 2020, after the discussion in this <a href="https://github.com/gbdev/pandocs/issues/275">RFC</a> we migrated the last updated version to <strong>plain Markdown</strong> and made <a href="https://github.com/gbdev/pandocs">github.com/gbdev/pandocs</a> the new home of this resource, where it can receive new public discussions and contributions, maintain its legacy and historical relevance, while making use of modern tools and workflows to be visualized and distributed.</p>
<p>From 2020 to May 2021 we used <a href="https://vuepress.github.io/">VuePress</a> to render the markdown files as web pages.</p>
<p>Since May 2021, we rely on <a href="https://rust-lang.github.io/mdBook/">mdBook</a>.</p>
<p>We are releasing everything (content, sources, code, figures) under the CC0 license (Public Domain).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifications"><a class="header" href="#specifications">Specifications</a></h1>
<style>
td {
    text-align: center;
}
td:first-child {
    text-align: left;
}
</style>
<table>
  <thead>
    <tr>
      <th></th><th>Game Boy (DMG)</th><th>Game Boy Pocket (MGB)</th><th>Super Game Boy (SGB)</th><th>Game Boy Color (CGB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CPU</td><td colspan="4">8-bit 8080-like Sharp CPU (speculated to be a SM83 core)</td>
    </tr>
    <tr>
      <td>CPU freq</td><td colspan="2">4.194304&nbsp;MHz</td><td>Depends on revision<sup class="footnote-reference"><a href="#sgb_clk">1</a></sup></td><td>Up to 8.388608&nbsp;MHz</td>
    </tr>
    <tr>
        <td>Work RAM</td><td colspan="3">8&nbsp;KiB</td><td>32&nbsp;KiB<sup class="footnote-reference"><a href="#compat">2</a></sup> (4&nbsp;+&nbsp;7&nbsp;×&nbsp;4&nbsp;KiB)</td>
    </tr>
    <tr>
        <td>Video RAM</td><td colspan="3">8&nbsp;KiB</td><td>16&nbsp;KiB<sup class="footnote-reference"><a href="#compat">2</a></sup> (2&nbsp;×&nbsp;8&nbsp;KiB)</td>
    </tr>
    <tr>
        <td>Screen</td><td>LCD 4.7&nbsp;×&nbsp;4.3&nbsp;cm</td><td>LCD 4.8&nbsp;×&nbsp;4.4&nbsp;cm</td><td>CRT TV</td><td>TFT 4.4&nbsp;×&nbsp;4&nbsp;cm</td>
    </tr>
    <tr>
        <td>Resolution</td><td colspan="2">160&nbsp;×&nbsp;144</td><td>160&nbsp;×&nbsp;144 within 256&nbsp;×&nbsp;224 border</td><td>160&nbsp;×&nbsp;144</td>
    </tr>
    <tr>
        <td>OBJ ("sprites")</td><td colspan="4">8&nbsp;×&nbsp;8 or 8&nbsp;×&nbsp;16 ; max 40 per screen, 10 per line</td>
    </tr>
    <tr>
        <td>Palettes</td><td colspan="2">BG: 1&nbsp;×&nbsp;4, OBJ: 2&nbsp;×&nbsp;3</td><td>BG/OBJ: 1&nbsp;+&nbsp;4&nbsp;×&nbsp;3, border: 4&nbsp;×&nbsp;15</td><td>BG: 8&nbsp;×&nbsp;4, OBJ: 8&nbsp;×&nbsp;3<sup class="footnote-reference"><a href="#compat">2</a></sup></td>
    </tr>
    <tr>
        <td>Colors</td><td>4 shades of green</td><td>4 shades of gray</td><td colspan="2">32768 colors (15-bit RGB)</td>
    </tr>
    <tr>
        <td>Horizontal sync</td><td colspan="2">9.198&nbsp;KHz</td><td>Complicated<sup class="footnote-reference"><a href="#sgb_vid">3</a></sup></td><td>9.198&nbsp;KHz</td>
    </tr>
    <tr>
        <td>Vertical sync</td><td colspan="2">59.73&nbsp;Hz</td><td>Complicated<sup class="footnote-reference"><a href="#sgb_vid">3</a></sup></td><td>59.73&nbsp;Hz</td>
    </tr>
    <tr>
        <td>Sound</td><td colspan="2">4 channels with stereo output</td><td>4 GB channels + SNES audio</td><td>4 channels with stereo output</td>
    </tr>
    <tr>
        <td>Power</td><td>DC 6V, 0.7&nbsp;W</td><td>DC 3V, 0.7&nbsp;W</td><td>Powered by SNES</td><td>DC 3V, 0.6&nbsp;W</td>
    </tr>
  </tbody>
</table>
<div class="footnote-definition" id="sgb_clk"><sup class="footnote-definition-label">1</sup>
<p>SGB1 cartridges derive the GB CPU clock from the SNES’ clock, <a href="#sgb-system-clock">yielding a clock speed a bit higher</a>, which differs slightly between NTSC and PAL systems.
SGB2 instead uses a clock internal to the cartridge, and so has the same speed as the handhelds.</p>
</div>
<div class="footnote-definition" id="compat"><sup class="footnote-definition-label">2</sup>
<p>The same value as on DMG is used in compatibility mode.</p>
</div>
<div class="footnote-definition" id="sgb_vid"><sup class="footnote-definition-label">3</sup>
<p>The SGB runs two consoles: a Game Boy within the SGB cartridge, and the SNES itself.
The GB LCD output is captured and displayed by the SNES, but the two consoles’ frame rates don’t quite sync up, leading to duplicated and/or dropped frames.
The GB side of the vertical sync depends on the CPU clock<sup class="footnote-reference"><a href="#sgb_clk">1</a></sup>, with the same ratio as the handhelds.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-map"><a class="header" href="#memory-map">Memory Map</a></h1>
<p>The Game Boy has a 16-bit address bus, which is used to address ROM, RAM, and I/O.</p>
<div class="table-wrapper"><table><thead><tr><th>Start</th><th>End</th><th>Description</th><th>Notes</th></tr></thead><tbody>
<tr><td>0000</td><td>3FFF</td><td>16 KiB ROM bank 00</td><td>From cartridge, usually a fixed bank</td></tr>
<tr><td>4000</td><td>7FFF</td><td>16 KiB ROM Bank 01~NN</td><td>From cartridge, switchable bank via <a href="#mbcs">mapper</a> (if any)</td></tr>
<tr><td>8000</td><td>9FFF</td><td>8 KiB Video RAM (VRAM)</td><td>In CGB mode, switchable bank 0/1</td></tr>
<tr><td>A000</td><td>BFFF</td><td>8 KiB External RAM</td><td>From cartridge, switchable bank if any</td></tr>
<tr><td>C000</td><td>CFFF</td><td>4 KiB Work RAM (WRAM)</td><td></td></tr>
<tr><td>D000</td><td>DFFF</td><td>4 KiB Work RAM (WRAM)</td><td>In CGB mode, switchable bank 1~7</td></tr>
<tr><td>E000</td><td>FDFF</td><td>Mirror of C000~DDFF (ECHO RAM)</td><td>Nintendo says use of this area is prohibited.</td></tr>
<tr><td>FE00</td><td>FE9F</td><td><a href="#vram-sprite-attribute-table-oam">Sprite attribute table (OAM)</a></td><td></td></tr>
<tr><td>FEA0</td><td>FEFF</td><td>Not Usable</td><td>Nintendo says use of this area is prohibited</td></tr>
<tr><td>FF00</td><td>FF7F</td><td><a href="#io-ranges">I/O Registers</a></td><td></td></tr>
<tr><td>FF80</td><td>FFFE</td><td>High RAM (HRAM)</td><td></td></tr>
<tr><td>FFFF</td><td>FFFF</td><td><a href="#interrupts">Interrupt</a> Enable register (IE)</td><td></td></tr>
</tbody></table>
</div>
<h2 id="jump-vectors-in-first-rom-bank"><a class="header" href="#jump-vectors-in-first-rom-bank">Jump Vectors in first ROM bank</a></h2>
<p>The following addresses are supposed to be used as jump vectors:</p>
<ul>
<li>RST instructions: 0000, 0008, 0010, 0018, 0020, 0028, 0030, 0038</li>
<li>Interrupts: 0040, 0048, 0050, 0058, 0060</li>
</ul>
<p>However, this memory area (0000-00FF) may be used for any other purpose in case that your
program doesn’t use any (or only some) <a href="https://rgbds.gbdev.io/docs/v0.5.2/gbz80.7/#RST_vec"><code>rst</code></a> instructions or interrupts. <code>rst</code>
is a 1-byte instruction that works similarly to the 3-byte <code>call</code> instruction, except
that the destination address is restricted. Since it is 1-byte sized,
it is also slightly faster.</p>
<h2 id="cartridge-header-in-first-rom-bank"><a class="header" href="#cartridge-header-in-first-rom-bank">Cartridge Header in first ROM bank</a></h2>
<p>The memory area at 0100-014F contains the <a href="#the-cartridge-header">cartridge
header</a>. This area contains information
about the program, its entry point, checksums, information about the
used MBC chip, the ROM and RAM sizes, etc. Most of the bytes in this
area are required to be specified correctly.</p>
<h2 id="external-memory-and-hardware"><a class="header" href="#external-memory-and-hardware">External Memory and Hardware</a></h2>
<p>The areas from 0000-7FFF and A000-BFFF address external hardware on
the cartridge, which is essentially an expansion board.  Typically this
is a ROM and SRAM or, more often, a <a href="#mbcs">Memory Bank Controller
(MBC)</a>. The RAM area can be read
from and written to normally; writes to the ROM area control the MBC.
Some MBCs allow mapping of other hardware into the RAM area in this
way.</p>
<p>Cartridge RAM is often battery buffered to hold saved game positions,
high score tables, and other information when the Game Boy is turned
off.  For specific information read the chapter about <a href="#mbcs">Memory Bank
Controllers</a>.</p>
<h2 id="echo-ram"><a class="header" href="#echo-ram">Echo RAM</a></h2>
<p>The range E000-FDFF is mapped to WRAM, but only the lower 13 bits of
the address lines are connected, with the upper bits on the upper bank
set internally in the memory controller by a bank swap register.  This
causes the address to effectively wrap around.  All reads and writes to
this range have the same effect as reads and writes to C000-DDFF.</p>
<p>Nintendo prohibits developers from using this memory range.  The
behavior is confirmed on all official hardware. Some emulators (such as
VisualBoyAdvance &lt;1.8) don’t emulate Echo RAM.  In some flash cartridges,
echo RAM interferes with SRAM normally at A000-BFFF. Software can check if
Echo RAM is properly emulated by writing to RAM (avoid values 00 and
FF) and checking if said value is mirrored in Echo RAM and not cart SRAM.</p>
<h2 id="io-ranges"><a class="header" href="#io-ranges">I/O Ranges</a></h2>
<p>The Game Boy uses the following I/O ranges:</p>
<div class="table-wrapper"><table><thead><tr><th>Start</th><th>End</th><th>First appeared</th><th>Purpose</th></tr></thead><tbody>
<tr><td>$FF00</td><td></td><td>DMG</td><td><a href="#ff00--p1joyp-joypad">Joypad input</a></td></tr>
<tr><td>$FF01</td><td>$FF02</td><td>DMG</td><td><a href="#serial-data-transfer-link-cable">Serial transfer</a></td></tr>
<tr><td>$FF04</td><td>$FF07</td><td>DMG</td><td><a href="#timer-and-divider-registers">Timer and divider</a></td></tr>
<tr><td>$FF10</td><td>$FF26</td><td>DMG</td><td><a href="#audio-registers">Audio</a></td></tr>
<tr><td>$FF30</td><td>$FF3F</td><td>DMG</td><td><a href="#ff30ff3f--wave-pattern-ram">Wave pattern</a></td></tr>
<tr><td>$FF40</td><td>$FF4B</td><td>DMG</td><td>LCD <a href="#ff40--lcdc-lcd-control">Control</a>, <a href="#ff41--stat-lcd-status">Status</a>, <a href="#lcd-position-and-scrolling">Position, Scrolling</a>, and <a href="#palettes">Palettes</a></td></tr>
<tr><td>$FF4F</td><td></td><td>CGB</td><td><a href="#ff4f--vbk-cgb-mode-only-vram-bank">VRAM Bank Select</a></td></tr>
<tr><td>$FF50</td><td></td><td>DMG</td><td>Set to non-zero to disable boot ROM</td></tr>
<tr><td>$FF51</td><td>$FF55</td><td>CGB</td><td><a href="#lcd-vram-dma-transfers">VRAM DMA</a></td></tr>
<tr><td>$FF68</td><td>$FF69</td><td>CGB</td><td><a href="#lcd-color-palettes-cgb-only">BG / OBJ Palettes</a></td></tr>
<tr><td>$FF70</td><td></td><td>CGB</td><td><a href="#ff70--svbk-cgb-mode-only-wram-bank">WRAM Bank Select</a></td></tr>
</tbody></table>
</div>
<h2 id="fea0-feff-range"><a class="header" href="#fea0-feff-range">FEA0-FEFF range</a></h2>
<p>Nintendo indicates use of this area is prohibited.  This area returns
$FF when OAM is blocked, and otherwise the behavior depends on the
hardware revision.</p>
<ul>
<li>
<p>On DMG, MGB, SGB, and SGB2, reads during OAM block trigger <a href="#oam-corruption-bug">OAM corruption</a>.
Reads otherwise return $00.</p>
</li>
<li>
<p>On CGB revisions 0-D, this area is a unique RAM area, but is masked
with a revision-specific value.</p>
</li>
<li>
<p>On CGB revision E, AGB, AGS, and GBP, it returns the high nibble of the
lower address byte twice, e.g. FFAx returns $AA, FFBx returns $BB, and so
forth.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-registers"><a class="header" href="#hardware-registers">Hardware Registers</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Address</th><th>Name</th><th>Description</th><th>Readable / Writable</th><th>Models</th></tr></thead><tbody>
<tr><td>$FF00</td><td><a href="#ff00--p1joyp-joypad">P1/JOYP</a></td><td>Joypad</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF01</td><td><a href="#ff01--sb-serial-transfer-data">SB</a></td><td>Serial transfer data</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF02</td><td><a href="#ff02--sc-serial-transfer-control">SC</a></td><td>Serial transfer control</td><td>R/W</td><td>Mixed</td></tr>
<tr><td>$FF04</td><td><a href="#ff04--div-divider-register">DIV</a></td><td>Divider register</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF05</td><td><a href="#ff05--tima-timer-counter">TIMA</a></td><td>Timer counter</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF06</td><td><a href="#ff06--tma-timer-modulo">TMA</a></td><td>Timer modulo</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF07</td><td><a href="#ff07--tac-timer-control">TAC</a></td><td>Timer control</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF0F</td><td><a href="#ff0f--if-interrupt-flag">IF</a></td><td>Interrupt flag</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF10</td><td><a href="#ff10--nr10-channel-1-sweep">NR10</a></td><td>Sound channel 1 sweep</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF11</td><td><a href="#ff11--nr11-channel-1-length-timer--duty-cycle">NR11</a></td><td>Sound channel 1 length timer &amp; duty cycle</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF12</td><td><a href="#ff12--nr12-channel-1-volume--envelope">NR12</a></td><td>Sound channel 1 volume &amp; envelope</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF13</td><td><a href="#ff13--nr13-channel-1-wavelength-low-write-only">NR13</a></td><td>Sound channel 1 wavelength low</td><td>W</td><td>All</td></tr>
<tr><td>$FF14</td><td><a href="#ff14--nr14-channel-1-wavelength-high--control">NR14</a></td><td>Sound channel 1 wavelength high &amp; control</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF16</td><td><a href="#sound-channel-2--pulse">NR21</a></td><td>Sound channel 2 length timer &amp; duty cycle</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF17</td><td><a href="#sound-channel-2--pulse">NR22</a></td><td>Sound channel 2 volume &amp; envelope</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF18</td><td><a href="#sound-channel-2--pulse">NR23</a></td><td>Sound channel 2 wavelength low</td><td>W</td><td>All</td></tr>
<tr><td>$FF19</td><td><a href="#sound-channel-2--pulse">NR24</a></td><td>Sound channel 2 wavelength high &amp; control</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF1A</td><td><a href="#ff1a--nr30-channel-3-dac-enable">NR30</a></td><td>Sound channel 3 DAC enable</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF1B</td><td><a href="#ff1b--nr31-channel-3-length-timer-write-only">NR31</a></td><td>Sound channel 3 length timer</td><td>W</td><td>All</td></tr>
<tr><td>$FF1C</td><td><a href="#ff1c--nr32-channel-3-output-level">NR32</a></td><td>Sound channel 3 output level</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF1D</td><td><a href="#ff1d--nr33-channel-3-wavelength-low-write-only">NR33</a></td><td>Sound channel 3 wavelength low</td><td>W</td><td>All</td></tr>
<tr><td>$FF1E</td><td><a href="#ff1e--nr34-channel-3-wavelength-high--control">NR34</a></td><td>Sound channel 3 wavelength high &amp; control</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF20</td><td><a href="#ff20--nr41-channel-4-length-timer-write-only">NR41</a></td><td>Sound channel 4 length timer</td><td>W</td><td>All</td></tr>
<tr><td>$FF21</td><td><a href="#ff21--nr42-channel-4-volume--envelope">NR42</a></td><td>Sound channel 4 volume &amp; envelope</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF22</td><td><a href="#ff22--nr43-channel-4-frequency--randomness">NR43</a></td><td>Sound channel 4 frequency &amp; randomness</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF23</td><td><a href="#ff23--nr44-channel-4-control">NR44</a></td><td>Sound channel 4 control</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF24</td><td><a href="#ff24--nr50-master-volume--vin-panning">NR50</a></td><td>Master volume &amp; VIN panning</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF25</td><td><a href="#ff25--nr51-sound-panning">NR51</a></td><td>Sound panning</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF26</td><td><a href="#ff26--nr52-sound-onoff">NR52</a></td><td>Sound on/off</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF30-FF3F</td><td><a href="#ff30ff3f--wave-pattern-ram">Wave RAM</a></td><td>Storage for one of the sound channels’ waveform</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF40</td><td><a href="#ff40--lcdc-lcd-control">LCDC</a></td><td>LCD control</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF41</td><td><a href="#ff41--stat-lcd-status">STAT</a></td><td>LCD status</td><td>Mixed</td><td>All</td></tr>
<tr><td>$FF42</td><td><a href="#ff42ff43--scy-scx-viewport-y-position-x-position">SCY</a></td><td>Viewport Y position</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF43</td><td><a href="#ff42ff43--scy-scx-viewport-y-position-x-position">SCX</a></td><td>Viewport X position</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF44</td><td><a href="#ff44--ly-lcd-y-coordinate-read-only">LY</a></td><td>LCD Y coordinate</td><td>R</td><td>All</td></tr>
<tr><td>$FF45</td><td><a href="#ff45--lyc-ly-compare">LYC</a></td><td>LY compare</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF46</td><td><a href="#ff46--dma-oam-dma-source-address--start">DMA</a></td><td>OAM DMA source address &amp; start</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF47</td><td><a href="#ff47--bgp-non-cgb-mode-only-bg-palette-data">BGP</a></td><td>BG palette data</td><td>R/W</td><td>DMG</td></tr>
<tr><td>$FF48</td><td><a href="#ff48ff49--obp0-obp1-non-cgb-mode-only-obj-palette-0-1-data">OBP0</a></td><td>OBJ palette 0 data</td><td>R/W</td><td>DMG</td></tr>
<tr><td>$FF49</td><td><a href="#ff48ff49--obp0-obp1-non-cgb-mode-only-obj-palette-0-1-data">OBP1</a></td><td>OBJ palette 1 data</td><td>R/W</td><td>DMG</td></tr>
<tr><td>$FF4A</td><td><a href="#ff4aff4b--wy-wx-window-y-position-x-position-plus-7">WY</a></td><td>Window Y position</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF4B</td><td><a href="#ff4aff4b--wy-wx-window-y-position-x-position-plus-7">WX</a></td><td>Window X position plus 7</td><td>R/W</td><td>All</td></tr>
<tr><td>$FF4D</td><td><a href="#ff4d--key1-cgb-mode-only-prepare-speed-switch">KEY1</a></td><td>Prepare speed switch</td><td>Mixed</td><td>CGB</td></tr>
<tr><td>$FF4F</td><td><a href="#ff4f--vbk-cgb-mode-only-vram-bank">VBK</a></td><td>VRAM bank</td><td>R/W</td><td>CGB</td></tr>
<tr><td>$FF51</td><td><a href="#ff51ff52--hdma1-hdma2-cgb-mode-only-vram-dma-source-high-low-write-only">HDMA1</a></td><td>VRAM DMA source high</td><td>W</td><td>CGB</td></tr>
<tr><td>$FF52</td><td><a href="#ff51ff52--hdma1-hdma2-cgb-mode-only-vram-dma-source-high-low-write-only">HDMA2</a></td><td>VRAM DMA source low</td><td>W</td><td>CGB</td></tr>
<tr><td>$FF53</td><td><a href="#ff53ff54--hdma3-hdma4-cgb-mode-only-vram-dma-destination-high-low-write-only">HDMA3</a></td><td>VRAM DMA destination high</td><td>W</td><td>CGB</td></tr>
<tr><td>$FF54</td><td><a href="#ff53ff54--hdma3-hdma4-cgb-mode-only-vram-dma-destination-high-low-write-only">HDMA4</a></td><td>VRAM DMA destination low</td><td>W</td><td>CGB</td></tr>
<tr><td>$FF55</td><td><a href="#ff55--hdma5-cgb-mode-only-vram-dma-lengthmodestart">HDMA5</a></td><td>VRAM DMA length/mode/start</td><td>R/W</td><td>CGB</td></tr>
<tr><td>$FF56</td><td><a href="#ff56--rp-cgb-mode-only-infrared-communications-port">RP</a></td><td>Infrared communications port</td><td>Mixed</td><td>CGB</td></tr>
<tr><td>$FF68</td><td><a href="#ff68--bcpsbgpi-cgb-mode-only-background-color-palette-specification--background-palette-index">BCPS/BGPI</a></td><td>Background color palette specification / Background palette index</td><td>R/W</td><td>CGB</td></tr>
<tr><td>$FF69</td><td><a href="#ff69--bcpdbgpd-cgb-mode-only-background-color-palette-data--background-palette-data">BCPD/BGPD</a></td><td>Background color palette data / Background palette data</td><td>R/W</td><td>CGB</td></tr>
<tr><td>$FF6A</td><td><a href="#ff6aff6b--ocpsobpi-ocpdobpd-cgb-mode-only-obj-color-palette-specification--obj-palette-index-obj-color-palette-data--obj-palette-data">OCPS/OBPI</a></td><td>OBJ color palette specification / OBJ palette index</td><td>R/W</td><td>CGB</td></tr>
<tr><td>$FF6B</td><td><a href="#ff6aff6b--ocpsobpi-ocpdobpd-cgb-mode-only-obj-color-palette-specification--obj-palette-index-obj-color-palette-data--obj-palette-data">OCPD/OBPD</a></td><td>OBJ color palette data / OBJ palette data</td><td>R/W</td><td>CGB</td></tr>
<tr><td>$FF6C</td><td><a href="#ff6c--opri-cgb-mode-only-object-priority-mode">OPRI</a></td><td>Object priority mode</td><td>R/W</td><td>CGB</td></tr>
<tr><td>$FF70</td><td><a href="#ff70--svbk-cgb-mode-only-wram-bank">SVBK</a></td><td>WRAM bank</td><td>R/W</td><td>CGB</td></tr>
<tr><td>$FF76</td><td><a href="#ff76--pcm12-cgb-mode-only-digital-outputs-1--2-read-only">PCM12</a></td><td>Audio digital outputs 1 &amp; 2</td><td>R</td><td>CGB</td></tr>
<tr><td>$FF77</td><td><a href="#ff77--pcm34-cgb-mode-only-digital-outputs-3--4-read-only">PCM34</a></td><td>Audio digital outputs 3 &amp; 4</td><td>R</td><td>CGB</td></tr>
<tr><td>$FFFF</td><td><a href="#ffff--ie-interrupt-enable">IE</a></td><td>Interrupt enable</td><td>R/W</td><td>All</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-overview"><a class="header" href="#rendering-overview">Rendering Overview</a></h1>
<p>The Game Boy outputs graphics to a 160x144 pixel LCD, using a quite complex
mechanism to facilitate rendering.</p>
<div class="box warning">
<p class="box-title">Terminology</p><p>Sprites/graphics terminology can vary a lot among different platforms, consoles,
users and communities. You may be familiar with slightly different definitions.
Keep also in mind that some definitions refer to lower (hardware) tools
and some others to higher abstractions concepts.</p>
</div>
<h2 id="tiles"><a class="header" href="#tiles">Tiles</a></h2>
<p>Similarly to other retro systems, pixels are not manipulated
individually, as this would be expensive CPU-wise. Instead, pixels are grouped
in 8x8 squares, called <em>tiles</em> (or sometimes “patterns”), often considered as
the base unit in Game Boy graphics.</p>
<p>A tile does not encode color information. Instead, a tile assigns a
<em>color ID</em> to each of its pixels, ranging from 0 to 3. For this reason,
Game Boy graphics are also called <em>2bpp</em> (2 bits per pixel). When a tile is used
in the Background or Window, these color IDs are associated with a <em>palette</em>. When
a tile is used in an OBJ, the IDs 1 to 3 are associated with a palette, but
ID 0 means transparent.</p>
<h2 id="palettes"><a class="header" href="#palettes">Palettes</a></h2>
<p>A palette consists of an array of colors, 4 in the Game Boy’s case.
Palettes are stored differently in monochrome and color versions of the console.</p>
<p>Modifying palettes enables graphical effects such as quickly flashing some graphics (damage,
invulnerability, thunderstorm, etc.), fading the screen, “palette swaps”, and more.</p>
<h2 id="layers"><a class="header" href="#layers">Layers</a></h2>
<p>The Game Boy has three “layers”, from back to front: the Background, the Window,
and the Objects. Some features and behaviors break this abstraction,
but it works for the most part.</p>
<h3 id="background"><a class="header" href="#background">Background</a></h3>
<p>The background is composed of a <em>tilemap</em>. A tilemap is a
large grid of tiles. However, tiles aren’t directly written to tilemaps,
they merely contain references to the tiles.
This makes reusing tiles very cheap, both in CPU time and in
required memory space, and it is the main mechanism that helps work around the
paltry 8 KiB of video RAM.</p>
<p>The background can be made to scroll as a whole, writing to two
hardware registers. This makes scrolling very cheap.</p>
<h3 id="window"><a class="header" href="#window">Window</a></h3>
<p>The window is sort of a second background layer on top of the background.
It is fairly limited: it has no transparency, it’s always a
rectangle and only the position of the top-left pixel can be controlled.</p>
<p>Possible usage include a fixed status bar in an otherwise scrolling game (e.g.
<em>Super Mario Bros. 3</em>).</p>
<h3 id="objects"><a class="header" href="#objects">Objects</a></h3>
<p>The background layer is useful for elements scrolling as a whole, but
it’s impractical for objects that need to move separately, such as the player.</p>
<p>The <em>objects</em> layer is designed to fill this gap: <em>objects</em> are made of 1 or 2 stacked tiles (8x8 or 8x16 pixels)
and can be displayed anywhere on the screen.</p>
<div class="box tip">
<p class="box-title">NOTE</p><p>Several objects can be combined (they can be called <em>metasprites</em>) to draw
a larger graphical element, usually called “sprite”. Originally, the term “sprites”
referred to fixed-sized objects composited together, by hardware, with a background.
Use of the term has since become more general.</p>
</div>
<p>To summarise:</p>
<ul>
<li><strong>Tile</strong>, an 8x8-pixel chunk of graphics.</li>
<li><strong>Object</strong>, an entry in object attribute memory, composed of 1 or 2
tiles. Independent of the background.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vram-tile-data"><a class="header" href="#vram-tile-data">VRAM Tile Data</a></h1>
<p>Tile data is stored in VRAM in the memory area at $8000-$97FF; with each tile
taking 16 bytes, this area defines data for 384 tiles. In CGB Mode,
this is doubled (768 tiles) because of the two VRAM banks.</p>
<p>Each tile has 8x8 pixels and has a color depth of 4 colors/gray
shades. Tiles can be displayed as part of the Background/Window maps,
and/or as OBJ tiles (foreground sprites). Note that OBJs
don’t use color 0 - it’s transparent instead.</p>
<p>There are three “blocks” of 128 tiles each:</p>
<table>
  <thead>
    <tr>
      <th rowspan="2">Block</th>
      <th rowspan="2">VRAM Address</th>
      <th colspan="3">Corresponding Tile IDs</th>
    </tr>
    <tr>
      <td>OBJs</td>
      <td>BG/Win if LCDC.4=1</td>
      <td>BG/Win if LCDC.4=0</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>$8000&ndash;$87FF</td>
      <td>0&ndash;127</td>
      <td>0&ndash;127</td>
      <td></td>
    </tr>
    <tr>
      <td>1</td>
      <td>$8800&ndash;$8FFF</td>
      <td>128&ndash;255</td>
      <td>128&ndash;255</td>
      <td>
        128&ndash;255 <br />
        (or -128&ndash;-1)
      </td>
    </tr>
    <tr>
      <td>2</td>
      <td>$9000&ndash;$97FF</td>
      <td colspan="2">(Can't use)</td>
      <td>0&ndash;127</td>
    </tr>
  </tbody>
</table>
<p>Tiles are always indexed using an 8-bit integer, but the addressing
method may differ. The “$8000 method” uses $8000 as its base pointer
and uses an unsigned addressing, meaning that tiles 0-127 are in block
0, and tiles 128-255 are in block 1. The “$8800 method” uses $9000 as
its base pointer and uses a signed addressing, meaning that tiles 0-127
are in block 2, and tiles -128 to -1 are in block 1, or to put it differently,
“$8800 addressing” takes tiles 0-127 from block 2
and tiles 128-255 from block 1. (You can notice that block 1 is shared
by both addressing methods)</p>
<p>Sprites always use “$8000 addressing”, but the BG and Window can use either
mode, controlled by <a href="#lcdc4--bg-and-window-tile-data-area">LCDC bit 4</a>.</p>
<p>Each tile occupies 16 bytes, where each line is represented by 2 bytes:</p>
<pre><code>Byte 0-1  Topmost Line (Top 8 pixels)
Byte 2-3  Second Line
etc.
</code></pre>
<p>For each line, the first byte specifies the least significant bit of the color
ID of each pixel, and the second byte specifies the most significant bit. In
both bytes, bit 7 represents the leftmost pixel, and bit 0 the rightmost. For
example, the tile data <code>$3C $7E $42 $42 $42 $42 $42 $42 $7E $5E $7E $0A $7C $56 $38 $7C</code> appears as follows:</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" width="480" height="200" viewBox="0 0 480 200">
  <defs>
    <style>
      text {
        font-family: monospace;
        font-size: 13px;
        text-anchor: middle;
        dominant-baseline: central;
        fill: var(--fg)
      }
      .c0 { fill: #081820 }
      .c1 { fill: #346856 }
      .c2 { fill: #88c070 }
      .c3 { fill: #e0f8d0 }
    </style>
  </defs>
  <g transform="translate(40, 100)">
    <text y="-70">$3C $7E</text>
    <text y="-50">$42 $42</text>
    <text y="-30">$42 $42</text>
    <text y="-10">$42 $42</text>
    <text y="10">$7E $5E</text>
    <text y="30">$7E $0A</text>
    <text y="50">$7C $56</text>
    <text y="70">$38 $7C</text>
  </g>
  <text x="85" y="100">=</text>
  <g transform="translate(140, 100)">
    <rect class="c0" x="-40" y="-80" width="80" height="160"/>
    <path class="c1" d="M-20,-80h40v20h10v100h-10v20h-10v20h-30v-20h-10v-120h10v60h40v-60h-40z"/>
    <text x="-35" y="-90">a</text>
    <text x="-25" y="-90">b</text>
    <text x="-15" y="-90">c</text>
    <text x="-5" y="-90">d</text>
    <text x="5" y="-90">e</text>
    <text x="15" y="-90">f</text>
    <text x="25" y="-90">g</text>
    <text x="35" y="-90">h</text>
    <text class="c3" x="-35" y="-70">0</text>
    <text class="c3" x="-25" y="-70">0</text>
    <text class="c3" x="-15" y="-70">1</text>
    <text class="c3" x="-5" y="-70">1</text>
    <text class="c3" x="5" y="-70">1</text>
    <text class="c3" x="15" y="-70">1</text>
    <text class="c3" x="25" y="-70">0</text>
    <text class="c3" x="35" y="-70">0</text>
    <text class="c3" x="-35" y="-50">0</text>
    <text class="c3" x="-25" y="-50">1</text>
    <text class="c3" x="-15" y="-50">0</text>
    <text class="c3" x="-5" y="-50">0</text>
    <text class="c3" x="5" y="-50">0</text>
    <text class="c3" x="15" y="-50">0</text>
    <text class="c3" x="25" y="-50">1</text>
    <text class="c3" x="35" y="-50">0</text>
    <text class="c3" x="-35" y="-30">0</text>
    <text class="c3" x="-25" y="-30">1</text>
    <text class="c3" x="-15" y="-30">0</text>
    <text class="c3" x="-5" y="-30">0</text>
    <text class="c3" x="5" y="-30">0</text>
    <text class="c3" x="15" y="-30">0</text>
    <text class="c3" x="25" y="-30">1</text>
    <text class="c3" x="35" y="-30">0</text>
    <text class="c3" x="-35" y="-10">0</text>
    <text class="c3" x="-25" y="-10">1</text>
    <text class="c3" x="-15" y="-10">0</text>
    <text class="c3" x="-5" y="-10">0</text>
    <text class="c3" x="5" y="-10">0</text>
    <text class="c3" x="15" y="-10">0</text>
    <text class="c3" x="25" y="-10">1</text>
    <text class="c3" x="35" y="-10">0</text>
    <text class="c3" x="-35" y="10">0</text>
    <text class="c3" x="-25" y="10">1</text>
    <text class="c3" x="-15" y="10">1</text>
    <text class="c3" x="-5" y="10">1</text>
    <text class="c3" x="5" y="10">1</text>
    <text class="c3" x="15" y="10">1</text>
    <text class="c3" x="25" y="10">1</text>
    <text class="c3" x="35" y="10">0</text>
    <text class="c3" x="-35" y="30">0</text>
    <text class="c3" x="-25" y="30">1</text>
    <text class="c3" x="-15" y="30">1</text>
    <text class="c3" x="-5" y="30">1</text>
    <text class="c3" x="5" y="30">1</text>
    <text class="c3" x="15" y="30">1</text>
    <text class="c3" x="25" y="30">1</text>
    <text class="c3" x="35" y="30">0</text>
    <text class="c3" x="-35" y="50">0</text>
    <text class="c3" x="-25" y="50">1</text>
    <text class="c3" x="-15" y="50">1</text>
    <text class="c3" x="-5" y="50">1</text>
    <text class="c3" x="5" y="50">1</text>
    <text class="c3" x="15" y="50">1</text>
    <text class="c3" x="25" y="50">0</text>
    <text class="c3" x="35" y="50">0</text>
    <text class="c3" x="-35" y="70">0</text>
    <text class="c3" x="-25" y="70">0</text>
    <text class="c3" x="-15" y="70">1</text>
    <text class="c3" x="-5" y="70">1</text>
    <text class="c3" x="5" y="70">1</text>
    <text class="c3" x="15" y="70">0</text>
    <text class="c3" x="25" y="70">0</text>
    <text class="c3" x="35" y="70">0</text>
    <text x="-35" y="90">a</text>
    <text x="-25" y="90">b</text>
    <text x="-15" y="90">c</text>
    <text x="-5" y="90">d</text>
    <text x="5" y="90">e</text>
    <text x="15" y="90">f</text>
    <text x="25" y="90">g</text>
    <text x="35" y="90">h</text>
  </g>
  <text x="190" y="100">+</text>
  <g transform="translate(240, 100)">
    <rect class="c0" x="-40" y="-80" width="80" height="160"/>
    <path class="c2" d="M-30,-80h60v140h-10v20h-50v-40h10v20h10v-20h10v20h10v-20h10v-20h-10v20h-10v-20h-10v-20h30v-60h-40v80h-10z"/>
    <text x="-35" y="-90">i</text>
    <text x="-25" y="-90">j</text>
    <text x="-15" y="-90">k</text>
    <text x="-5" y="-90">l</text>
    <text x="5" y="-90">m</text>
    <text x="15" y="-90">n</text>
    <text x="25" y="-90">o</text>
    <text x="35" y="-90">p</text>
    <text class="c3" x="-35" y="-70">0</text>
    <text class="c0" x="-25" y="-70">1</text>
    <text class="c0" x="-15" y="-70">1</text>
    <text class="c0" x="-5" y="-70">1</text>
    <text class="c0" x="5" y="-70">1</text>
    <text class="c0" x="15" y="-70">1</text>
    <text class="c0" x="25" y="-70">1</text>
    <text class="c3" x="35" y="-70">0</text>
    <text class="c3" x="-35" y="-50">0</text>
    <text class="c0" x="-25" y="-50">1</text>
    <text class="c3" x="-15" y="-50">0</text>
    <text class="c3" x="-5" y="-50">0</text>
    <text class="c3" x="5" y="-50">0</text>
    <text class="c3" x="15" y="-50">0</text>
    <text class="c0" x="25" y="-50">1</text>
    <text class="c3" x="35" y="-50">0</text>
    <text class="c3" x="-35" y="-30">0</text>
    <text class="c0" x="-25" y="-30">1</text>
    <text class="c3" x="-15" y="-30">0</text>
    <text class="c3" x="-5" y="-30">0</text>
    <text class="c3" x="5" y="-30">0</text>
    <text class="c3" x="15" y="-30">0</text>
    <text class="c0" x="25" y="-30">1</text>
    <text class="c3" x="35" y="-30">0</text>
    <text class="c3" x="-35" y="-10">0</text>
    <text class="c0" x="-25" y="-10">1</text>
    <text class="c3" x="-15" y="-10">0</text>
    <text class="c3" x="-5" y="-10">0</text>
    <text class="c3" x="5" y="-10">0</text>
    <text class="c3" x="15" y="-10">0</text>
    <text class="c0" x="25" y="-10">1</text>
    <text class="c3" x="35" y="-10">0</text>
    <text class="c3" x="-35" y="10">0</text>
    <text class="c0" x="-25" y="10">1</text>
    <text class="c3" x="-15" y="10">0</text>
    <text class="c0" x="-5" y="10">1</text>
    <text class="c0" x="5" y="10">1</text>
    <text class="c0" x="15" y="10">1</text>
    <text class="c0" x="25" y="10">1</text>
    <text class="c3" x="35" y="10">0</text>
    <text class="c3" x="-35" y="30">0</text>
    <text class="c3" x="-25" y="30">0</text>
    <text class="c3" x="-15" y="30">0</text>
    <text class="c3" x="-5" y="30">0</text>
    <text class="c0" x="5" y="30">1</text>
    <text class="c3" x="15" y="30">0</text>
    <text class="c0" x="25" y="30">1</text>
    <text class="c3" x="35" y="30">0</text>
    <text class="c3" x="-35" y="50">0</text>
    <text class="c0" x="-25" y="50">1</text>
    <text class="c3" x="-15" y="50">0</text>
    <text class="c0" x="-5" y="50">1</text>
    <text class="c3" x="5" y="50">0</text>
    <text class="c0" x="15" y="50">1</text>
    <text class="c0" x="25" y="50">1</text>
    <text class="c3" x="35" y="50">0</text>
    <text class="c3" x="-35" y="70">0</text>
    <text class="c0" x="-25" y="70">1</text>
    <text class="c0" x="-15" y="70">1</text>
    <text class="c0" x="-5" y="70">1</text>
    <text class="c0" x="5" y="70">1</text>
    <text class="c0" x="15" y="70">1</text>
    <text class="c3" x="25" y="70">0</text>
    <text class="c3" x="35" y="70">0</text>
    <text x="-35" y="90">i</text>
    <text x="-25" y="90">j</text>
    <text x="-15" y="90">k</text>
    <text x="-5" y="90">l</text>
    <text x="5" y="90">m</text>
    <text x="15" y="90">n</text>
    <text x="25" y="90">o</text>
    <text x="35" y="90">p</text>
  </g>
  <text x="295" y="100">=</text>
  <g transform="translate(390, 100)">
    <rect class="c0" x="-80" y="-80" width="160" height="160"/>
    <path class="c1" d="M-40,0h20v20h20v20h20v-20h20v20h-20v20h-20v-20h-20v20h-20v-20h-20v-20h20z"/>
    <path class="c2" d="M-60,-80h20v20h-20zM40-80h20v20h-20zM40,40h20v20h-20v20h-20v-20h20zM-60,60h20v20h-20z"/>
    <path class="c3" d="M-40,-80h80v20h20v100h-20v20h-20v20h-60v-20h-20v-20h20v20h20v-20h20v20h20v-20h20v-20h-20v20h-20v-20h-20v-20h60v-60h-80v80h-20v-80h20z"/>
    <text x="-70" y="-90">ia</text>
    <text x="-50" y="-90">jb</text>
    <text x="-30" y="-90">kc</text>
    <text x="-10" y="-90">ld</text>
    <text x="10" y="-90">me</text>
    <text x="30" y="-90">nf</text>
    <text x="50" y="-90">og</text>
    <text x="70" y="-90">ph</text>
    <text class="c3" x="-70" y="-70">00</text>
    <text class="c0" x="-50" y="-70">10</text>
    <text class="c0" x="-30" y="-70">11</text>
    <text class="c0" x="-10" y="-70">11</text>
    <text class="c0" x="10" y="-70">11</text>
    <text class="c0" x="30" y="-70">11</text>
    <text class="c0" x="50" y="-70">10</text>
    <text class="c3" x="70" y="-70">00</text>
    <text class="c3" x="-70" y="-50">00</text>
    <text class="c0" x="-50" y="-50">11</text>
    <text class="c3" x="-30" y="-50">00</text>
    <text class="c3" x="-10" y="-50">00</text>
    <text class="c3" x="10" y="-50">00</text>
    <text class="c3" x="30" y="-50">00</text>
    <text class="c0" x="50" y="-50">11</text>
    <text class="c3" x="70" y="-50">00</text>
    <text class="c3" x="-70" y="-30">00</text>
    <text class="c0" x="-50" y="-30">11</text>
    <text class="c3" x="-30" y="-30">00</text>
    <text class="c3" x="-10" y="-30">00</text>
    <text class="c3" x="10" y="-30">00</text>
    <text class="c3" x="30" y="-30">00</text>
    <text class="c0" x="50" y="-30">11</text>
    <text class="c3" x="70" y="-30">00</text>
    <text class="c3" x="-70" y="-10">00</text>
    <text class="c0" x="-50" y="-10">11</text>
    <text class="c3" x="-30" y="-10">00</text>
    <text class="c3" x="-10" y="-10">00</text>
    <text class="c3" x="10" y="-10">00</text>
    <text class="c3" x="30" y="-10">00</text>
    <text class="c0" x="50" y="-10">11</text>
    <text class="c3" x="70" y="-10">00</text>
    <text class="c3" x="-70" y="10">00</text>
    <text class="c0" x="-50" y="10">11</text>
    <text class="c3" x="-30" y="10">01</text>
    <text class="c0" x="-10" y="10">11</text>
    <text class="c0" x="10" y="10">11</text>
    <text class="c0" x="30" y="10">11</text>
    <text class="c0" x="50" y="10">11</text>
    <text class="c3" x="70" y="10">00</text>
    <text class="c3" x="-70" y="30">00</text>
    <text class="c3" x="-50" y="30">01</text>
    <text class="c3" x="-30" y="30">01</text>
    <text class="c3" x="-10" y="30">01</text>
    <text class="c0" x="10" y="30">11</text>
    <text class="c3" x="30" y="30">01</text>
    <text class="c0" x="50" y="30">11</text>
    <text class="c3" x="70" y="30">00</text>
    <text class="c3" x="-70" y="50">00</text>
    <text class="c0" x="-50" y="50">11</text>
    <text class="c3" x="-30" y="50">01</text>
    <text class="c0" x="-10" y="50">11</text>
    <text class="c3" x="10" y="50">01</text>
    <text class="c0" x="30" y="50">11</text>
    <text class="c0" x="50" y="50">10</text>
    <text class="c3" x="70" y="50">00</text>
    <text class="c3" x="-70" y="70">00</text>
    <text class="c0" x="-50" y="70">10</text>
    <text class="c0" x="-30" y="70">11</text>
    <text class="c0" x="-10" y="70">11</text>
    <text class="c0" x="10" y="70">11</text>
    <text class="c0" x="30" y="70">10</text>
    <text class="c3" x="50" y="70">00</text>
    <text class="c3" x="70" y="70">00</text>
    <text x="-70" y="90">ia</text>
    <text x="-50" y="90">jb</text>
    <text x="-30" y="90">kc</text>
    <text x="-10" y="90">ld</text>
    <text x="10" y="90">me</text>
    <text x="30" y="90">nf</text>
    <text x="50" y="90">og</text>
    <text x="70" y="90">ph</text>
  </g>
</svg>
<figcaption>Sample tile data</figcaption>
</figure>
<p>For the first row, the values <code>$3C $7E</code> are <code>00111100</code> and <code>01111110</code> in
binary. The leftmost bits are 0 and 0, thus the color ID is binary <code>00</code>, or 0.
The next bits are 0 and 1, thus the color ID is binary <code>10</code>, or 2 (remember to
flip the order of the bits!). The full eight-pixel row evaluates to 0 2 3 3 3 3
2 0.</p>
<p>A tool for viewing tiles can be found
<a href="https://www.huderlem.com/demos/gameboy2bpp.html">here</a>.</p>
<p>So, each pixel has a color ID of 0 to 3. The color
numbers are translated into real colors (or gray shades) depending on
the current palettes, except that when the tile is used in an OBJ the
color ID 0 means transparent. The palettes are defined through registers
<a href="#ff47--bgp-non-cgb-mode-only-bg-palette-data">BGP</a>,
<a href="#ff48ff49--obp0-obp1-non-cgb-mode-only-obj-palette-0-1-data">OBP0 and OBP1</a>, and
<a href="#ff68--bcpsbgpi-cgb-mode-only-background-color-palette-specification--background-palette-index">BCPS/BGPI</a>,
<a href="#ff69--bcpdbgpd-cgb-mode-only-background-color-palette-data--background-palette-data">BCPD/BGPD</a>,
<a href="#ff6aff6b--ocpsobpi-ocpdobpd-cgb-mode-only-obj-color-palette-specification--obj-palette-index-obj-color-palette-data--obj-palette-data">OCPS/OBPI and OCPD/OBPD</a>
(CGB Mode).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vram-tile-maps"><a class="header" href="#vram-tile-maps">VRAM Tile Maps</a></h1>
<p>The Game Boy contains two 32x32 tile maps in VRAM at
the memory areas <code>$9800-$9BFF</code> and <code>$9C00-$9FFF</code>. Any of these maps can be used to
display the Background or the Window.</p>
<h2 id="tile-indexes"><a class="header" href="#tile-indexes">Tile Indexes</a></h2>
<p>Each tile map contains the 1-byte indexes of the
tiles to be displayed.</p>
<p>Tiles are obtained from the Tile Data Table using either of the two
addressing modes (described in <a href="#vram-tile-data">VRAM Tile Data</a>), which
can be selected via <a href="#ff40--lcdc-lcd-control">the LCDC register</a>.</p>
<p>Since one tile has 8x8 pixels, each map holds a 256x256 pixels picture.
Only 160x144 of those pixels are displayed on the LCD at any given time.</p>
<h2 id="bg-map-attributes-cgb-mode-only"><a class="header" href="#bg-map-attributes-cgb-mode-only">BG Map Attributes (CGB Mode only)</a></h2>
<p>In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1
(each byte defines attributes for the corresponding tile-number map
entry in VRAM Bank 0, that is, 1:9800 defines the attributes for the tile at
0:9800):</p>
<pre><code>Bit 7    BG-to-OAM Priority         (0=Use OAM Priority bit, 1=BG Priority)
Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
Bit 4    Not used
Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
Bit 2-0  Background Palette number  (BGP0-7)
</code></pre>
<p>Note that, if the map entry at <code>0:9800</code> is tile $2A, the attribute at
<code>1:9800</code> doesn’t define properties for ALL tiles $2A on-screen, but only
the one at <code>0:9800</code>!</p>
<h3 id="bg-to-obj-priority-in-cgb-mode"><a class="header" href="#bg-to-obj-priority-in-cgb-mode">BG-to-OBJ Priority in CGB Mode</a></h3>
<p>In CGB Mode, the priority between the BG (and window) layer and the OBJ layer is declared in three different places:</p>
<ul>
<li><a href="#bg-map-attributes-cgb-mode-only">BG Map Attribute bit 7</a></li>
<li><a href="#lcdc0--bg-and-window-enablepriority">LCDC bit 0</a></li>
<li><a href="#byte-3--attributesflags">OAM Attributes bit 7</a></li>
</ul>
<p>We can infer the following rules from the table below:</p>
<ul>
<li>If the BG color index is 0, the OBJ will always have priority;</li>
<li>Otherwise, if LCDC bit 0 is clear, the OBJ will always have priority;</li>
<li>Otherwise, if both the BG Attributes and the OAM Attributes have bit 7 clear, the OBJ will have priority;</li>
<li>Otherwise, BG will have priority.</li>
</ul>
<p>The following table shows the relations between the 3 flags:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">LCDC bit 0</th><th style="text-align: center">OAM attr bit 7</th><th style="text-align: center">BG attr bit 7</th><th>Priority</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td>OBJ</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td>OBJ</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td>OBJ</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td>OBJ</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td>OBJ</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td>BG color 1–3, otherwise OBJ</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td>BG color 1–3, otherwise OBJ</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td>BG color 1–3, otherwise OBJ</td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/alloncm/MagenTests">This test ROM</a> can be used to observe the above.</p>
<div class="box warning">
<p>Keep in mind that:</p>
<ul>
<li>OAM Attributes bit 7 will grant OBJ priority when <strong>clear</strong>, not when <strong>set</strong>.</li>
<li>Priority between all OBJs is resolved <strong>before</strong> priority with the BG layer is considered.
Please refer <a href="#drawing-priority">to this page</a> for more details.</li>
</ul>
</div>
<h2 id="background-bg"><a class="header" href="#background-bg">Background (BG)</a></h2>
<p>The <a href="#ff42ff43--scy-scx-viewport-y-position-x-position">SCY and SCX</a>
registers can be used to scroll the Background, specifying the origin of the visible
160x144 pixel area within the total 256x256 pixel Background map.
The visible area of the Background wraps around the Background map (that is, when part of
the visible area goes beyond the map edge, it starts displaying the opposite side of the map).</p>
<p>In Non-CGB mode, the Background (and the Window) can be disabled using
<a href="#lcdc0--bg-and-window-enablepriority">LCDC bit 0</a>.</p>
<h2 id="window-1"><a class="header" href="#window-1">Window</a></h2>
<p>Besides the Background, there is also a Window overlaying it.
The content of the Window is not scrollable; it is always
displayed starting at the top left tile of its tile map. The only way to adjust the Window
is by modifying its position on the screen, which is done via the WX and WY registers. The screen
coordinates of the top left corner of the Window are (WX-7,WY). The tiles
for the Window are stored in the Tile Data Table. Both the Background
and the Window share the same Tile Data Table.</p>
<p>Whether the Window is displayed can be toggled using
<a href="#lcdc5--window-enable">LCDC bit 5</a>. But in Non-CGB mode this bit is only
functional as long as <a href="#lcdc0--bg-and-window-enablepriority">LCDC bit 0</a> is set.
Enabling the Window makes
<a href="#lcd-status-register">Mode 3</a> slightly longer on scanlines where it’s visible.
(See <a href="#ff4aff4b--wy-wx-window-y-position-x-position-plus-7">WX and WY</a>
for the definition of “Window visibility”.)</p>
<div class="box tip">
<p class="box-title">Window Internal Line Counter</p><p>The window keeps an internal line counter that’s functionally similar to <code>LY</code>, and increments alongside it. However, it only gets incremented when the window is visible, as described <a href="#ff4aff4b--wy-wx-window-y-position-x-position-plus-7">here</a>.</p>
<p>This line counter determines what window line is to be rendered on the current scanline.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vram-sprite-attribute-table-oam"><a class="header" href="#vram-sprite-attribute-table-oam">VRAM Sprite Attribute Table (OAM)</a></h1>
<p>The Game Boy PPU can display up to 40 sprites either in 8x8 or
in 8x16 pixels. Because of a limitation of hardware, only ten sprites
can be displayed per scan line. Sprite tiles have the same format as
BG tiles, but they are taken from the Sprite Tiles Table located at
$8000-8FFF and have unsigned numbering.</p>
<p>Sprite attributes reside in the Sprite Attribute Table (OAM: Object
Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of
four bytes with the following meanings:</p>
<h2 id="byte-0--y-position"><a class="header" href="#byte-0--y-position">Byte 0 — Y Position</a></h2>
<p>Y = Sprite’s vertical position on the screen + 16. So for example,
Y=0 hides a sprite,
Y=2 hides an 8×8 sprite but displays the last two rows of an 8×16 sprite,
Y=16 displays a sprite at the top of the screen,
Y=144 displays an 8×16 sprite aligned with the bottom of the screen,
Y=152 displays an 8×8 sprite aligned with the bottom of the screen,
Y=154 displays the first six rows of a sprite at the bottom of the screen,
Y=160 hides a sprite.</p>
<h2 id="byte-1--x-position"><a class="header" href="#byte-1--x-position">Byte 1 — X Position</a></h2>
<p>X = Sprite’s horizontal position on the screen + 8. This works similarly
to the examples above, except that the width of a sprite is always 8. An
off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite still
affects the priority ordering, thus other sprites with lower priority may be
left out due to the ten sprites limit per scan-line.
A better way to hide a sprite is to set its Y-coordinate off-screen.</p>
<h2 id="byte-2--tile-index"><a class="header" href="#byte-2--tile-index">Byte 2 — Tile Index</a></h2>
<p>In 8x8 mode (LCDC bit 2 = 0), this byte specifies the sprite’s only tile index ($00-$FF).
This unsigned value selects a tile from the memory area at $8000-$8FFF.
In CGB Mode this could be either in
VRAM bank 0 or 1, depending on bit 3 of the following byte.
In 8x16 mode (LCDC bit 2 = 1), the memory area at $8000-$8FFF is still interpreted
as a series of 8x8 tiles, where every 2 tiles form a sprite. In this mode, this byte
specifies the index of the first (top) tile of the sprite. This is enforced by the
hardware: the least significant bit of the tile index is ignored; that is, the top 8x8
tile is “NN &amp; $FE”, and the bottom 8x8 tile is “NN | $01”.</p>
<h2 id="byte-3--attributesflags"><a class="header" href="#byte-3--attributesflags">Byte 3 — Attributes/Flags</a></h2>
<pre><code> Bit7   BG and Window over OBJ (0=No, 1=BG and Window colors 1-3 over the OBJ)
 Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
 Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
 Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
 Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
 Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
</code></pre>
<h2 id="writing-data-to-oam"><a class="header" href="#writing-data-to-oam">Writing data to OAM</a></h2>
<p>The recommended method is to write the data to a buffer in normal RAM
(typically WRAM) first, then to copy that buffer to OAM using
<a href="#oam-dma-transfer">the DMA transfer functionality</a>.</p>
<p>While it is also possible to write data directly to the OAM area
<a href="#oam-memory-area-at-fe00-fe9f-is-accessible-during-modes-0-1">by accessing it normally</a>,
this only works <a href="#lcd-status-register">during the HBlank and VBlank periods</a>.</p>
<h2 id="object-priority-and-conflicts"><a class="header" href="#object-priority-and-conflicts">Object Priority and Conflicts</a></h2>
<p>There are two kinds of “priorities” as far as objects are concerned.
The first one defines which objects are ignored when there are more than 10 on a
given scanline. The second one decides which object is displayed on top when some
overlap (the Game Boy being a 2D console, there is no Z coordinate).</p>
<h3 id="selection-priority"><a class="header" href="#selection-priority">Selection priority</a></h3>
<p>During each scanline’s OAM scan, the PPU compares <a href="#ff44--ly-lcd-y-coordinate-read-only"><code>LY</code></a>
(<a href="#lcdc2--obj-size">using <code>LCDC</code> bit 2 to determine their size</a>) to each
object’s Y position to select up to 10 objects to be drawn on that line.
The PPU scans OAM sequentially (from $FE00 to $FE9F), selecting the first (up to)
10 suitably-positioned objects.</p>
<p>Since the PPU only checks the Y coordinate to select objects, even
off-screen objects count towards the 10-objects-per-scanline limit.
Merely setting an object’s X coordinate to X = 0 or X ≥ 168
(160 + 8) will hide it, but it will still count towards the
limit, possibly causing another object later in OAM not
to be drawn. To keep off-screen objects from affecting on-screen ones, make
sure to set their Y coordinate to Y = 0 or Y ≥ 160
(144 + 16).
(Y ≤ 8 also works if <a href="#lcdc2--obj-size">object size</a> is set to 8x8.)</p>
<h3 id="drawing-priority"><a class="header" href="#drawing-priority">Drawing priority</a></h3>
<p>When <strong>opaque</strong> pixels from two different objects overlap, which pixel ends up
being displayed is determined by another kind of priority: the pixel belonging
to the higher-priority object wins. However, this priority is determined
differently when in CGB mode.</p>
<ul>
<li><strong>In Non-CGB mode</strong>, the smaller the X coordinate, the higher the priority.
When X coordinates are identical, the object located first in OAM has higher
priority.</li>
<li><strong>In CGB mode</strong>, only the object’s location in OAM determines its priority.
The earlier the object, the higher its priority.</li>
</ul>
<div class="box tip">
<p class="box-title">Interaction with “BG over OBJ” flag</p><p>Object drawing priority and “BG over OBJ” interact in a non-intuitive way.</p>
<p>Internally, the PPU first resolves priority between objects to
pick an “object pixel”, which is the first non-transparent pixel encountered
when iterating over objects sorted by their drawing priority.
The “BG over OBJ” attribute is <strong>never</strong> considered in this process.</p>
<p>Only <em>after</em> object priority is resolved, the “object pixel” has the “BG over
OBJ” attribute of its object checked to determine whether it should be drawn
over the background.
This means that an object with a higher priority but with “BG over OBJ” enabled
will sort of “mask” lower-priority objects, even if those have “BG over OBJ”
disabled.</p>
<p>This can be exploited to only hide parts of an object behind the background
(<a href="https://youtu.be/B8sJGgCVvnk">video demonstration</a>).
A similar behaviour <a href="https://forums.nesdev.org/viewtopic.php?f=10&amp;t=16861">can be seen on the NES</a>.</p>
<p><strong>In CGB Mode</strong>, BG vs. OBJ priority is declared in more than one register, <a href="#bg-to-obj-priority-in-cgb-mode">please see this page</a> for more details.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oam-dma-transfer"><a class="header" href="#oam-dma-transfer">OAM DMA Transfer</a></h1>
<h2 id="ff46--dma-oam-dma-source-address--start"><a class="header" href="#ff46--dma-oam-dma-source-address--start">FF46 — DMA: OAM DMA source address &amp; start</a></h2>
<p>Writing to this register launches a DMA transfer from ROM or RAM to OAM
(Object Attribute Memory). The written value specifies the
transfer source address divided by $100, that is, source and destination are:</p>
<pre><code>Source:      $XX00-$XX9F   ;XX = $00 to $DF
Destination: $FE00-$FE9F
</code></pre>
<p>The transfer takes 160 machine cycles: 152 microseconds in normal speed
or 76 microseconds in CGB Double Speed Mode. On DMG, during this time,
the CPU can access only HRAM (memory at $FF80-$FFFE); on CGB, the bus used
by the source area cannot be used (this isn’t understood well at the
moment; it’s recommended to assume same behavior as DMG). For this
reason, the programmer must copy a short procedure into HRAM, and use
this procedure to start the transfer from inside HRAM, and wait until
the transfer has finished:</p>
<pre><code class="language-rgbasm">run_dma:
    ld a, HIGH(start address)
    ldh [$FF46], a  ; start DMA transfer (starts right after instruction)
    ld a, 40        ; delay for a total of 4×40 = 160 cycles
.wait
    dec a           ; 1 cycle
    jr nz, .wait    ; 3 cycles
    ret
</code></pre>
<p>Because sprites are not displayed while an OAM DMA transfer is in progress, most
programs execute this procedure from inside their VBlank
handler. But it is also possible to execute it during display redraw (Modes 2 and 3),
allowing to display more than 40 sprites on the screen (that is, for
example 40 sprites in the top half, and other 40 sprites in the bottom half of
the screen), at the cost of a couple lines that lack sprites due to the fact that
during those couple lines the PPU reads OAM as $FF. Besides, graphic glitches may
happen if an OAM DMA transfer is started during Mode 3.</p>
<p>A more compact procedure is</p>
<pre><code class="language-rgbasm">run_dma:          ; This part is in ROM
    ld a, HIGH(start address)
    ld bc, $2846  ; B: wait time; C: LOW($FF46)
    jp run_dma_hrampart

run_dma_hrampart:
    ldh [c], a
.wait
    dec b
    jr nz, .wait
    ret
</code></pre>
<p>This saves 5 bytes of HRAM, but is slightly slower in most cases due to
the jump into the HRAM part.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lcd-control"><a class="header" href="#lcd-control">LCD Control</a></h1>
<h2 id="ff40--lcdc-lcd-control"><a class="header" href="#ff40--lcdc-lcd-control">FF40 — LCDC: LCD control</a></h2>
<p><strong>LCDC</strong> is the main <strong>LCD C</strong>ontrol register. Its bits toggle what
elements are displayed on the screen, and how.</p>
<div class="table-wrapper"><table><thead><tr><th>Bit</th><th>Name</th><th>Usage notes</th></tr></thead><tbody>
<tr><td>7</td><td>LCD and PPU enable</td><td>0=Off, 1=On</td></tr>
<tr><td>6</td><td>Window tile map area</td><td>0=9800-9BFF, 1=9C00-9FFF</td></tr>
<tr><td>5</td><td>Window enable</td><td>0=Off, 1=On</td></tr>
<tr><td>4</td><td>BG and Window tile data area</td><td>0=8800-97FF, 1=8000-8FFF</td></tr>
<tr><td>3</td><td>BG tile map area</td><td>0=9800-9BFF, 1=9C00-9FFF</td></tr>
<tr><td>2</td><td>OBJ size</td><td>0=8x8, 1=8x16</td></tr>
<tr><td>1</td><td>OBJ enable</td><td>0=Off, 1=On</td></tr>
<tr><td>0</td><td>BG and Window enable/priority</td><td>0=Off, 1=On</td></tr>
</tbody></table>
</div>
<h3 id="lcdc7--lcd-enable"><a class="header" href="#lcdc7--lcd-enable">LCDC.7 — LCD enable</a></h3>
<p>This bit controls whether the LCD is on and the PPU is active. Setting
it to 0 turns both off, which grants immediate and full access to VRAM,
OAM, etc.</p>
<div class="box danger">
<p class="box-title">CAUTION</p><p>Stopping LCD operation (Bit 7 from 1 to 0) may be performed
during VBlank ONLY, disabling the display outside
of the VBlank period may damage the hardware by burning in a black
horizontal line similar to that which appears when the GB is turned off.
This appears to be a serious issue. Nintendo is reported to reject any
games not following this rule.</p>
</div>
<p>When the display is disabled the screen is blank, which on DMG is
displayed as a white “whiter” than color #0.</p>
<p>On SGB, the screen doesn’t turn white, it appears that the previous
picture sticks to the screen. (TODO: research this more.)</p>
<p>When re-enabling the LCD, the PPU will immediately start drawing again,
but the screen will stay blank during the first frame.</p>
<h3 id="lcdc6--window-tile-map-area"><a class="header" href="#lcdc6--window-tile-map-area">LCDC.6 — Window tile map area</a></h3>
<p>This bit controls which background map the Window uses for rendering.
When it’s reset, the $9800 tilemap is used, otherwise it’s the $9C00
one.</p>
<h3 id="lcdc5--window-enable"><a class="header" href="#lcdc5--window-enable">LCDC.5 — Window enable</a></h3>
<p>This bit controls whether the window shall be displayed or not.
This bit is overridden on DMG by <a href="#lcdc0--bg-and-window-enablepriority">bit 0</a>
if that bit is reset.</p>
<p>Changing the value of this register mid-frame triggers a more complex behaviour:
<a href="#ff4aff4b--wy-wx-window-y-position-x-position-plus-7">see further below</a>.</p>
<p>Note that on CGB models, setting this bit to 0 then back to 1 mid-frame
may cause the second write to be ignored. (TODO: test this.)</p>
<h3 id="lcdc4--bg-and-window-tile-data-area"><a class="header" href="#lcdc4--bg-and-window-tile-data-area">LCDC.4 — BG and Window tile data area</a></h3>
<p>This bit controls which <a href="#vram-tile-data">addressing
mode</a> the BG and Window use to
pick tiles.</p>
<p>Sprites aren’t affected by this, and will always use $8000 addressing
mode.</p>
<h3 id="lcdc3--bg-tile-map-area"><a class="header" href="#lcdc3--bg-tile-map-area">LCDC.3 — BG tile map area</a></h3>
<p>This bit works similarly to <a href="#lcdc6--window-tile-map-area">LCDC bit 6</a>:
if the bit is reset, the BG uses tilemap $9800, otherwise tilemap $9C00.</p>
<h3 id="lcdc2--obj-size"><a class="header" href="#lcdc2--obj-size">LCDC.2 — OBJ size</a></h3>
<p>This bit controls the sprite size (1 tile or 2 stacked vertically).</p>
<p>Be cautious when changing this mid-frame from 8x8 to 8x16: “remnants”
of the sprites intended for 8x8 could “leak” into the 8x16 zone and
cause artifacts.</p>
<h3 id="lcdc1--obj-enable"><a class="header" href="#lcdc1--obj-enable">LCDC.1 — OBJ enable</a></h3>
<p>This bit toggles whether sprites are displayed or not.</p>
<p>This can be toggled mid-frame, for example to avoid sprites being
displayed on top of a status bar or text box.</p>
<p>(Note: toggling mid-scanline might have funky results on DMG?
Investigation needed.)</p>
<h3 id="lcdc0--bg-and-window-enablepriority"><a class="header" href="#lcdc0--bg-and-window-enablepriority">LCDC.0 — BG and Window enable/priority</a></h3>
<p>LCDC.0 has different meanings depending on Game Boy type and Mode:</p>
<h4 id="non-cgb-mode-dmg-sgb-and-cgb-in-compatibility-mode-bg-and-window-display"><a class="header" href="#non-cgb-mode-dmg-sgb-and-cgb-in-compatibility-mode-bg-and-window-display">Non-CGB Mode (DMG, SGB and CGB in compatibility mode): BG and Window display</a></h4>
<p>When Bit 0 is cleared, both background and window become blank (white),
and the <a href="#lcdc5--window-enable">Window Display Bit</a>
is ignored in that case. Only Sprites may still be displayed (if enabled
in Bit 1).</p>
<h4 id="cgb-mode-bg-and-window-master-priority"><a class="header" href="#cgb-mode-bg-and-window-master-priority">CGB Mode: BG and Window master priority</a></h4>
<p>When Bit 0 is cleared, the background and window lose their priority -
the sprites will be always displayed on top of background and window,
independently of the priority flags in OAM and BG Map attributes.</p>
<p>When Bit 0 is set, pixel priority is resolved <a href="#bg-to-obj-priority-in-cgb-mode">as described here</a>.</p>
<h2 id="using-lcdc"><a class="header" href="#using-lcdc">Using LCDC</a></h2>
<p>LCDC is a powerful tool: each bit controls a lot of behavior, and can be
modified at any time during the frame.</p>
<p>One of the important aspects of LCDC is that unlike VRAM, the PPU never
locks it. It’s thus possible to modify it mid-scanline!</p>
<h2 id="faux-layer-textboxstatus-bar"><a class="header" href="#faux-layer-textboxstatus-bar">Faux-layer textbox/status bar</a></h2>
<p>A problem often seen especially in NES games is sprites rendering on top
of the textbox/status bar. It’s possible to prevent this using LCDC if
the textbox/status bar is “alone” on its scanlines:</p>
<ul>
<li>Set LCDC.1 to 1 for gameplay scanlines</li>
<li>Set LCDC.1 to 0 for textbox/status bar scanlines</li>
</ul>
<p>Usually, these bars are either at the top or bottom of the screen, so
the bit can be set by the VBlank handler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lcd-status-register"><a class="header" href="#lcd-status-register">LCD Status Register</a></h1>
<div class="box tip">
<p class="box-title">TERMINOLOGY</p><p>A <em>dot</em> is the shortest period over which the PPU can output one pixel: is it equivalent to 1 T-state on DMG or on CGB single-speed mode or 2 T-states on CGB double-speed mode. On each dot during mode 3, either the PPU outputs a pixel or the fetcher is stalling the <a href="#pixel-fifo">FIFOs</a>.</p>
</div>
<h2 id="ff41--stat-lcd-status"><a class="header" href="#ff41--stat-lcd-status">FF41 — STAT: LCD status</a></h2>
<pre><code>Bit 6 - LYC=LY STAT Interrupt source         (1=Enable) (Read/Write)
Bit 5 - Mode 2 OAM STAT Interrupt source     (1=Enable) (Read/Write)
Bit 4 - Mode 1 VBlank STAT Interrupt source  (1=Enable) (Read/Write)
Bit 3 - Mode 0 HBlank STAT Interrupt source  (1=Enable) (Read/Write)
Bit 2 - LYC=LY Flag                          (0=Different, 1=Equal) (Read Only)
Bit 1-0 - Mode Flag                          (Mode 0-3, see below) (Read Only)
          0: HBlank
          1: VBlank
          2: Searching OAM
          3: Transferring Data to LCD Controller
</code></pre>
<p>The two lower STAT bits show the current status of the PPU.</p>
<p>Bit 2 is set when <a href="#ff44--ly-lcd-y-coordinate-read-only">LY</a> contains the same value as <a href="#ff45--lyc-ly-compare">LYC</a>.
It is constantly updated.</p>
<p>Bits 3-6 select which sources are used for <a href="#int-48--stat-interrupt">the STAT interrupt</a>.</p>
<p>The LCD controller operates on a 2^22 Hz = 4.194 MHz dot clock. An
entire frame is 154 scanlines = 70224 dots = 16.74 ms. On scanlines 0
through 143, the PPU cycles through modes 2, 3, and 0 once
every 456 dots. Scanlines 144 through 153 are mode 1.</p>
<p>The following sequence is typical when the display is enabled:</p>
<pre><code>Mode 2  2_____2_____2_____2_____2_____2___________________2____
Mode 3  _33____33____33____33____33____33__________________3___
Mode 0  ___000___000___000___000___000___000________________000
Mode 1  ____________________________________11111111111111_____
</code></pre>
<p>When the PPU is accessing some video-related memory, that memory is inaccessible
to the CPU: writes are ignored, and reads return garbage values (usually $FF).</p>
<ul>
<li>During modes 2 and 3, the CPU cannot access <a href="#vram-sprite-attribute-table-oam">OAM</a> ($FE00-FE9F).</li>
<li>During mode 3, the CPU cannot access VRAM or <a href="#lcd-color-palettes-cgb-only">CGB palette data registers</a>
($FF69,$FF6B).</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Action</th><th>Duration</th><th>Accessible video memory</th></tr></thead><tbody>
<tr><td>2</td><td>Searching OAM for OBJs whose Y coordinate overlap this line</td><td>80 dots</td><td>VRAM, CGB palettes</td></tr>
<tr><td>3</td><td>Reading OAM and VRAM to generate the picture</td><td>168 to 291 dots, depending on sprite count</td><td>None</td></tr>
<tr><td>0</td><td>Nothing (HBlank)</td><td>85 to 208 dots, depending on previous mode 3 duration</td><td>VRAM, OAM, CGB palettes</td></tr>
<tr><td>1</td><td>Nothing (VBlank)</td><td>4560 dots (10 scanlines)</td><td>VRAM, OAM, CGB palettes</td></tr>
</tbody></table>
</div>
<h2 id="properties-of-stat-modes"><a class="header" href="#properties-of-stat-modes">Properties of STAT modes</a></h2>
<p>Unlike most game consoles, the Game Boy can pause the dot clock briefly,
making Mode 3 longer and Mode 0 shorter. It routinely takes a 6 to 11 dot
break to fetch an OBJ’s tile between background tile pattern fetches.
On DMG and GBC in DMG mode, mid-scanline writes to <a href="#ff47--bgp-non-cgb-mode-only-bg-palette-data"><code>BGP</code></a>
allow observing this behavior, as the delay from drawing an OBJ shifts the
write’s effect to the left by that many dots.</p>
<p>Three things are known to pause the dot clock:</p>
<ul>
<li>Background scrolling: If <code>SCX % 8</code> is not zero at the start of the scanline, rendering is paused for that many dots while the shifter discards that many pixels from the leftmost tile.</li>
<li>Window: An active window pauses for at least 6 dots, as the background fetching mechanism starts over at the left side of the window.</li>
<li>Sprites: Each sprite usually pauses for <code>11 - min(5, (x + SCX) % 8)</code> dots. Because sprite fetch waits for background fetch to finish, a sprite’s cost depends on its position relative to the left side of the background tile under it. It’s greater if a sprite is directly aligned over the background tile, less if the sprite is to the right. If the sprite’s left side is over the window, use <code>255 - WX</code> instead of <code>SCX</code> in this formula.</li>
</ul>
<div class="box warning">
<p class="box-title">TO BE VERIFIED</p><p>The exact pause duration for window start is
not confirmed; it may have the same background fetch finish delay as a
sprite. If two sprites’ left sides are over the same background or
window tile, the second may pause for fewer dots.</p>
</div>
<p>A hardware quirk in the monochrome Game Boy makes the LCD interrupt
sometimes trigger when writing to STAT (including writing $00) during
OAM scan, HBlank, VBlank, or LY=LYC. It behaves as if $FF were
written for one cycle, and then the written value were written the next
cycle. Because the GBC in DMG mode does not have this quirk, two games
that depend on this quirk (Ocean’s <em>Road Rash</em> and Vic Tokai’s <em>Xerd
no Densetsu</em>) will not run on a GBC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lcd-position-and-scrolling"><a class="header" href="#lcd-position-and-scrolling">LCD Position and Scrolling</a></h1>
<p>These registers can be accessed even during Mode 3, but modifications may not take
effect immediately (see further below).</p>
<h2 id="ff42ff43--scy-scx-viewport-y-position-x-position"><a class="header" href="#ff42ff43--scy-scx-viewport-y-position-x-position">FF42–FF43 — SCY, SCX: Viewport Y position, X position</a></h2>
<p>Those specify the top-left coordinates of the visible 160×144 pixel area within the
256×256 pixels BG map. Values in the range 0–255 may be used.</p>
<h2 id="ff44--ly-lcd-y-coordinate-read-only"><a class="header" href="#ff44--ly-lcd-y-coordinate-read-only">FF44 — LY: LCD Y coordinate [read-only]</a></h2>
<p>LY indicates the current horizontal line, which might be about to be drawn,
being drawn, or just been drawn. LY can hold any value from 0 to 153, with
values from 144 to 153 indicating the VBlank period.</p>
<h2 id="ff45--lyc-ly-compare"><a class="header" href="#ff45--lyc-ly-compare">FF45 — LYC: LY compare</a></h2>
<p>The Game Boy permanently compares the value of the LYC and LY registers.
When both values are identical, the “LYC=LY” flag in the STAT register
is set, and (if enabled) a STAT interrupt is requested.</p>
<h2 id="ff4aff4b--wy-wx-window-y-position-x-position-plus-7"><a class="header" href="#ff4aff4b--wy-wx-window-y-position-x-position-plus-7">FF4A–FF4B — WY, WX: Window Y position, X position plus 7</a></h2>
<p>Specify the top-left coordinates of <a href="#window">the Window</a>.</p>
<p>The Window is visible (if enabled) when both coordinates are in the ranges
WX=0..166, WY=0..143 respectively. Values WX=7, WY=0 place the Window at the
top left of the screen, completely covering the background.</p>
<div class="box warning">
<p class="box-title">Warning</p><p>WX values 0 and 166 are unreliable due to hardware bugs.</p>
<p>If WX is set to 0, the window will “stutter” horizontally when SCX changes
(depending on SCX % 8).</p>
<p>If WX is set to 166, the window will span the entirety of the following
scanline.</p>
</div>
<h2 id="mid-frame-behavior"><a class="header" href="#mid-frame-behavior">Mid-frame behavior</a></h2>
<h3 id="scrolling"><a class="header" href="#scrolling">Scrolling</a></h3>
<p>The scroll registers are re-read on each <a href="#get-tile">tile fetch</a>, except for the low 3 bits of SCX, which are only read at the beginning of the scanline (for the initial shifting of pixels).</p>
<p>All models before the CGB-D read the Y coordinate once for each bitplane (so a very precisely timed SCY write allows “desyncing” them), but CGB-D and later use the same Y coordinate for both no matter what.</p>
<h3 id="window-2"><a class="header" href="#window-2">Window</a></h3>
<p>While the Window should work as just mentioned, writing to WX, WY etc. mid-frame shows a more articulated behavior.</p>
<p>For the window to be displayed on a scanline, the following conditions must be met:</p>
<ul>
<li><strong>WY condition was triggered</strong>: i.e. at some point in this frame the value of WY was equal to LY (checked at the start of Mode 2 only)</li>
<li><strong>WX condition was triggered</strong>: i.e. the current X coordinate being rendered + 7 was equal to WX</li>
<li>Window enable bit in LCDC is set</li>
</ul>
<p>If the WY condition has already been triggered and at the start of a row the window enable bit was set,
then resetting that bit before the WX condition gets triggered on that row yields a nice window glitch pixel where the window would have been activated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="palettes-1"><a class="header" href="#palettes-1">Palettes</a></h1>
<h2 id="lcd-monochrome-palettes"><a class="header" href="#lcd-monochrome-palettes">LCD Monochrome Palettes</a></h2>
<h3 id="ff47--bgp-non-cgb-mode-only-bg-palette-data"><a class="header" href="#ff47--bgp-non-cgb-mode-only-bg-palette-data">FF47 — BGP (Non-CGB Mode only): BG palette data</a></h3>
<p>This register assigns gray shades to the color indexes of the BG and
Window tiles.</p>
<pre><code>Bit 7-6 - Color for index 3
Bit 5-4 - Color for index 2
Bit 3-2 - Color for index 1
Bit 1-0 - Color for index 0
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Color</th></tr></thead><tbody>
<tr><td>0</td><td>White</td></tr>
<tr><td>1</td><td>Light gray</td></tr>
<tr><td>2</td><td>Dark gray</td></tr>
<tr><td>3</td><td>Black</td></tr>
</tbody></table>
</div>
<p>In CGB Mode the color palettes are taken from <a href="#lcd-color-palettes-cgb-only">CGB palette memory</a>
instead.</p>
<h3 id="ff48ff49--obp0-obp1-non-cgb-mode-only-obj-palette-0-1-data"><a class="header" href="#ff48ff49--obp0-obp1-non-cgb-mode-only-obj-palette-0-1-data">FF48–FF49 — OBP0, OBP1 (Non-CGB Mode only): OBJ palette 0, 1 data</a></h3>
<p>These registers assigns gray shades to the color indexes of the OBJs that use the corresponding palette.
They work exactly like BGP, except that the lower two bits are ignored because color index 0 is transparent for OBJs.</p>
<h2 id="lcd-color-palettes-cgb-only"><a class="header" href="#lcd-color-palettes-cgb-only">LCD Color Palettes (CGB only)</a></h2>
<p>The CGB has a small amount of RAM used to store its color palettes. Unlike most
of the hardware interface, palette RAM (or <em>CRAM</em> for <em>Color RAM</em>) is not
accessed directly, but instead through the following registers:</p>
<h3 id="ff68--bcpsbgpi-cgb-mode-only-background-color-palette-specification--background-palette-index"><a class="header" href="#ff68--bcpsbgpi-cgb-mode-only-background-color-palette-specification--background-palette-index">FF68 — BCPS/BGPI (CGB Mode only): Background color palette specification / Background palette index</a></h3>
<p>This register is used to address a byte in the CGB’s background palette RAM.
Since there are 8 palettes, 8 palettes × 4 colors/palette × 2 bytes/color = 64 bytes
can be addressed.</p>
<pre><code>Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)
Bit 5-0   Address ($00-3F)
</code></pre>
<p>First comes BGP0 color number 0, then BGP0 color number 1, BGP0 color number 2, BGP0 color number 3,
BGP1 color number 0, and so on. Thus, address $03 allows accessing the second (upper)
byte of BGP0 color #1 via BCPD, which contains the color’s blue and upper green bits.</p>
<p>data can be read from or written to the specified CRAM address through
BCPD/BGPD. If the Auto Increment bit is set, the index gets
incremented after each <strong>write</strong> to BCPD. Auto Increment has
no effect when <strong>reading</strong> from BCPD, so the index must be manually
incremented in that case. Writing to BCPD during rendering still causes
auto-increment to occur, despite the write being blocked.</p>
<p>Unlike BCPD, this register can be accessed outside VBlank and HBlank.</p>
<h3 id="ff69--bcpdbgpd-cgb-mode-only-background-color-palette-data--background-palette-data"><a class="header" href="#ff69--bcpdbgpd-cgb-mode-only-background-color-palette-data--background-palette-data">FF69 — BCPD/BGPD (CGB Mode only): Background color palette data / Background palette data</a></h3>
<p>This register allows to read/write data to the CGBs background palette memory,
addressed through BCPS/BGPI. Each color is stored as little-endian RGB555:</p>
<pre><code>Bit 0-4   Red Intensity   ($00-1F)
Bit 5-9   Green Intensity ($00-1F)
Bit 10-14 Blue Intensity  ($00-1F)
</code></pre>
<p>Much like VRAM, data in palette memory cannot be read or written during the time
when the PPU is reading from it, that is, <a href="#lcd-status-register">Mode 3</a>.</p>
<div class="box tip">
<p class="box-title">NOTE</p><p>All background colors are initialized as white by the boot ROM, however it is a
good idea to initialize all colors yourself, e.g. if implementing
a soft-reset mechanic.</p>
</div>
<h3 id="ff6aff6b--ocpsobpi-ocpdobpd-cgb-mode-only-obj-color-palette-specification--obj-palette-index-obj-color-palette-data--obj-palette-data"><a class="header" href="#ff6aff6b--ocpsobpi-ocpdobpd-cgb-mode-only-obj-color-palette-specification--obj-palette-index-obj-color-palette-data--obj-palette-data">FF6A–FF6B — OCPS/OBPI, OCPD/OBPD (CGB Mode only): OBJ color palette specification / OBJ palette index, OBJ color palette data / OBJ palette data</a></h3>
<p>These registers function exactly like BCPS and BCPD respectively; the 64 bytes
of OBJ palette memory are entirely separate from Background palette memory, but
function the same.</p>
<p>Note that while 4 colors are stored per OBJ palette, color #0 is never used, as
it’s always transparent. It’s thus fine to write garbage values, or even leave
color #0 uninitialized.</p>
<div class="box tip">
<p class="box-title">NOTE</p><p>The boot ROM leaves all object colors uninitialized (and thus somewhat random),
aside from setting the first byte of OBJ0 color #0 to $00, which is unused.</p>
</div>
<h3 id="rgb-translation-by-cgbs"><a class="header" href="#rgb-translation-by-cgbs">RGB Translation by CGBs</a></h3>
<p><img src="imgs/VGA_versus_CGB.png" alt="sRGB versus CGB color mixing" /></p>
<p>When developing graphics on PCs, note that the RGB values will have
different appearance on CGB displays as on VGA/HDMI monitors calibrated
to sRGB color. Because the GBC is not lit, the highest intensity will
produce light gray rather than white. The intensities are not
linear; the values $10-$1F will all appear very bright, while medium and
darker colors are ranged at $00-0F.</p>
<p>The CGB display’s pigments aren’t perfectly saturated. This means the
colors mix quite oddly: increasing the intensity of only one R/G/B color
will also influence the other two R/G/B colors. For example, a color
setting of $03EF (Blue=$00, Green=$1F, Red=$0F) will appear as Neon Green
on VGA displays, but on the CGB it’ll produce a decently washed out
Yellow. See the image above.</p>
<h3 id="rgb-translation-by-gbas"><a class="header" href="#rgb-translation-by-gbas">RGB Translation by GBAs</a></h3>
<p>Even though GBA is described to be compatible to CGB games, most CGB
games are completely unplayable on older GBAs because most colors are
invisible (black). Of course, colors such like Black and White will
appear the same on both CGB and GBA, but medium intensities are arranged
completely different. Intensities in range $00–07 are invisible/black
(unless eventually under best sunlight circumstances, and when gazing at
the screen under obscure viewing angles), unfortunately, these
intensities are regularly used by most existing CGB games for medium and
darker colors.</p>
<div class="box tip">
<p class="box-title">WORKAROUND</p><p>Newer CGB games may avoid this effect by changing palette data when
detecting GBA hardware (<a href="#detecting-cgb-and-gba-functions">see how</a>).
Based on measurements of GBC and GBA palettes using the
<a href="https://github.com/pinobatch/240p-test-mini/tree/master/gameboy">144p Test Suite</a>,
a fairly close approximation is <code>GBA = GBC × 3/4 + $08</code> for each R/G/B
component. The result isn’t quite perfect, and it may turn
out that the color mixing is different also; anyways, it’d be still
ways better than no conversion.</p>
</div>
<p>This problem with low brightness levels does not affect later GBA SP
units and Game Boy Player. Thus ideally, the player should have control
of this brightness correction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pixel-fifo"><a class="header" href="#pixel-fifo">Pixel FIFO</a></h1>
<div class="box tip">
<p class="box-title">TERMINOLOGY</p><p>All references to a dot are meant as dots (4.19 MHz). Dots remain the same regardless of 
CGB double speed.
When it is stated that a certain action <em>lengthens mode 3</em> it means that mode 0 (HBlank) is
shortened to make up for the additional time in mode 3, as shown in the following diagram.</p>
</div>
<svg viewBox="0 0 700 590" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
	<defs>
		<style type="text/css"><![CDATA[
			text {
				fill: var(--fg);
			}
			rect {
				opacity: 75%;
			}
			.mode-box {
				opacity: 25%;
				height: 60px;
			}
			.scanline {
				height: 20px;
			}
			.square {
				height: 10px;
				width: 10px;
			}
			.m2 { fill: #ffd966; }
			.m3 { fill: #ff8000; }
			.m0 { fill: #97d077; }
			.m1 { fill: #00ffff; }
			.m30 {
				fill: url(#m30-gradient);
			}
			.darken {
				fill: #000;
				opacity: 50%;
				font-weight: 500;
			}
			.centered { text-anchor: middle; }
			.right    { text-anchor: end; }
			.mode-id {
				font-size: large;
			}
			.small {
				font-size: small;
			}
			.middle-baseline {
				dominant-baseline: middle;
			}
			.mode-id, .mode-descr {
				font-variant: small-caps;
			}
		]]></style>
		<linearGradient x1="0%" y1="0%" x2="100%" y2="0%" id="m30-gradient">
			<stop offset="0%" stop-color="#ff8000"/>
			<stop offset="100%" stop-color="#97d077"/>
		</linearGradient>
	</defs>
	<rect class="mode-box m2" x="60" y="0" width="80"/>
	<text class="centered mode-id" x="100" y="25">Mode 2</text>
	<text class="centered mode-descr" x="100" y="45">OAM scan</text>
	<text class="centered small" x="100" y="75">80 dots</text>
	<rect class="mode-box m3" x="145" y="0" width="172"/>
	<text class="centered mode-id" x="231" y="25">Mode 3</text>
	<text class="centered mode-descr" x="231" y="45">Drawing pixels</text>
	<text class="centered small" x="231" y="75">172–289 dots</text>
	<rect class="mode-box m0" x="322" y="0" width="204"/>
	<text class="centered mode-id" x="424" y="25">Mode 0</text>
	<text class="centered mode-descr" x="424" y="45">Horizontal blank</text>
	<text class="centered small" x="424" y="75">87–204 dots</text>
	<rect class="mode-box m1" x="130" y="490" width="230"/>
	<text class="centered mode-id" x="245" y="515">Mode 1</text>
	<text class="centered mode-descr" x="245" y="535">Vertical blank</text>
	<!-- "Accessibility" spans -->
	<text x="322" y="135">VRAM ($8000–9FFF) inaccessible</text>
	<text x="322" y="155">CGB palettes inaccessible</text>
	<path stroke="#ff8000" d="M 317,130
	                          v 20
	                          m 0,-10
	                          h -172
	                          m 0,10
	                          v -20"/>
	<text x="322" y="185">OAM inaccessible (except by DMA)</text>
	<path stroke="#ffd966" d="M 317,170
	                          v 20
	                          m 0,-10
	                          h -257
	                          m 0,10
	                          v -20"/>
	<text class="centered" x="443" y="515">Everything</text>
	<text class="centered" x="443" y="535">accessible</text>
	<!-- Scanlines -->
	<text class="middle-baseline right" x="55" y="222">LY = 0</text>
	<rect class="scanline m2" y="210" x="60" width="80"/>
	<rect class="scanline m3" y="210" x="145" width="172"/>
	<rect class="scanline m0" y="210" x="322" width="204"/>
	<text class="middle-baseline darken" y="222" x="150">SHORTEST</text>
	<text class="middle-baseline darken right" y="222" x="525">LONGEST</text>
	<text class="middle-baseline small" x="535" y="222">456 dots</text>
	<text class="middle-baseline right" x="55" y="247">1</text>
	<rect class="scanline m2" y="235" x="60" width="80"/>
	<rect class="scanline m3" y="235" x="145" width="289"/>
	<rect class="scanline m0" y="235" x="439" width="87"/>
	<text class="middle-baseline darken" y="247" x="150">LONGEST</text>
	<text class="middle-baseline darken right" y="247" x="525">SHORTEST</text>
	<text class="middle-baseline small" x="535" y="247">456 dots</text>
	<text class="middle-baseline right" x="55" y="272">2</text>
	<rect class="scanline m2" y="260" x="60" width="80"/>
	<rect class="scanline m3" y="260" x="145" width="172"/>
	<rect class="scanline m30" y="260" x="322" width="112"/>
	<rect class="scanline m0" y="260" x="439" width="87"/>
	<text class="middle-baseline small" x="535" y="272">...</text>
	<text class="middle-baseline right" x="55" y="297">3</text>
	<rect class="scanline m2" y="285" x="60" width="80"/>
	<rect class="scanline m3" y="285" x="145" width="172"/>
	<rect class="scanline m30" y="285" x="322" width="112"/>
	<rect class="scanline m0" y="285" x="439" width="87"/>
	<text class="middle-baseline small" x="535" y="297">...</text>
	<text class="middle-baseline right" x="55" y="322">4</text>
	<rect class="scanline m2" y="310" x="60" width="80"/>
	<rect class="square m3" y="315" x="150"/>
	<rect class="square m3" y="315" x="175"/>
	<rect class="square m3" y="315" x="200"/>
	<text class="middle-baseline right" x="55" y="347">...</text>
	<rect class="square m2" y="340" x="70"/>
	<rect class="square m2" y="340" x="95"/>
	<rect class="square m2" y="340" x="120"/>
	<text class="middle-baseline right" x="55" y="372">...</text>
	<rect class="square m2" y="365" x="70"/>
	<text class="middle-baseline right" x="55" y="397">...</text>
	<rect class="square m2" y="390" x="70"/>
	<text class="middle-baseline right" x="55" y="422">143</text>
	<rect class="scanline m2" y="410" x="60" width="80"/>
	<rect class="scanline m3" y="410" x="145" width="172"/>
	<rect class="scanline m30" y="410" x="322" width="112"/>
	<rect class="scanline m0" y="410" x="439" width="87"/>
	<text class="middle-baseline right" x="55" y="447">144</text>
	<rect class="scanline m1" y="435" x="60" width="466"/>
	<text class="middle-baseline right" x="55" y="472">145</text>
	<rect class="scanline m1" y="460" x="60" width="466"/>
	<rect class="square m1" y="490" x="70"/>
	<rect class="square m1" y="515" x="70"/>
	<rect class="square m1" y="540" x="70"/>
	<text class="middle-baseline right" x="55" y="572">153</text>
	<rect class="scanline m1" y="560" x="60" width="466"/>
	<rect class="m1" y="435" x="533" height="145" width="2"/>
	<text class="middle-baseline small" x="540" y="490">10 "scanlines"</text>
	<text class="middle-baseline small" x="540" y="510">4560 dots</text>
	<!-- Totals -->
	<text class="centered" y="20" x="613">One frame:</text>
	<text class="centered" y="45" x="613">70224 dots</text>
	<text class="centered" y="70" x="613">@ 59.7 fps</text>
</svg>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>FIFO stands for <em>First In, First Out</em>. The first pixel to be pushed to the
FIFO is the first pixel to be popped off. In theory that sounds great,
in practice there are a lot of intricacies.</p>
<p>There are two pixel FIFOs. One for background pixels and one for OAM
(sprite) pixels. These two FIFOs are not shared. They are independent
of each other. The two FIFOs are mixed only when popping items. Sprites
take priority unless they’re transparent (color 0) which will be
explained in detail later. Each FIFO can hold up to 16 pixels. The FIFO
and Pixel Fetcher work together to ensure that the FIFO always contains
at least 8 pixels at any given time, as 8 pixels are required for the
Pixel Rendering operation to take place. Each FIFO is manipulated only
during mode 3 (pixel transfer).</p>
<p>Each pixel in the FIFO has four properties:</p>
<ul>
<li>Color: a value between 0 and 3</li>
<li>Palette: on CGB a value between 0 and 7 and on DMG this only applies to sprites</li>
<li>Sprite Priority: on CGB this is the OAM index for the sprite and on DMG this doesn’t exist</li>
<li>Background Priority: holds the value of the <a href="#vram-sprite-attribute-table-oam">OBJ-to-BG Priority</a> bit</li>
</ul>
<h2 id="fifo-pixel-fetcher"><a class="header" href="#fifo-pixel-fetcher">FIFO Pixel Fetcher</a></h2>
<p>The fetcher fetches a row of 8 background or window pixels and queues
them up to be mixed with sprite pixels. The pixel fetcher has 5 steps.
The first four steps take 2 dots each and the fifth step is attempted
every dot until it succeeds. The order of the steps are as follows:</p>
<ul>
<li>Get tile</li>
<li>Get tile data low</li>
<li>Get tile data high</li>
<li>Sleep</li>
<li>Push</li>
</ul>
<h3 id="get-tile"><a class="header" href="#get-tile">Get Tile</a></h3>
<p>This step determines which background/window tile to fetch pixels from.
By default the tilemap used is the one at $9800 but certain conditions
can change that.</p>
<p>When LCDC.3 is enabled and the X coordinate of the current scanline is
not inside the window then tilemap $9C00 is used.</p>
<p>When LCDC.6 is enabled and the X coordinate of the current scanline is
inside the window then tilemap $9C00 is used.</p>
<p>The fetcher keeps track of which X and Y coordinate of the tile it’s on:</p>
<p>If the current tile is a window tile, the X coordinate for the window
tile is used, otherwise the following formula is used to calculate
the X coordinate: ((SCX / 8) + fetcher’s X coordinate) &amp; $1F. Because of
this formula, fetcherX can be between 0 and 31.</p>
<p>If the current tile is a window tile, the Y coordinate for the window
tile is used, otherwise the following formula is used to calculate
the Y coordinate: (currentScanline + SCY) &amp; 255. Because of this formula,
fetcherY can be between 0 and 255.</p>
<p>The fetcher’s X and Y coordinate can then be used to get the tile from
VRAM. However, if the PPU’s access to VRAM is <a href="#vram-access">blocked</a>
then the value for the tile is read as $FF.</p>
<p>CGB can access both tile index and the attributes in the same clock
dot.</p>
<h3 id="get-tile-data-low"><a class="header" href="#get-tile-data-low">Get Tile Data Low</a></h3>
<p>Check LCDC.4 for which tilemap to use. At this step CGB also needs to
check which VRAM bank to use and check if the tile is flipped vertically.
Once the tilemap, VRAM and vertical flip is calculated the tile data
is retrieved from VRAM. However, if the PPU’s access to VRAM is
<a href="#vram-access">blocked</a> then the tile data is read as $FF.</p>
<p>The tile data retrieved in this step will be used in the push steps.</p>
<h3 id="get-tile-data-high"><a class="header" href="#get-tile-data-high">Get Tile Data High</a></h3>
<p>Same as Get Tile Data Low except the tile address is incremented by 1.</p>
<p>The tile data retrieved in this step will be used in the push steps.</p>
<p>This also pushes a row of background/window pixels to the FIFO. This
extra push is not part of the 8 steps, meaning there’s 3 total chances to
push pixels to the background FIFO every time the complete fetcher steps
are performed.</p>
<h3 id="push"><a class="header" href="#push">Push</a></h3>
<p>Pushes a row of background/window pixels to the FIFO. Since tiles are 8
pixels wide, a “row” of pixels is 8 pixels from the tile to be rendered
based on the X and Y coordinates calculated in the previous steps.</p>
<p>Pixels are only pushed to the background FIFO if it’s empty.</p>
<p>This is where the tile data retrieved in the two Tile Data steps will
come in handy. Depending on if the tile is flipped horizontally the
pixels will be pushed to the background FIFO differently. If the tile
is flipped horizontally the pixels will be pushed LSB first. Otherwise
they will be pushed MSB first.</p>
<h3 id="sleep"><a class="header" href="#sleep">Sleep</a></h3>
<p>Do nothing.</p>
<h3 id="vram-access"><a class="header" href="#vram-access">VRAM Access</a></h3>
<p>At various times during PPU operation read access to VRAM is blocked and
the value read is $FF:</p>
<ul>
<li>LCD turning off</li>
<li>At scanline 0 on CGB when not in double speed mode</li>
<li>When switching from mode 3 to mode 0</li>
<li>On CGB when searching OAM and index 37 is reached</li>
</ul>
<p>At various times during PPU operation read access to VRAM is restored:</p>
<ul>
<li>At scanline 0 on DMG and CGB when in double speed mode</li>
<li>On DMG when searching OAM and index 37 is reached</li>
<li>After switching from mode 2 (oam search) to mode 3 (pixel transfer)</li>
</ul>
<p>NOTE: These conditions are checked only when entering STOP mode and the
PPU’s access to VRAM is always restored upon leaving STOP mode.</p>
<h2 id="mode-3-operation"><a class="header" href="#mode-3-operation">Mode 3 Operation</a></h2>
<p>As stated before the pixel FIFO only operates during mode 3 (pixel
transfer). At the beginning of mode 3 both the background and OAM FIFOs
are cleared.</p>
<h3 id="the-window"><a class="header" href="#the-window">The Window</a></h3>
<p>When rendering the window the background FIFO is cleared and the fetcher
is reset to step 1. When WX is 0 and the SCX &amp; 7 &gt; 0 mode 3 is shortened
by 1 dot.</p>
<p>When the window has already started rendering there is a bug that occurs
when WX is changed mid-scanline. When the value of WX changes after the
window has started rendering and the new value of WX is reached again,
a pixel with color value of 0 and the lowest priority is pushed onto the
background FIFO.</p>
<h3 id="sprites"><a class="header" href="#sprites">Sprites</a></h3>
<p>The following is performed for each sprite on the current scanline if
LCDC.1 is enabled (this condition is ignored on CGB) and the X coordinate
of the current scanline has a sprite on it. If those conditions are not
met then sprite fetching is <a href="#sprite-fetch-abortion">aborted</a>.</p>
<p>At this point the <a href="#fifo-pixel-fetcher">fetcher</a> is advanced one step
until it’s at step 5 or until the background FIFO is not empty. Advancing
the fetcher one step here lengthens mode 3 by 1 dot. This process may
be <a href="#sprite-fetch-abortion">aborted</a> after the fetcher has advanced a
step.</p>
<p>When SCX &amp; 7 &gt; 0 and there is a sprite at X coordinate 0 of the current
scanline then mode 3 is lengthened. The amount of dots this lengthens
mode 3 by is whatever the lower 3 bits of SCX are. After this penalty is
applied object fetching may be aborted. Note that the timing of the
penalty is not confirmed. It may happen before or after waiting for the
fetcher. More research needs to be done.</p>
<p>After checking for sprites at X coordinate 0 the fetcher is advanced two
steps. The first advancement lengthens mode 3 by 1 dot and the second
advancement lengthens mode 3 by 3 dots. After each fetcher advancement
there is a chance for a sprite fetch abortion to occur.</p>
<p>The lower address for the row of pixels of the target object tile is now
retrieved and lengthens mode 3 by 1 dot. Once the address is retrieved
this is the last chance for sprite fetch abortion to occur. Exiting
object fetch lengthens mode 3 by 1 dot. The upper address for the
target object tile is now retrieved and does not shorten mode 3.</p>
<p>At this point <a href="#vram-access">VRAM Access</a> is checked for the lower and
upper addresses for the target object. Before any mixing is done, if the
OAM FIFO doesn’t have at least 8 pixels in it then transparent pixels
with the lowest priority are pushed onto the OAM FIFO. Once this is done
each pixel of the target object row is checked. On CGB, horizontal flip
is checked here. If the target object pixel is not white and the pixel in
the OAM FIFO <em>is</em> white, or if the pixel in the OAM FIFO has higher
priority than the target object’s pixel, then the pixel in the OAM FIFO
is replaced with the target object’s properties.</p>
<p>Now it’s time to <a href="#pixel-rendering">render a pixel</a>! The same process
described in Sprite Fetch Abortion is performed: a pixel is rendered and
the fetcher is advanced one step. This advancement lengthens mode 3 by 1
dot if the X coordinate of the current scanline is not 160. If the X
coordinate is 160 the PPU stops processing sprites (because they won’t be
visible).</p>
<p>Everything in this section is repeated for every sprite on the current
scanline unless it was decided that fetching should be aborted or the
X coordinate is 160.</p>
<h3 id="pixel-rendering"><a class="header" href="#pixel-rendering">Pixel Rendering</a></h3>
<p>This is where the background FIFO and OAM FIFO are mixed. There are
conditions where either a background pixel or a sprite pixel will have
display priority.</p>
<p>If there are pixels in the background and OAM FIFOs then a pixel is
popped off each. If the OAM pixel is not transparent and LCDC.1 is
enabled then the OAM pixel’s background priority property is used if it’s
the same or higher priority as the background pixel’s background priority.</p>
<p>Pixels won’t be pushed to the LCD if there is nothing in the background
FIFO or the current pixel is pixel 160 or greater.</p>
<p>If LCDC.0 is disabled then the background is disabled on DMG and the
background pixel won’t have priority on CGB. When the background pixel
is disabled the pixel color value will be 0, otherwise the color value
will be whatever color pixel was popped off the background FIFO. When the
pixel popped off the background FIFO has a color value other than 0 and
it has priority then the sprite pixel will be discarded.</p>
<p>At this point, on DMG, the color of the pixel is retrieved from the BGP
register and pushed to the LCD. On CGB when <a href="#cgb-palette-access">palette access</a>
is blocked a black pixel is pushed to the LCD.</p>
<p>When a sprite pixel has priority the color value is retrieved from the
popped pixel from the OAM FIFO. On DMG the color for the pixel is
retrieved from either the OBP1 or OBP0 register depending on the pixel’s
palette property. If the palette property is 1 then OBP1 is used,
otherwise OBP0 is used. The pixel is then pushed to the LCD. On CGB when
palette access is blocked a black pixel is pushed to the LCD.</p>
<p>The pixel is then finally pushed to the LCD.</p>
<h3 id="cgb-palette-access"><a class="header" href="#cgb-palette-access">CGB Palette Access</a></h3>
<p>At various times during PPU operation read access to the CGB palette is
blocked and a black pixel pushed to the LCD when rendering pixels:</p>
<ul>
<li>LCD turning off</li>
<li>First HBlank of the frame</li>
<li>When searching OAM and index 37 is reached</li>
<li>After switching from mode 2 (oam search) to mode 3 (pixel transfer)</li>
<li>When entering HBlank (mode 0) and not in double speed mode, blocked 2 dots later no matter what</li>
</ul>
<p>At various times during PPU operation read access to the CGB palette is
restored and pixels are pushed to the LCD normally when rendering pixels:</p>
<ul>
<li>At the end of mode 2 (oam search)</li>
<li>For only 2 dots when entering HBlank (mode 0) and in double speed mode</li>
</ul>
<div class="box tip">
<p class="box-title">Note</p><p>These conditions are checked only when entering STOP mode and the
PPU’s access to CGB palettes is always restored upon leaving STOP mode.</p>
</div>
<h3 id="sprite-fetch-abortion"><a class="header" href="#sprite-fetch-abortion">Sprite Fetch Abortion</a></h3>
<p>Sprite fetching may be aborted if LCDC.1 is disabled while the PPU is
fetching an object from OAM. This abortion lengthens mode 3 by the amount
of dots the previous instruction took plus the residual dots left for
the PPU to process. When OAM fetching is aborted a pixel is <a href="#pixel-rendering">rendered</a>,
the <a href="#fifo-pixel-fetcher">fetcher</a> is advanced one step. This advancement
lengthens mode 3 by 1 dot if the current pixel is not 160. If the
current pixel is 160 the PPU stops processing sprites because they won’t
be visible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-overview"><a class="header" href="#audio-overview">Audio Overview</a></h1>
<p>Game Boy audio is sometimes called “8-bit”.
This does not refer to the bit depth of the sound generated, but rather that it has sound capabilities typical of 8-bit consoles.
Like much of its contemporary hardware, the Game Boy produces sound generated by simple digital circuits.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<svg viewBox="0 0 480 220" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style type="text/css"><![CDATA[
      text {
        fill: var(--fg);
        dominant-baseline: middle;
      }
      .centered { text-anchor: middle; }
      .right    { text-anchor: end; }
      rect, path, use {
        stroke: var(--fg);
        fill: var(--fg);
      }
      .inverted {
        stroke: var(--bg);
        fill: var(--bg);
      }
      .unfilled {
        fill: none !important;
      }
      .no-stroke {
        stroke: none !important;
      }
    ]]></style>
    <path d="M 0,-5
             v 10
             l 10,-5
             z" id="arrow-head"/>
  </defs>
  <text x="85" y="36" class="right">Channel 1</text>
  <rect x="95" y="15" width="40" height="40"/>
  <path d="M 95,45
           h 10
           v -20
           h 10
           v 20
           h 10
           v -20
           h 10" class="inverted unfilled"/>
  <text x="85" y="86" class="right">Channel 2</text>
  <rect x="95" y="65" width="40" height="40"/>
  <path d="M 95,95
           h 10
           v -20
           h 10
           v 20
           h 10
           v -20
           h 10" class="inverted unfilled"/>
  <text x="85" y="136" class="right">Channel 3</text>
  <rect x="95" y="115" width="40" height="40"/>
  <path d="M 95,141
           h 2
           v -2
           h 2
           v -3
           h 2
           v -3
           h 2
           v -3
           h 2
           v -2
           h 2
           v -1
           h 2
           v 1
           h 2
           v 2
           h 2
           v 5
           h 2
           v 4
           h 2
           v 2
           h 2
           v 1
           h 4
           v -10
           h 2
           v -5
           h 2
           v 15
           h 2
           v -14
           h 2
           v 7
           h 2
           v 4
           h 2
           v 2
           h 4
           v 1
           h 4
           v -1
           h 2
           v -1
           h 2
           v -2
           h 2
           v -2
           h 2
           v -3
           h 2
           v -2
           h 2
           v -2
           h 2" class="inverted unfilled"/>
  <text x="85" y="186" class="right">Channel 4</text>
  <rect x="95" y="165" width="40" height="40"/>
  <path d="M 95,195
           h 2
           v -20
           h 2
           v 20
           h 5
           v -20
           h 2
           v 20
           h 1
           v -20
           h 6
           v 20
           h 3
           v -20
           h 2
           v 20
           h 1
           v -20
           h 2
           v 20
           h 5
           v -20
           h 1
           v 20
           h 4
           v -20
           h 2
           v 20
           h 1
           v -20
           h 1" class="inverted unfilled"/>
  <path d="M 135,35
           h 30
           m -30,50
           h 30
           m -30,50
           h 30
           m -30,50
           h 30
           v -150
           m 0,75
           h 30" class="unfilled"/>
  <use x="185" y="110" href="#arrow-head"/>
  <rect x="195" y="95" width="60" height="30"/>
  <text x="225" y="110" class="centered inverted no-stroke">Mixer</text>
  <path d="M 255,102
           h 30" class="unfilled"/>
  <use x="275" y="102" href="#arrow-head"/>
  <path d="M 255,118
           h 30" class="unfilled"/>
  <use x="275" y="118" href="#arrow-head"/>
  <rect x="285" y="95" width="80" height="30"/>
  <text x="325" y="110" class="centered inverted no-stroke">Amplifier</text>
  <path d="M 365,102
           h 30" class="unfilled"/>
  <use x="385" y="102" href="#arrow-head"/>
  <path d="M 365,118
           h 30" class="unfilled"/>
  <use x="385" y="118" href="#arrow-head"/>
  <rect x="395" y="95" width="80" height="30"/>
  <text x="435" y="110" class="centered inverted no-stroke">Output</text>
</svg>
<p>The Game Boy has four sound generation units, called <strong>channels</strong> 1 through 4, notated “CH1”, “CH2”, etc.
Unlike some other sound chips, such as the C64’s SID or the Atari 5200’s POKEY, each sound channel is specialized in a way largely different from the other channels.</p>
<p>Each channel generates an electronic signal; these signals are then mixed into two new channels (for stereo: one for the left ear, one for the right ear), which are then individually amplified, and then output either to the headphone jack, or the speaker<sup class="footnote-reference"><a href="#speaker_mono">1</a></sup>.</p>
<p>Channels 1 and 2, the “pulse channels”, produce <a href="https://en.wikipedia.org/wiki/Pulse-width_modulation">pulse width modulated waves</a> with 4 fixed pulse width settings.
Channel 3, the “wave” channel, produces arbitrary user-supplied waves.
Channel 4 is the “<a href="https://en.wikipedia.org/wiki/Noise_in_music">noise</a>” channel, producing a pseudo-random wave.</p>
<p>The VIN channel is an analog signal received directly from the cartridge, allowing external hardware to supply a fifth sound channel.
No licensed games used this feature, and it was omitted from the Game Boy Advance.</p>
<div class="box tip">
<p class="box-title">POCKET MUSIC</p><p>Despite some online claims, <em>Pocket Music</em> does not use VIN.
It refuses to run on the GBA for a different reason: the developer couldn’t figure out how to silence buzzing associated with sample playback on the wave channel.</p>
</div>
<div class="footnote-definition" id="speaker_mono"><sup class="footnote-definition-label">1</sup>
<p>The speaker merges back the two channels, losing the stereo aspect entirely.</p>
</div>
<h2 id="common-concepts"><a class="header" href="#common-concepts">Common concepts</a></h2>
<h3 id="apu"><a class="header" href="#apu">APU</a></h3>
<p>The Game Boy’s sound chip is called the <abbr title="Audio Processing Unit">APU</abbr>.</p>
<p>The APU runs off the same master clock as the rest of the Game Boy, which is to say, it is fully synced with the CPU and <a href="#rendering-overview">PPU</a>.
This also means that the APU runs about 2.4% faster on the SGB1, increasing frequencies by as much and thus sounding slightly higher-pitched.
The SGB2 rectifies this issue.</p>
<p>All interfaces to the APU use <strong>durations</strong> instead of frequencies, which may be confusing as signal theory and music are more typically based on the latter.
Thus, durations will be expressed from their frequencies: for example, a “256 Hz tick” means “1 ∕ 256th of a second”.</p>
<p>The length of APU ticks is not affected by <a href="#ff4d--key1-cgb-mode-only-prepare-speed-switch">CGB double speed</a>, so the APU works just the same regardless of CPU speed.</p>
<div class="box warning">
<p>The Game Boy’s APU is actually full of tricky details; this chapter will mostly describe the intended / common behavior, and often paper over bugs &amp; quirks.
Readers wishing to learn more should read the <a href="#audio-details">APU details</a> chapter.</p>
</div>
<h3 id="triggering"><a class="header" href="#triggering">Triggering</a></h3>
<p><strong>Triggering</strong> a channel causes it to turn on if it wasn’t<sup class="footnote-reference"><a href="#trig_dac_off">2</a></sup>, and to start playing its wave from the beginning<sup class="footnote-reference"><a href="#pulse_restart">3</a></sup>.
Most changes to a channel’s parameters take effect immediately, but some require re-triggering the channel.</p>
<h3 id="volume--envelope"><a class="header" href="#volume--envelope">Volume &amp; envelope</a></h3>
<p>The volume can be controlled in two ways: there is a “master volume” control<sup class="footnote-reference"><a href="#vol_knob">4</a></sup> (which has separate settings for the left and right outputs), and each channel’s volume can be individually set as well (CH3’s less precisely than the others).</p>
<p>Additionally, an <a href="https://en.wikipedia.org/wiki/Envelope_(music)"><strong>envelope</strong></a> can be configured for CH1, CH2 and CH4, which allows automatically adjusting the volume over time.
The parameters that can be controlled are the initial volume, the envelope’s direction (but not its slope), and its duration.
Internally, all envelopes are ticked at 64 Hz, and every 1–7 of those ticks, the volume will be increased or decreased.</p>
<h3 id="length-timer"><a class="header" href="#length-timer">Length timer</a></h3>
<p>All channels can be individually set to automatically shut themselves down after a certain amount of time.</p>
<p>If the functionality is enabled, a channel’s <strong>length timer</strong> ticks up<sup class="footnote-reference"><a href="#len_cnt_dir">5</a></sup> at 256 Hz (tied to <a href="#div-apu">DIV-APU</a>) from the value it’s initially set at.
When the length timer reaches 64, the channel is turned off.</p>
<h3 id="frequency"><a class="header" href="#frequency">Frequency</a></h3>
<p>Music notes and audio waves are typically manipulated in terms of <strong>frequency</strong><sup class="footnote-reference"><a href="#pitch">6</a></sup>, i.e. how often the signal repeats per second.
However, as explained above, the Game Boy APU primarily works with durations; thus, <strong>wavelengths</strong> will be used instead of frequency.<sup class="footnote-reference"><a href="#len_raw">7</a></sup></p>
<div class="box warning">
<p>The term “wavelength” throughout this document does <em>not</em> designate the inverse of the frequency, but instead a quantity akin to it.
See the description of each NRx3 register for more information.</p>
</div>
<hr />
<div class="footnote-definition" id="trig_dac_off"><sup class="footnote-definition-label">2</sup>
<p>If <a href="#dacs">the channel’s DAC</a> is off, the channel will not turn on.</p>
</div>
<div class="footnote-definition" id="pulse_restart"><sup class="footnote-definition-label">3</sup>
<p>Except for pulse channels, whose phase position is only ever reset by turning the APU off.
This is usually not noticeable unless changing the duty cycle mid-note.</p>
</div>
<div class="footnote-definition" id="vol_knob"><sup class="footnote-definition-label">4</sup>
<p>This is separate from the physical volume knob located on the side of the console.</p>
</div>
<div class="footnote-definition" id="len_cnt_dir"><sup class="footnote-definition-label">5</sup>
<p>Internally, the length timer is inverted when written, and <em>that</em> ticks down until it reaches 0.
But the effect is as if the counter ticked up.</p>
</div>
<div class="footnote-definition" id="pitch"><sup class="footnote-definition-label">6</sup>
<p>There is also <strong>pitch</strong>, which is merely a measure of how we perceive frequency.
The higher the frequency, the higher the pitch; therefore, pitch will be omitted from the rest of the document.</p>
</div>
<div class="footnote-definition" id="len_raw"><sup class="footnote-definition-label">7</sup>
<p>Actually, the APU interfaces don’t work with any wavelengths either, but with values that are more akin to wavelengths than frequencies.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-registers"><a class="header" href="#audio-registers">Audio Registers</a></h1>
<p>Audio registers are named following a <code>NRxy</code> scheme, where <code>x</code> is the channel number (or <code>5</code> for “global” registers), and <code>y</code> is the register’s ID within the channel.
Since many registers share common properties, a notation is often used where e.g. <code>NRx2</code> is used to designate <code>NR12</code>, <code>NR22</code>, <code>NR32</code>, and <code>NR42</code> at the same time, for simplicity.</p>
<p>As a rule of thumb, for any <code>x</code> in <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>:</p>
<ul>
<li><code>NRx0</code> is some channel-specific feature (if present),</li>
<li><code>NRx1</code> controls the length timer,</li>
<li><code>NRx2</code> controls the volume and envelope,</li>
<li><code>NRx3</code> controls the wavelength (maybe only partially),</li>
<li><code>NRx4</code> has the channel’s trigger and length timer enable bits;</li>
</ul>
<p>…but there are some exceptions.</p>
<p>One of the pitfalls of the <code>NRxy</code> naming convention is that the register’s purpose is not immediately clear from its name, so some alternative names have been proposed, <a href="https://github.com/gbdev/hardware.inc/blob/05f5a9b6c7172abe1d7488080c1c050284c09226/hardware.inc#L415">such as <code>AUDENA</code> for <code>NR52</code></a>.</p>
<h2 id="global-control-registers"><a class="header" href="#global-control-registers">Global control registers</a></h2>
<h3 id="ff26--nr52-sound-onoff"><a class="header" href="#ff26--nr52-sound-onoff">FF26 — NR52: Sound on/off</a></h3>
<p>This register controls whether the APU is powered on at all (akin to <a href="#lcdc7--lcd-enable"><code>LCDC</code> bit 7</a>), and allows checking whether channels are active<sup class="footnote-reference"><a href="#nr52_dac">1</a></sup>.
Turning the APU off drains less power (around 16%), but clears all APU registers and makes them read-only until turned back on, except <code>NR52</code><sup class="footnote-reference"><a href="#dmg_apu_off">2</a></sup>.</p>
<pre><code> Bit 7 - All sound on/off  (0: turn the APU off) (Read/Write)
 Bit 3 - Channel 4 ON flag (Read Only)
 Bit 2 - Channel 3 ON flag (Read Only)
 Bit 1 - Channel 2 ON flag (Read Only)
 Bit 0 - Channel 1 ON flag (Read Only)
</code></pre>
<p>Bits 0-3 of this register are read-only status bits.
Writing to those does NOT enable or disable the channels, despite many emulators behaving as if.</p>
<p>A channel is turned on by triggering it (i.e. setting bit 7 of <code>NRx4</code>)<sup class="footnote-reference"><a href="#dac_off">3</a></sup>.
A channel is turned off when any of the following occurs:</p>
<ul>
<li>The channel’s length timer, if enabled in <code>NRx4</code>, expires</li>
<li>For CH1: when the wavelength sweep overflows<sup class="footnote-reference"><a href="#freq_sweep_underflow">4</a></sup></li>
<li><a href="#dacs">The channel’s DAC</a> is turned off</li>
</ul>
<p>The envelope reaching a volume of 0 does NOT turn the channel off!</p>
<div class="footnote-definition" id="nr52_dac"><sup class="footnote-definition-label">1</sup>
<p>Actually, the low nibble of NR52 only reports whether the channels’ <em>generation</em> circuits are enabled, not if <a href="#dacs">the DACs</a> are.</p>
</div>
<div class="footnote-definition" id="dmg_apu_off"><sup class="footnote-definition-label">2</sup>
<p>…and the length timers (in <code>NRx1</code>) on monochrome models.</p>
</div>
<div class="footnote-definition" id="dac_off"><sup class="footnote-definition-label">3</sup>
<p>If <a href="#dacs">the DAC</a> is off, then the write to NRx4 will be ineffective and won’t turn the channel on.</p>
</div>
<div class="footnote-definition" id="freq_sweep_underflow"><sup class="footnote-definition-label">4</sup>
<p>The wavelength sweep cannot normally underflow, so a “decreasing” sweep (<code>NR10</code> bit 3 set) won’t turn the channel off.</p>
</div>
<h3 id="ff25--nr51-sound-panning"><a class="header" href="#ff25--nr51-sound-panning">FF25 — NR51: Sound panning</a></h3>
<p>Each channel can be panned hard left, center, hard right, or ignored entirely.</p>
<pre><code>Bit 7 - Mix channel 4 into left output
Bit 6 - Mix channel 3 into left output
Bit 5 - Mix channel 2 into left output
Bit 4 - Mix channel 1 into left output
Bit 3 - Mix channel 4 into right output
Bit 2 - Mix channel 3 into right output
Bit 1 - Mix channel 2 into right output
Bit 0 - Mix channel 1 into right output
</code></pre>
<h3 id="ff24--nr50-master-volume--vin-panning"><a class="header" href="#ff24--nr50-master-volume--vin-panning">FF24 — NR50: Master volume &amp; VIN panning</a></h3>
<p>The volume bits specify the master volume, i.e. how much each output should be scaled.
A value of 0 is treated as a volume of 1 (very quiet), and a value of 7 is treated as a volume of 8 (no volume reduction).
Importantly, the amplifier <strong>never mutes</strong> a non-silent input.</p>
<p>The VIN mixing bits work exactly like bits in <a href="#ff25--nr51-sound-panning"><code>NR51</code></a>.</p>
<pre><code>Bit 7   - Mix VIN into left output  (1=Enable)
Bit 6-4 - Left output volume        (0-7)
Bit 3   - Mix VIN into right output (1=Enable)
Bit 2-0 - Right output volume       (0-7)
</code></pre>
<h2 id="sound-channel-1--pulse-with-wavelength-sweep"><a class="header" href="#sound-channel-1--pulse-with-wavelength-sweep">Sound Channel 1 — Pulse with wavelength sweep</a></h2>
<h3 id="ff10--nr10-channel-1-sweep"><a class="header" href="#ff10--nr10-channel-1-sweep">FF10 — NR10: Channel 1 sweep</a></h3>
<p>This register controls CH1’s wavelength sweep functionality.</p>
<pre><code>Bit 6-4 - Sweep pace
Bit 3   - Sweep increase/decrease
           0: Addition    (wavelength increases)
           1: Subtraction (wavelength decreases)
Bit 2-0 - Sweep slope control (n: 0-7)
</code></pre>
<p>The <var>sweep pace</var> dictates how often the wavelength gets changed, in units of 128 Hz ticks<sup class="footnote-reference"><a href="#div_apu">5</a></sup> (7.8 ms).
The pace is only reloaded after the following sweep iteration, or when (re)triggering the channel.
However, if bits 4–6 are all set to 0, then iterations are instantly disabled, and the pace will be reloaded immediately if it’s set to something else.</p>
<p>On each sweep iteration, the wavelength in <a href="#ff13--nr13-channel-1-wavelength-low-write-only"><code>NR13</code></a> and <a href="#ff14--nr14-channel-1-wavelength-high--control"><code>NR14</code></a> is modified and written back.
That is, unless <var>n</var> (the slope) is 0, in which case iterations do nothing (in this case, subtraction mode should be set, see below).</p>
<p>On each tick, the new wavelength <math><msub><mi>L</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></math> is computed from the current one <math><msub><mi>L</mi><mi>t</mi></msub></math> as follows:</p>
<math display="block">
  <msub><mi>L</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>=</mo> <msub><mi>L</mi><mi>t</mi></msub> <mo>±</mo> <mfrac><msub><mi>L</mi><mi>t</mi></msub><msup><mn>2</mn><mi>n</mi></msup></mfrac>
</math>
<p>In addition mode, if the wavelength would overflow (i.e. <math><msub><mi>L</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></math> is strictly more than $7FF), the channel is turned off instead.
<strong>This occurs even if sweep iterations are disabled</strong> by <var>n</var> = 0.</p>
<p>Note that if the wavelength ever becomes 0, the wavelength sweep will never be able to change it.
For the same reason, the wavelength sweep cannot underflow the wavelength (which would turn the channel off).</p>
<div class="footnote-definition" id="div_apu"><sup class="footnote-definition-label">5</sup>
<p><a href="#div-apu">As long as <code>DIV</code> is not written to</a>.</p>
</div>
<h3 id="ff11--nr11-channel-1-length-timer--duty-cycle"><a class="header" href="#ff11--nr11-channel-1-length-timer--duty-cycle">FF11 — NR11: Channel 1 length timer &amp; duty cycle</a></h3>
<p>This register controls both the channel’s <a href="#length-timer">length timer</a> and <a href="https://en.wikipedia.org/wiki/Duty_cycle">duty cycle</a> (the ratio of the time spent low vs. high).
However, the selected duty cycle also alters the phase, although the effect is hardly noticeable.</p>
<pre><code>Bit 7-6 - Wave duty            (Read/Write)
Bit 5-0 - Initial length timer (Write Only)
</code></pre>
<style>
.waveform {
  display: block;
  width: 16rem;
  background-image: repeating-linear-gradient(to right, var(--bg), var(--bg) 1rem, var(--table-alternate-bg) 1rem, var(--table-alternate-bg) 2rem);
  border: 1px solid var(--table-header-bg);
}
.waveform polyline {
  stroke-width: 1px;
  stroke: var(--inline-code-color);
  fill: none;
}
</style>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Wave duty (binary)</th><th style="text-align: center">Duty cycle</th><th>Waveform</th></tr></thead><tbody>
<tr><td style="text-align: right">00</td><td style="text-align: center">12.5 %</td><td><svg viewBox="0 -1 80 12" preserveAspectRatio="xMidYMid meet" class="waveform"><polyline points="0,0 35,0 35,10 40,10 40,0 75,0 75,10 80,10 80,0"/></svg></td></tr>
<tr><td style="text-align: right">01</td><td style="text-align: center">25 %</td><td><svg viewBox="0 -1 80 12" preserveAspectRatio="xMidYMid meet" class="waveform"><polyline points="0,10 5,10 5,0 35,0 35,10 45,10 45,0 75,0 75,10 80,10"/></svg></td></tr>
<tr><td style="text-align: right">10</td><td style="text-align: center">50 %</td><td><svg viewBox="0 -1 80 12" preserveAspectRatio="xMidYMid meet" class="waveform"><polyline points="0,10 5,10 5,0 25,0 25,10 45,10 45,0 65,0 65,10 80,10"/></svg></td></tr>
<tr><td style="text-align: right">11</td><td style="text-align: center">75 %</td><td><svg viewBox="0 -1 80 12" preserveAspectRatio="xMidYMid meet" class="waveform"><polyline points="0,0 5,0 5,10 35,10 35,0 45,0 45,10 75,10 75,0 80,0"/></svg></td></tr>
</tbody></table>
</div>
<p>It’s worth noting that there is no audible difference between the 25 % and 75 % duty cycle settings.</p>
<p>The higher the <a href="#length-timer">length timer</a> field, the shorter the time before the channel is cut.</p>
<h3 id="ff12--nr12-channel-1-volume--envelope"><a class="header" href="#ff12--nr12-channel-1-volume--envelope">FF12 — NR12: Channel 1 volume &amp; envelope</a></h3>
<p>This register controls the digital amplitude of the “high” part of the pulse, and the sweep applied to that setting.</p>
<pre><code>Bit 7-4 - Initial volume of envelope (0-F) (0=No Sound)
Bit 3   - Envelope direction (0=Decrease, 1=Increase)
Bit 2-0 - Sweep pace (0=No Sweep)
</code></pre>
<p>Setting bits 3-7 of this register all to 0 turns the DAC off (and thus, the channel as well), which <a href="#mixer">may cause an audio pop</a>.</p>
<p>The envelope ticks at 64 Hz, and the channel’s envelope will be increased / decreased (depending on bit 3) every <var>Sweep pace</var> of those ticks.</p>
<p>Writes to this register while the channel is on require retriggering it afterwards.</p>
<h3 id="ff13--nr13-channel-1-wavelength-low-write-only"><a class="header" href="#ff13--nr13-channel-1-wavelength-low-write-only">FF13 — NR13: Channel 1 wavelength low [write-only]</a></h3>
<p>This register stores the low 8 bits of the channel’s 11-bit “<a href="#frequency">wavelength</a>”.
The upper 3 bits are stored in the low 3 bits of <code>NR14</code>.</p>
<p>The actual signal frequency is <math><mfrac><mn>131072</mn><mrow><mn>2048</mn><mo>-</mo><mi>wavelen</mi></mrow></mfrac></math> Hz: the higher the value, the higher the frequency.
This is the whole wave’s frequency; the rate at which the channel steps through the 8 “steps” in its wave form is 8× that, i.e. <math><mfrac><mn>1048576</mn><mrow><mn>2048</mn><mo>-</mo><mi>wavelen</mi></mrow></mfrac></math> Hz = <math><mfrac><mn>1</mn><mrow><mn>2048</mn><mo>-</mo><mn>wavelen</mn></mrow></mfrac></math> MiHz.</p>
<h3 id="ff14--nr14-channel-1-wavelength-high--control"><a class="header" href="#ff14--nr14-channel-1-wavelength-high--control">FF14 — NR14: Channel 1 wavelength high &amp; control</a></h3>
<pre><code>Bit 7   - Trigger (1=Restart channel)  (Write Only)
Bit 6   - Sound Length enable          (Read/Write)
          (1=Stop output when length in NR11 expires)
Bit 2-0 - &quot;Wavelength&quot;'s higher 3 bits (Write Only)
</code></pre>
<p>Writing a value here with bit 7 set <a href="#triggering">triggers</a> the channel.</p>
<p>Bit 6 takes effect immediately upon writing to this register.</p>
<h2 id="sound-channel-2--pulse"><a class="header" href="#sound-channel-2--pulse">Sound Channel 2 — Pulse</a></h2>
<p>This sound channel works exactly like channel 1, except that it lacks a wavelength sweep (and thus an equivalent to <a href="#ff10--nr10-channel-1-sweep"><code>NR10</code></a>).
Please refer to the corresponding CH1 register:</p>
<ul>
<li><code>NR21</code> ($FF16) → <a href="#ff11--nr11-channel-1-length-timer--duty-cycle"><code>NR11</code></a></li>
<li><code>NR22</code> ($FF17) → <a href="#ff12--nr12-channel-1-volume--envelope"><code>NR12</code></a></li>
<li><code>NR23</code> ($FF18) → <a href="#ff13--nr13-channel-1-wavelength-low-write-only"><code>NR13</code></a></li>
<li><code>NR24</code> ($FF19) → <a href="#ff14--nr14-channel-1-wavelength-high--control"><code>NR14</code></a></li>
</ul>
<h2 id="sound-channel-3--wave-output"><a class="header" href="#sound-channel-3--wave-output">Sound Channel 3 — Wave output</a></h2>
<p>While other channels only offer limited control over the waveform they generate, this channel allows outputting any wave.
It’s thus sometimes called a “voluntary wave” channel.</p>
<p>While the “length” of the wave is fixed at 32 “samples”, 4-bit each, the speed at which it is read can be customized.
It’s possible to “shorten” the wave by either feeding it a repeating pattern, or doubling each sample and doubling the read rate.
It’s also possible to artificially “increase” the wave’s length by loading a new wave as soon as the whole buffer has been read; this is sometimes used for full-on sample playback.</p>
<h3 id="ff1a--nr30-channel-3-dac-enable"><a class="header" href="#ff1a--nr30-channel-3-dac-enable">FF1A — NR30: Channel 3 DAC enable</a></h3>
<p>This register controls CH3’s DAC.
Like other channels, turning the DAC off immediately turns the channel off as well.</p>
<pre><code>Bit 7 - Sound Channel 3 DAC  (0=Off, 1=On)
</code></pre>
<p>The DAC is often turned off just before writing to <a href="#ff30ff3f--wave-pattern-ram">wave RAM</a> to avoid issues with accessing it; see further below for more info.</p>
<p>Turning the DAC off <a href="#mixer">may cause an audio pop</a>.</p>
<h3 id="ff1b--nr31-channel-3-length-timer-write-only"><a class="header" href="#ff1b--nr31-channel-3-length-timer-write-only">FF1B — NR31: Channel 3 length timer [write-only]</a></h3>
<p>This register controls the channel’s <a href="#length-timer">length timer</a>.</p>
<pre><code>Bit 7-0 - length timer
</code></pre>
<p>The higher the <a href="#length-timer">length timer</a>, the shorter the time before the channel is cut.</p>
<h3 id="ff1c--nr32-channel-3-output-level"><a class="header" href="#ff1c--nr32-channel-3-output-level">FF1C — NR32: Channel 3 output level</a></h3>
<p>This channel lacks the envelope functionality that the other three channels have.</p>
<pre><code>Bits 6-5 - Output level selection
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Bits 6-5 (binary)</th><th>Output level</th></tr></thead><tbody>
<tr><td style="text-align: right">%00</td><td>Mute (No sound)</td></tr>
<tr><td style="text-align: right">%01</td><td>100% volume (use samples read from Wave RAM as-is)</td></tr>
<tr><td style="text-align: right">%10</td><td>50% volume (shift samples read from Wave RAM right once)</td></tr>
<tr><td style="text-align: right">%11</td><td>25% volume (shift samples read from Wave RAM right twice)</td></tr>
</tbody></table>
</div>
<h3 id="ff1d--nr33-channel-3-wavelength-low-write-only"><a class="header" href="#ff1d--nr33-channel-3-wavelength-low-write-only">FF1D — NR33: Channel 3 wavelength low [write-only]</a></h3>
<p>This register stores the low 8 bits of the channel’s 11-bit “<a href="#frequency">wavelength</a>”.
The upper 3 bits are stored in the low 3 bits of <code>NR34</code>.</p>
<p>The actual signal frequency is <math><mfrac><mn>65536</mn><mrow><mn>2048</mn><mo>-</mo><mi>wavelen</mi></mrow></mfrac></math> Hz: the higher the value, the higher the frequency.
This is the whole wave’s frequency; the rate at which the channel steps through the 8 “indices” in its wave form is 32 times that, i.e. <math><mfrac><mn>2097152</mn><mrow><mn>2048</mn><mo>-</mo><mi>wavelen</mi></mrow></mfrac></math>) Hz = <math><mfrac><mn>2</mn><mrow><mn>2048</mn><mo>-</mo><mi>wavelen</mi></mrow></mfrac></math> MiHz.</p>
<div class="box warning">
<p class="box-title">DELAY</p><p>Wavelength changes (written to <code>NR33</code> or <code>NR34</code>) only take effect after the following time wave RAM is read.
(<a href="https://github.com/LIJI32/SameSuite/blob/master/apu/channel_3/channel_3_freq_change_delay.asm">Source</a>)</p>
</div>
<h3 id="ff1e--nr34-channel-3-wavelength-high--control"><a class="header" href="#ff1e--nr34-channel-3-wavelength-high--control">FF1E — NR34: Channel 3 wavelength high &amp; control</a></h3>
<pre><code>Bit 7   - Trigger (1=Restart Sound)    (Write Only)
Bit 6   - Sound Length enable          (Read/Write)
          (1=Stop output when length in NR31 expires)
Bit 2-0 - &quot;Wavelength&quot;'s higher 3 bits (Write Only)
</code></pre>
<p>Writing a value here with bit 7 set <a href="#triggering">triggers</a> the channel.</p>
<div class="box warning">
<p class="box-title">RETRIGGERING CAUTION</p><p>On monochrome consoles only, retriggering CH3 while it’s about to read a byte from wave RAM causes wave RAM to be corrupted in a generally unpredictable manner.</p>
</div>
<p>Bit 6 takes effect immediately upon writing to this register.</p>
<div class="box warning">
<p class="box-title">PLAYBACK DELAY</p><p>Triggering the wave channel does not immediately start playing wave RAM; instead, the <em>last</em> sample ever read (which is reset to 0 when the APU is off) is output until the channel next reads a sample.</p>
</div>
<h3 id="ff30ff3f--wave-pattern-ram"><a class="header" href="#ff30ff3f--wave-pattern-ram">FF30–FF3F — Wave pattern RAM</a></h3>
<p>Wave RAM is 16 bytes long; each byte holds two “samples”, each 4 bits.</p>
<p>As CH3 plays, it reads wave RAM left to right, upper nibble first.
That is, $FF30’s upper nibble, $FF30’s lower nibble, $FF31’s upper nibble, and so on.</p>
<div class="box warning">
<p class="box-title">ACCESS ORDER</p><p>When CH3 is started, the first sample read is the one at index <em>1</em>, i.e. the lower nibble of the first byte, NOT the upper nibble.
(<a href="https://github.com/LIJI32/SameSuite/blob/master/apu/channel_3/channel_3_first_sample.asm">Source</a>)</p>
</div>
<p>Accessing wave RAM while CH3 is <strong>active</strong> (i.e. playing) causes accesses to misbehave:</p>
<ul>
<li>On AGB, reads return $FF, and writes are ignored. (<a href="https://github.com/LIJI32/SameSuite/blob/master/apu/channel_3/channel_3_wave_ram_locked_write.asm">Source</a>)</li>
<li>On monochrome consoles, wave RAM can only be accessed on the same cycle that CH3 does.
Otherwise, reads return $FF, and writes are ignored.</li>
<li>On other consoles, the byte accessed will be the one CH3 is currently reading<sup class="footnote-reference"><a href="#wave_access">6</a></sup>; that is, if CH3 is currently reading one of the first two samples, the CPU will really access $FF30, regardless of the address being used. (<a href="https://github.com/LIJI32/SameSuite/blob/master/apu/channel_3/channel_3_wave_ram_locked_write.asm">Source</a>)</li>
</ul>
<p>Wave RAM <em>can</em> be accessed normally even if the DAC is on, as long as the channel is not active. (<a href="https://github.com/LIJI32/SameSuite/blob/master/apu/channel_3/channel_3_wave_ram_dac_on_rw.asm">Source</a>)
This is especially relevant on GBA, since <a href="#game-boy-advance-audio">“DACs” are always enabled there</a>.</p>
<div class="footnote-definition" id="wave_access"><sup class="footnote-definition-label">6</sup>
<p>The way it works is that wave RAM is a 16-byte memory buffer, and while it’s playing, CH3 has priority over the CPU when choosing which of those 16 bytes is accessed.
So, from the CPU’s point of view, wave RAM reads out the same byte, regardless of the address.</p>
</div>
<h2 id="sound-channel-4--noise"><a class="header" href="#sound-channel-4--noise">Sound Channel 4 — Noise</a></h2>
<p>This channel is used to output white noise<sup class="footnote-reference"><a href="#not_white">7</a></sup>, which is done by randomly switching the amplitude between two levels fairly fast.</p>
<p>The frequency can be adjusted in order to make the noise appear “harder” (lower frequency) or “softer” (higher frequency).</p>
<p>The random function that switches the output level can also be manipulated.
Certain settings can cause the wave to be more regular, sounding closer to a pulse than noise.</p>
<div class="footnote-definition" id="not_white"><sup class="footnote-definition-label">7</sup>
<p>By default, the noise will sound close to white; but it can be manipulated to sound differently.</p>
</div>
<h3 id="ff20--nr41-channel-4-length-timer-write-only"><a class="header" href="#ff20--nr41-channel-4-length-timer-write-only">FF20 — NR41: Channel 4 length timer [write-only]</a></h3>
<p>This register controls the channel’s <a href="#length-timer">length timer</a>.</p>
<pre><code>Bit 5-0 - length timer
</code></pre>
<p>The higher the <a href="#length-timer">length timer</a>, the shorter the time before the channel is cut.</p>
<h3 id="ff21--nr42-channel-4-volume--envelope"><a class="header" href="#ff21--nr42-channel-4-volume--envelope">FF21 — NR42: Channel 4 volume &amp; envelope</a></h3>
<p>This register controls the digital amplitude produced when the LFSR outputs a 1, and the sweep applied to that setting.</p>
<pre><code>Bit 7-4 - Initial volume of envelope (0-F) (0=No Sound)
Bit 3   - Envelope direction (0=Decrease, 1=Increase)
Bit 2-0 - Sweep pace (0=No Sweep)
</code></pre>
<p>Setting bits 3-7 of this register all to 0 turns the DAC off (and thus, the channel as well), which <a href="#mixer">may cause an audio pop</a>.</p>
<p>The envelope ticks at 64 Hz, and the channel’s envelope will be increased / decreased (depending on bit 3) every <var>Sweep pace</var> of those ticks.</p>
<h3 id="ff22--nr43-channel-4-frequency--randomness"><a class="header" href="#ff22--nr43-channel-4-frequency--randomness">FF22 — NR43: Channel 4 frequency &amp; randomness</a></h3>
<p>This register allows controlling the way the amplitude is randomly switched.</p>
<pre><code>Bit 7-4 - Clock shift (s)
Bit 3   - LFSR width (0=15 bits, 1=7 bits)
Bit 2-0 - Clock divider (r)
</code></pre>
<p>The frequency at which the LFSR is clocked is <math><mfrac><mn>262144</mn><mrow><mi>r</mi><mo>×</mo><msup><mn>2</mn><mi>s</mi></msup></mrow></mfrac></math> Hz.
(<var>r</var> = 0 is treated as <var>r</var> = 0.5 instead.)
If the bit shifted out is a 0, the channel emits a 0; otherwise, it emits the volume selected in <code>NR42</code>.</p>
<p>If the LFSR is set to 7-bit mode, the output will become more regular, and some frequencies will sound more like Pulse than Noise.
Note that switching from 15- to 7-bit mode when the LFSR <a href="#noise-channel-ch4">is in a certain state</a> can “lock it up”, which essentially silences CH4; this can be avoided by retriggering CH4, which resets the LFSR.</p>
<h3 id="ff23--nr44-channel-4-control"><a class="header" href="#ff23--nr44-channel-4-control">FF23 — NR44: Channel 4 control</a></h3>
<pre><code>Bit 7   - Trigger (1=Restart channel)  (Write Only)
Bit 6   - Sound Length enable          (Read/Write)
          (1=Stop output when length in NR41 expires)
</code></pre>
<p>Writing a value here with bit 7 set <a href="#triggering">triggers</a> the channel.</p>
<p>Bit 6 takes effect immediately upon writing to this register.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-details"><a class="header" href="#audio-details">Audio Details</a></h1>
<p>tl;dr:</p>
<blockquote>
<p>The PPU is a bunch of state machines, and the APU is a bunch of counters.</p>
</blockquote>
<!-- Styles in <svg> tags apply to the whole page, and we have two on this one. Hoist this to be less confusing. -->
<style>
  text {
    fill: var(--fg);
    dominant-baseline: middle;
    font-size: .6em;
  }
  #dsg { font-size: 1em; }
  .centered { text-anchor: middle; }
  .right    { text-anchor: end; }
  .tabnum { font-feature-settings: "tnum"; }
  svg > rect, svg > use {
    stroke: var(--fg);
    fill: var(--fg);
  }
  svg > path, svg > circle {
    stroke: var(--fg);
    fill: none;
  }
  .dashed { stroke-dasharray: 2; }
  .opa50 { opacity: .5; }
  .fill50 { fill-opacity: .5; }
  .digital   { stroke: #df0000; fill: #df0000; }
  .analog    { stroke: #005f98; fill: #005f98; }
  .misc_data { stroke: #a4269c; fill: #a4269c; }
  .dac_ena   { stroke: #ffa700; fill: #ffa700; }
  .ch_active { stroke: #17cc00; fill: #17cc00; }
  rect.legend { width: 5px; height: 5px; }
  text.legend { font-size: .7em; }
  .arrow { stroke-width: 2px; opacity: .35; }
  .unfilled {
    fill: none;
  }
  .no-stroke {
    stroke: none;
  }
</style>
<figure>
<svg viewBox="115 99 470 390" preserveAspectRatio="xMidYMid meet">
  <defs>
    <path d="M 0,-2
             v 4
             l 4,-2
             z" id="arrow-head"/>
  </defs>
  <rect x="570" y="110" class="legend digital"/>
  <text x="565" y="113" class="legend right">Digital waveform</text>
  <rect x="570" y="125" class="legend analog"/>
  <text x="565" y="128" class="legend right">Analog waveform</text>
  <rect x="570" y="140" class="legend misc_data"/>
  <text x="565" y="143" class="legend right">Misc. digital data</text>
  <rect x="570" y="155" class="legend dac_ena"/>
  <text x="565" y="158" class="legend right">DAC enable flag</text>
  <rect x="570" y="170" class="legend ch_active"/>
  <text x="565" y="173" class="legend right">Channel active flag</text>
  <rect x="150" y="100" width="230" height="275" class="unfilled opa50"/>
  <text x="265" y="118" id="dsg" class="centered">Digital Sound Generator</text>
  <rect x="160" y="140" width="150" height="20" class="unfilled"/>
  <text x="235" y="151" class="centered tabnum">Channel 1</text>
  <rect x="160" y="160" width="30" height="20" class="unfilled"/>
  <text x="175" y="172" class="centered tabnum">NR10</text>
  <rect x="190" y="160" width="30" height="20" class="unfilled"/>
  <text x="205" y="172" class="centered tabnum">NR11</text>
  <rect x="220" y="160" width="30" height="20" class="unfilled"/>
  <text x="235" y="172" class="centered tabnum">NR12</text>
  <rect x="250" y="160" width="30" height="20" class="unfilled"/>
  <text x="265" y="172" class="centered tabnum">NR13</text>
  <rect x="280" y="160" width="30" height="20" class="unfilled"/>
  <text x="295" y="172" class="centered tabnum">NR14</text>
  <rect x="160" y="190" width="150" height="20" class="unfilled"/>
  <text x="235" y="201" class="centered tabnum">Channel 2</text>
  <rect x="160" y="210" width="30" height="20" class="fill50"/>
  <rect x="190" y="210" width="30" height="20" class="unfilled"/>
  <text x="205" y="222" class="centered tabnum">NR21</text>
  <rect x="220" y="210" width="30" height="20" class="unfilled"/>
  <text x="235" y="222" class="centered tabnum">NR22</text>
  <rect x="250" y="210" width="30" height="20" class="unfilled"/>
  <text x="265" y="222" class="centered tabnum">NR23</text>
  <rect x="280" y="210" width="30" height="20" class="unfilled"/>
  <text x="295" y="222" class="centered tabnum">NR24</text>
  <rect x="160" y="240" width="150" height="20" class="unfilled"/>
  <text x="235" y="251" class="centered tabnum">Channel 3</text>
  <rect x="160" y="260" width="30" height="20" class="unfilled"/>
  <text x="175" y="272" class="centered tabnum">NR30</text>
  <rect x="190" y="260" width="30" height="20" class="unfilled"/>
  <text x="205" y="272" class="centered tabnum">NR31</text>
  <rect x="220" y="260" width="30" height="20" class="unfilled"/>
  <text x="235" y="272" class="centered tabnum">NR32</text>
  <rect x="250" y="260" width="30" height="20" class="unfilled"/>
  <text x="265" y="272" class="centered tabnum">NR33</text>
  <rect x="280" y="260" width="30" height="20" class="unfilled"/>
  <text x="295" y="272" class="centered tabnum">NR34</text>
  <rect x="160" y="290" width="150" height="20" class="unfilled"/>
  <text x="235" y="301" class="centered tabnum">Channel 4</text>
  <rect x="160" y="310" width="30" height="20" class="fill50"/>
  <rect x="190" y="310" width="30" height="20" class="unfilled"/>
  <text x="205" y="322" class="centered tabnum">NR41</text>
  <rect x="220" y="310" width="30" height="20" class="unfilled"/>
  <text x="235" y="322" class="centered tabnum">NR42</text>
  <rect x="250" y="310" width="30" height="20" class="unfilled"/>
  <text x="265" y="322" class="centered tabnum">NR43</text>
  <rect x="280" y="310" width="30" height="20" class="unfilled"/>
  <text x="295" y="322" class="centered tabnum">NR44</text>
  <rect x="340" y="148" width="30" height="20" class="unfilled"/>
  <text x="355" y="160" class="centered tabnum">NR50</text>
  <rect x="340" y="183" width="30" height="20" class="unfilled"/>
  <text x="355" y="195" class="centered tabnum">NR51</text>
  <rect x="340" y="218" width="30" height="20" class="unfilled"/>
  <text x="355" y="230" class="centered tabnum">NR52</text>
  <rect x="185" y="350" width="40" height="20" class="unfilled"/>
  <text x="205" y="362" class="centered tabnum">PCM12</text>
  <rect x="245" y="350" width="40" height="20" class="unfilled"/>
  <text x="265" y="362" class="centered tabnum">PCM34</text>
  <rect x="140" y="430" width="40" height="30" class="unfilled"/>
  <text x="160" y="446" class="centered tabnum">DAC 1</text>
  <rect x="190" y="430" width="40" height="30" class="unfilled"/>
  <text x="210" y="446" class="centered tabnum">DAC 2</text>
  <rect x="240" y="430" width="40" height="30" class="unfilled"/>
  <text x="260" y="446" class="centered tabnum">DAC 3</text>
  <rect x="290" y="430" width="40" height="30" class="unfilled"/>
  <text x="310" y="446" class="centered tabnum">DAC 4</text>
  <rect x="370" y="430" width="40" height="30" class="unfilled"/>
  <text x="390" y="446" class="centered tabnum">Mixer</text>
  <rect x="430" y="430" width="40" height="30" class="unfilled"/>
  <text x="450" y="446" class="centered tabnum">Volume</text>
  <rect x="490" y="420" width="30" height="20" class="unfilled"/>
  <text x="505" y="431" class="centered tabnum">HPF</text>
  <rect x="490" y="450" width="30" height="20" class="unfilled"/>
  <text x="505" y="461" class="centered tabnum">HPF</text>
  <rect x="540" y="430" width="40" height="30" class="unfilled"/>
  <text x="560" y="446" class="centered tabnum">Out</text>
  <!-- Keep in mind that later things are drawn over earlier ones. Order matters! -->
  <path d="M 235,180
           v 5
           h -115
           v 230
           h 30
           v 11" class="dac_ena unfilled"/>
  <use x="150" y="426" href="#arrow-head" class="dac_ena" transform="rotate(90,150,426)"/>
  <path d="M 235,230
           v 5
           h -100
           v 165
           h 65
           v 26" class="dac_ena unfilled"/>
  <use x="200" y="426" href="#arrow-head" class="dac_ena" transform="rotate(90,200,426)"/>
  <path d="M 175,280
           v 5
           h -20
           v 100
           h 95
           v 41" class="dac_ena unfilled"/>
  <use x="250" y="426" href="#arrow-head" class="dac_ena" transform="rotate(90,250,426)"/>
  <path d="M 235,330
           v 5
           h 65
           v 91" class="dac_ena unfilled"/>
  <use x="300" y="426" href="#arrow-head" class="dac_ena" transform="rotate(90,300,426)"/>
  <path d="M 160,150
           h -35
           v 32
           a 8 4 0 0 1 0,6
           v 222
           h 45
           v 16" class="digital unfilled"/>
  <use x="170" y="426" href="#arrow-head" class="digital" transform="rotate(90,170,426)"/>
  <path d="M 181,355
           h -23
           a 4 8 0 0 0 -6,0
           h -14
           a 4 8 0 0 0 -6,0
           h -7" class="digital unfilled"/>
  <use x="181" y="355" href="#arrow-head" class="digital"/>
  <path d="M 160,200
           h -20
           v 32
           a 8 4 0 0 1 0,6
           v 114
           a 8 4 0 0 1 0,6
           v 37
           h 80
           v 31" class="digital unfilled"/>
  <use x="220" y="426" href="#arrow-head" class="digital" transform="rotate(90,220,426)"/>
  <path d="M 181,365
           h -23
           a 4 8 0 0 0 -6,0
           h -12" class="digital unfilled"/>
  <use x="181" y="365" href="#arrow-head" class="digital"/>
  <path d="M 310,254
           h 25
           v 131
           h -12
           a 4 8 0 0 0 -6,0
           h -14
           a 4 8 0 0 0 -6,0
           h -27
           v 41" class="digital unfilled"/>
  <use x="270" y="426" href="#arrow-head" class="digital" transform="rotate(90,270,426)"/>
  <path d="M 289,355
           h 8
           a 4 8 0 0 1 6,0
           h 14
           a 4 8 0 0 1 6,0
           h 12" class="digital unfilled"/>
  <use x="289" y="355" href="#arrow-head" class="digital" transform="rotate(-180,289,355)"/>
  <path d="M 310,304
           h 10
           v 122" class="digital unfilled"/>
  <use x="320" y="426" href="#arrow-head" class="digital" transform="rotate(90,320,426)"/>
  <path d="M 289,365
           h 8
           a 4 8 0 0 1 6,0
           h 17" class="digital unfilled"/>
  <use x="289" y="365" href="#arrow-head" class="digital" transform="rotate(-180,289,365)"/>
  <path d="M 310,150
           h 18
           v 73
           h 8" class="ch_active unfilled"/>
  <use x="336" y="223" href="#arrow-head" class="ch_active"/>
  <path d="M 310,200
           h 8
           v 33
           h 18" class="ch_active unfilled"/>
  <use x="336" y="233" href="#arrow-head" class="ch_active"/>
  <path d="M 310,246
           h 40
           v -3" class="ch_active unfilled"/>
  <use x="350" y="243" href="#arrow-head" class="ch_active" transform="rotate(-90,350,243)"/>
  <path d="M 310,296
           h 22
           a 4 8 0 0 1 6,0
           h 22
           v -53" class="ch_active unfilled"/>
  <use x="360" y="243" href="#arrow-head" class="ch_active" transform="rotate(-90,360,243)"/>
  <path d="M 310,460
           v 10
           h 31
           v -37
           h 25" class="analog unfilled"/>
  <use x="366" y="433" href="#arrow-head" class="analog"/>
  <path d="M 260,460
           v 15
           h 86
           v -34
           h 20" class="analog unfilled"/>
  <use x="366" y="441" href="#arrow-head" class="analog"/>
  <path d="M 210,460
           v 20
           h 141
           v -31
           h 15" class="analog unfilled"/>
  <use x="366" y="449" href="#arrow-head" class="analog"/>
  <path d="M 160,460
           v 25
           h 196
           v -28
           h 10" class="analog unfilled"/>
  <use x="366" y="457" href="#arrow-head" class="analog"/>
  <path d="M 410,438
           h 16" class="analog unfilled"/>
  <use x="426" y="438" href="#arrow-head" class="analog"/>
  <path d="M 410,452
           h 16" class="analog unfilled"/>
  <use x="426" y="452" href="#arrow-head" class="analog"/>
  <path d="M 470,438
           h 8
           v -8
           h 8" class="analog unfilled"/>
  <use x="486" y="430" href="#arrow-head" class="analog"/>
  <path d="M 470,452
           h 8
           v 8
           h 8" class="analog unfilled"/>
  <use x="486" y="460" href="#arrow-head" class="analog"/>
  <path d="M 520,430
           h 8
           v 8
           h 8" class="analog unfilled"/>
  <use x="536" y="438" href="#arrow-head" class="analog"/>
  <path d="M 520,460
           h 8
           v -8
           h 8" class="analog unfilled"/>
  <use x="536" y="452" href="#arrow-head" class="analog"/>
  <path d="M 370,193
           h 20
           v 233" class="misc_data unfilled"/>
  <use x="390" y="426" href="#arrow-head" class="misc_data" transform="rotate(90,390,426)"/>
  <path d="M 370,158
           h 30
           v 248
           h 50
           v 20" class="misc_data unfilled"/>
  <use x="450" y="426" href="#arrow-head" class="misc_data" transform="rotate(90,450,426)"/>
</svg>
<figcaption>Source: Lior "LIJI32" Halphon</figcaption>
</figure>
<p>Each of the four “conceptual” channels is composed of a “generation” circuit (designated “channel” in the above diagram), and a <a href="https://en.wikipedia.org/wiki/Digital-to-analog_converter">DAC</a>.
The digital value produced by the generator, which ranges between $0 and $F (0 and 15), is linearly translated by the DAC into an analog<sup class="footnote-reference"><a href="#digital_analog">1</a></sup> value between -1 and 1 (the unit is arbitrary).</p>
<p>The four analog channel outputs are then fed into the mixer<sup class="footnote-reference"><a href="#vin">2</a></sup>, which selectively adds them (depending on <a href="#ff25--nr51-sound-panning"><code>NR51</code></a>) into two analog outputs (Left and Right).
Thus, the analog range of those outputs is 4× that of each channel, -4 to 4.</p>
<p>Then, both of these two get their respective volume scaled, once from <a href="#ff24--nr50-master-volume--vin-panning"><code>NR50</code></a>, and once from the volume knob (if the console has one).
Note that the former step never mutes a non-silent input, but the latter can.</p>
<p>Each of the two analog outputs then goes through a <a href="https://en.wikipedia.org/wiki/High-pass_filter">high-pass filter</a> (HPF).
For short, a HPF constantly tries to “pull” the signal towards analog 0 (neutral); the reason for that is explained further below.</p>
<div class="footnote-definition" id="digital_analog"><sup class="footnote-definition-label">1</sup>
<p>To be clear: digital values are discrete and clear-cut; conversely, the analog domain is continuous.
The former is what computers use, the latter is what the real world is made of.</p>
</div>
<div class="footnote-definition" id="vin"><sup class="footnote-definition-label">2</sup>
<p>Actually, VIN acts as a 5<sup>th</sup> channel fed into the mixer, whose control bits are in NR50 instead of NR51.
This was omitted from the diagram for simplicity.</p>
</div>
<h2 id="pcm-registers"><a class="header" href="#pcm-registers">PCM registers</a></h2>
<p>These two registers, only present in the Game Boy Color and later models, allow reading the output of the generation circuits directly; this is very useful for testing “internal” APU behavior.
These registers are not documented in any known Nintendo manual.</p>
<h3 id="ff76--pcm12-cgb-mode-only-digital-outputs-1--2-read-only"><a class="header" href="#ff76--pcm12-cgb-mode-only-digital-outputs-1--2-read-only">FF76 — PCM12 (CGB Mode only): Digital outputs 1 &amp; 2 [read-only]</a></h3>
<p>The low nibble is a copy of sound channel 1’s digital output, the high nibble a copy of sound channel 2’s.</p>
<h3 id="ff77--pcm34-cgb-mode-only-digital-outputs-3--4-read-only"><a class="header" href="#ff77--pcm34-cgb-mode-only-digital-outputs-3--4-read-only">FF77 — PCM34 (CGB Mode only): Digital outputs 3 &amp; 4 [read-only]</a></h3>
<p>Same, but with channels 3 and 4.</p>
<h2 id="finer-technical-explanation"><a class="header" href="#finer-technical-explanation">Finer technical explanation</a></h2>
<h3 id="div-apu"><a class="header" href="#div-apu">DIV-APU</a></h3>
<p>A “DIV-APU” counter is increased every time <code>DIV</code>’s bit 4 (5 in <a href="#ff4d--key1-cgb-mode-only-prepare-speed-switch">double-speed mode</a>) goes from 1 to 0, therefore at a frequency of 512 Hz (regardless of whether double-speed is active).
Thus, the counter can be made to increase faster by writing to <code>DIV</code> while its relevant bit is set (which clears <code>DIV</code>, and triggers the falling edge).</p>
<p>The following events occur every <var>N</var> DIV-APU ticks:</p>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Rate</th><th>Frequency<sup class="footnote-reference"><a href="#div_apu_freq">3</a></sup></th></tr></thead><tbody>
<tr><td>Envelope sweep</td><td>8</td><td>64 Hz</td></tr>
<tr><td>Sound length</td><td>2</td><td>256 Hz</td></tr>
<tr><td>CH1 freq sweep</td><td>4</td><td>128 Hz</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="div_apu_freq"><sup class="footnote-definition-label">3</sup>
<p>Indicated values are under normal operation; the frequencies will obviously differ if writing to <code>DIV</code> to increase the counter faster.</p>
</div>
<h3 id="mixer"><a class="header" href="#mixer">Mixer</a></h3>
<p>A high-pass filter (HPF) removes constant biases over time.
The HPFs therefore remove the DC offset created by inactive channels with an enabled DAC, and off-center waveforms.</p>
<div class="box tip">
<p class="box-title">Avoiding audio pops</p><p>Enabling or disabling a DAC (<a href="#dacs">see below</a>), adding or removing it using NR51, or changing the volume in NR50, will cause an audio pop.
(All of these actions cause a change in DC offset, which is smoothed out by the HPFs over time, but still creates a pop.)</p>
<p>To avoid this, a sound driver should avoid turning the DACs off; this can be done by writing $08 to <code>NRx2</code> (silences the channel but keeps the DAC on) then $80 to <code>NRx4</code> to retrigger the channel and reload <code>NRx2</code>.</p>
</div>
<p>The HPF is more aggressive on GBA than on GBC, which itself is more aggressive than on DMG.
(The more “aggressive” a HPF, the faster it pulls the signal towards “analog 0”; this tends to also distort waveforms.)</p>
<h3 id="dacs"><a class="header" href="#dacs">DACs</a></h3>
<p>Channel <var>x</var>’s DAC is enabled if and only if <code>[NRx2] &amp; $F8 != 0</code>; the exception is CH3, whose DAC is directly controlled by bit 7 of NR30 instead.
Note that the envelope functionality changes the volume, but not the value stored in NRx2, and thus doesn’t disable the DACs.</p>
<p>If a DAC is enabled, the digital range $0 to $F is linearly translated to the analog range -1 to 1, in arbitrary units.
Importantly, the slope is negative: “digital 0” maps to “analog 1”, not “analog -1”.</p>
<p>If a DAC is disabled, it fades to an analog value of 0.
The nature of this fade is not entirely deterministic and varies between models.</p>
<p>NR52’s low 4 bits report whether the channels are turned on, not their DACs.</p>
<h3 id="channels"><a class="header" href="#channels">Channels</a></h3>
<p>A channel is activated by a write to NRx4’s MSB, unless its DAC is off, which forces it to be disabled as well.
The opposite is not true, however: a disabled channel outputs 0, which an enabled DAC will dutifully convert into “analog 1”.</p>
<p>A channel can be deactivated in one of the following ways:</p>
<ul>
<li>Turning off its DAC</li>
<li>Its <a href="#length-timer">length timer</a> expiring</li>
<li>(CH1 only) <a href="#ff10--nr10-channel-1-sweep">Frequency sweep</a> overflowing the frequency</li>
</ul>
<h3 id="pulse-channels-ch1-ch2"><a class="header" href="#pulse-channels-ch1-ch2">Pulse channels (CH1, CH2)</a></h3>
<p>Each pulse channel has an internal “duty step” counter, which is used to index into <a href="#ff11--nr11-channel-1-length-timer--duty-cycle">the selected waveform</a> (each background stripe corresponds to one “duty step”)<sup class="footnote-reference"><a href="#pulse_lut">4</a></sup>.
The “duty step” increments at 8 times <a href="#ff13--nr13-channel-1-wavelength-low-write-only">the channel’s frequency</a>).</p>
<p>The “duty step” counter cannot be reset, except by turning the APU off, which sets both back to 0.
Retriggering a pulse channel causes its “duty step timer” to reset, thus retriggering a pulse channel often enough will cause its “duty step” to never advance.</p>
<p>When first starting up a pulse channel, it will <em>always</em> output a (digital) zero.</p>
<div class="footnote-definition" id="pulse_lut"><sup class="footnote-definition-label">4</sup>
<p>Actually, there is not LUT, but the manipulations done to the counter’s bits are equivalent.</p>
</div>
<h3 id="wave-channel-ch3"><a class="header" href="#wave-channel-ch3">Wave channel (CH3)</a></h3>
<p>CH3 has an internal “sample index” counter.
Each time it is ticked (as determined by the “wavelength” in NR33/NR34), that “sample index” is incremented, and then the corresponding “sample” (nibble) is read from wave RAM.
(This means that sample #0 is skipped when first starting up CH3.)</p>
<p>CH3 does not emit samples directly, but stores every sample read into a buffer, and emits that continuously; (re)triggering the channel does <em>not</em> clear nor refresh this buffer, so the last sample ever read will be emitted again.
This buffer <em>is</em> cleared when turning the APU on, so CH3 will emit a “digital 0” when first powered on.</p>
<p>CH3 output level control does not, in fact, alter the output level.
It shifts the <strong>digital</strong> value CH3 is outputting, not the analog value.
This only matters when changing the setting mid-playback: the digital values being shifted bias them towards 0, which biases the analog output towards “1”; the HPF will smooth this over time, but not instantly.</p>
<h3 id="noise-channel-ch4"><a class="header" href="#noise-channel-ch4">Noise channel (CH4)</a></h3>
<svg viewBox="0 0 322 60" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <path d="M 0,-5
             v 10
             l 10,-5
             z" id="arrow-head"/>
  </defs>
  <rect x="1" y="10" width="20" height="20" class="unfilled"/> <text x="11" y="5" class="centered">15</text>
  <rect x="21" y="10" width="20" height="20" class="unfilled"/> <text x="31" y="5" class="centered">14</text>
  <rect x="41" y="10" width="20" height="20" class="unfilled"/> <text x="51" y="5" class="centered">13</text>
  <rect x="61" y="10" width="20" height="20" class="unfilled"/> <text x="71" y="5" class="centered">12</text>
  <rect x="81" y="10" width="20" height="20" class="unfilled"/> <text x="91" y="5" class="centered">11</text>
  <rect x="101" y="10" width="20" height="20" class="unfilled"/> <text x="111" y="5" class="centered">10</text>
  <rect x="121" y="10" width="20" height="20" class="unfilled"/> <text x="131" y="5" class="centered">9</text>
  <rect x="141" y="10" width="20" height="20" class="unfilled"/> <text x="151" y="5" class="centered">8</text>
  <rect x="161" y="10" width="20" height="20" class="unfilled"/> <text x="171" y="5" class="centered">7</text>
  <rect x="181" y="10" width="20" height="20" class="unfilled"/> <text x="191" y="5" class="centered">6</text>
  <rect x="201" y="10" width="20" height="20" class="unfilled"/> <text x="211" y="5" class="centered">5</text>
  <rect x="221" y="10" width="20" height="20" class="unfilled"/> <text x="231" y="5" class="centered">4</text>
  <rect x="241" y="10" width="20" height="20" class="unfilled"/> <text x="251" y="5" class="centered">3</text>
  <rect x="261" y="10" width="20" height="20" class="unfilled"/> <text x="271" y="5" class="centered">2</text>
  <rect x="281" y="10" width="20" height="20" class="unfilled"/> <text x="291" y="5" class="centered">1</text>
  <rect x="301" y="10" width="20" height="20" class="unfilled"/> <text x="311" y="5" class="centered">0</text>
  <path d="M 311,30
           v 21
           h -30"/>
  <path d="M 291,30
           v 15
           h -10"/>
  <path d="M 267,38
           c 0,0 -10,0 -17,10  7,10 17,10 17,10
           h 13
           c -5,-5 -5,-15 0,-20
           z
           m 17,20
           c -5,-5 -5,-15 0,-20"/>
  <circle cx="248" cy="48" r="2"/>
  <path d="M 246,48
           h -235
           v -13"/> <use x="11" y="35" href="#arrow-head" transform="rotate(-90,11,35)"/>
  <path d="M 171,48
           v -13" class="dashed"/> <use x="171" y="35" href="#arrow-head" transform="rotate(-90,171,35)"/>
</svg>
<p>CH4 revolves around a <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>, pictured above.
The LFSR is 16-bit internally, but really acts as if it was 15-bit.</p>
<p>When CH4 is ticked (at the frequency specified via <a href="#ff22--nr43-channel-4-frequency--randomness"><code>NR43</code></a>):</p>
<ol>
<li>The result of <math><menclose notation="top"><msub><mi>LFSR</mi><mn>0</mn></msub> <mo>⊕</mo> <msub><mi>LFSR</mi><mn>1</mn></msub></menclose></math> (<code>1</code> if bit 0 and bit 1 are identical, <code>0</code> otherwise) is written to bit 15.</li>
<li>If “short mode” was selected in <a href="#ff22--nr43-channel-4-frequency--randomness"><code>NR43</code></a>, then bit 15 is copied to bit 7 as well.</li>
<li>Finally, the entire LFSR is shifted right, and bit 0 selects between 0 and <a href="#ff21--nr42-channel-4-volume--envelope">the chosen volume</a>.</li>
</ol>
<p>The LFSR is set to 0 when (re)triggering the channel.</p>
<div class="box tip">
<p class="box-title">Lock-up</p><p>If the “active” portion of the LFSR only contains “1” bits, only “1” bits will be generated; this prevents CH4 from ever changing values (until retriggered), essentially silencing it.</p>
<p>This does not happen under regular operation, but can be achieved by switching from 15-bit to 7-bit mode when the LFSR’s bottom 7 bits are all “1“s (which occurs relatively early after triggering the channel, for example).</p>
</div>
<h2 id="game-boy-advance-audio"><a class="header" href="#game-boy-advance-audio">Game Boy Advance audio</a></h2>
<p>The APU was reworked pretty heavily for the GBA, which introduces some slightly different behavior:</p>
<ul>
<li>Instead of mixing being done by analog circuitry, it’s instead done digitally; then, sound is converted to an analog signal and an offset is added (see <code>SOUNDBIAS</code> in <a href="http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters">GBATEK</a> for more details).</li>
<li>This also means that the GBA APU has no DACs.
Instead, they are emulated digitally such that a disabled “DAC” behaves like an enabled DAC receiving 0 as its input.</li>
<li>Additionally, CH3’s DAC has its output inverted.
In particular, this causes the channel to emit a loud spike when disabled; therefore, it’s a good idea to “disconnect” the channel using NR51 before accessing wave RAM.</li>
</ul>
<p>None of the additional features (more wave RAM, digital FIFOs, etc.) are available to CGB programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="joypad-input"><a class="header" href="#joypad-input">Joypad Input</a></h1>
<h2 id="ff00--p1joyp-joypad"><a class="header" href="#ff00--p1joyp-joypad">FF00 — P1/JOYP: Joypad</a></h2>
<p>The eight Game Boy action/direction buttons are arranged as a 2x4
matrix. Select either action or direction buttons by writing to this
register, then read out the bits 0-3.</p>
<pre><code>Bit 7 - Not used
Bit 6 - Not used
Bit 5 - P15 Select Action buttons    (0=Select)
Bit 4 - P14 Select Direction buttons (0=Select)
Bit 3 - P13 Input: Down  or Start    (0=Pressed) (Read Only)
Bit 2 - P12 Input: Up    or Select   (0=Pressed) (Read Only)
Bit 1 - P11 Input: Left  or B        (0=Pressed) (Read Only)
Bit 0 - P10 Input: Right or A        (0=Pressed) (Read Only)
</code></pre>
<div class="box tip">
<p class="box-title">NOTE</p><p>Most programs read from this port several times in a row
(the first reads are used as a short delay, allowing the inputs to stabilize,
and only the value from the last read is actually used).</p>
</div>
<h2 id="usage-in-sgb-software"><a class="header" href="#usage-in-sgb-software">Usage in SGB software</a></h2>
<p>Beside for normal joypad input, SGB games misuse the joypad register to
output SGB command packets to the SNES, also, SGB programs may read out
gamepad states from up to four different joypads which can be connected
to the SNES. See SGB description for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serial-data-transfer-link-cable"><a class="header" href="#serial-data-transfer-link-cable">Serial Data Transfer (Link Cable)</a></h1>
<p>Communication between two Game Boy systems happens one byte at a time. One
Game Boy generates a clock signal internally and thus controls when the
exchange happens. In SPI terms, the Game Boy generating the clock is
called the “master.”  The other one uses an external clock (receiving
it from the other Game Boy) and has no control over when the
transfer happens. If it hasn’t gotten around to loading up the next
data byte at the time the transfer begins, the last one will go out
again. Alternately, if it’s ready to send the next byte but the last
one hasn’t gone out yet, it has no choice but to wait.</p>
<h2 id="ff01--sb-serial-transfer-data"><a class="header" href="#ff01--sb-serial-transfer-data">FF01 — SB: Serial transfer data</a></h2>
<p>Before a transfer, it holds the next byte that will go out.</p>
<p>During a transfer, it has a blend of the outgoing and incoming bytes.
Each cycle, the leftmost bit is shifted out (and over the wire) and the
incoming bit is shifted in from the other side:</p>
<pre><code>o7 o6 o5 o4 o3 o2 o1 o0
o6 o5 o4 o3 o2 o1 o0 i7
o5 o4 o3 o2 o1 o0 i7 i6
o4 o3 o2 o1 o0 i7 i6 i5
o3 o2 o1 o0 i7 i6 i5 i4
o2 o1 o0 i7 i6 i5 i4 i3
o1 o0 i7 i6 i5 i4 i3 i2
o0 i7 i6 i5 i4 i3 i2 i1
i7 i6 i5 i4 i3 i2 i1 i0
</code></pre>
<h2 id="ff02--sc-serial-transfer-control"><a class="header" href="#ff02--sc-serial-transfer-control">FF02 — SC: Serial transfer control</a></h2>
<pre><code>Bit 7 - Transfer Start Flag (0=No transfer is in progress or requested, 1=Transfer in progress, or requested)
Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)
</code></pre>
<p>The master Game Boy will load up a data byte in SB and then set
SC to 0x81 (Transfer requested, use internal clock). It will be notified
that the transfer is complete in two ways: SC’s Bit 7 will be cleared
(that is, SC will be set up 0x01), and also the <a href="#int-58--serial-interrupt">Serial Interrupt handler</a>
will be called (that is, the CPU will jump to 0x0058).</p>
<p>The other Game Boy will load up a data byte and can optionally set SC’s
Bit 7 (that is, SC=0x80). Regardless of whether or not it has done this, if
and when the master wants to conduct a transfer, it will happen
(pulling whatever happens to be in SB at that time). The externally clocked
Game Boy will have its <a href="#int-58--serial-interrupt">serial interrupt handler</a> called at the end of the
transfer, and if it bothered to set SC’s Bit 7, it will be cleared.</p>
<h3 id="internal-clock"><a class="header" href="#internal-clock">Internal Clock</a></h3>
<p>In Non-CGB Mode the Game Boy supplies an internal clock of 8192Hz only
(allowing to transfer about 1 KByte per second minus overhead for delays).
In CGB Mode four internal clock rates are available, depending on Bit 1
of the SC register, and on whether the CGB Double Speed Mode is used:</p>
<div class="table-wrapper"><table><thead><tr><th>Clock freq</th><th>Transfer speed</th><th>Conditions</th></tr></thead><tbody>
<tr><td>8192Hz</td><td>1KB/s</td><td>Bit 1 cleared, Normal speed</td></tr>
<tr><td>16384Hz</td><td>2KB/s</td><td>Bit 1 cleared, Double-speed Mode</td></tr>
<tr><td>262144Hz</td><td>32KB/s</td><td>Bit 1 set,     Normal speed</td></tr>
<tr><td>524288Hz</td><td>64KB/s</td><td>Bit 1 set,     Double-speed Mode</td></tr>
</tbody></table>
</div>
<h3 id="external-clock"><a class="header" href="#external-clock">External Clock</a></h3>
<p>The external clock is typically supplied by another Game Boy, but might
be supplied by another computer (for example if connected to a PC’s
parallel port), in that case the external clock may have any speed. Even
the old/monochrome Game Boy is reported to recognize external clocks of
up to 500 kHz. And there is no limitation in the other direction: even
when suppling an external clock speed of “1 bit per month,” the Game Boy
will eagerly wait for the next bit to be transferred. It isn’t required
that the clock pulses are sent at a regular interval either.</p>
<h2 id="timeouts"><a class="header" href="#timeouts">Timeouts</a></h2>
<p>When using external clock then the transfer will not complete until the
last bit is received. In case that the second Game Boy isn’t supplying a
clock signal, if it gets turned off, or if there is no second Game Boy
connected at all) then transfer will never complete. For this reason the
transfer procedure should use a timeout counter, and abort the
communication if no response has been received during the timeout
interval.</p>
<h2 id="disconnects"><a class="header" href="#disconnects">Disconnects</a></h2>
<p>On a disconnected link cable, the input bit on a master will start to read 1.
This means a master will start to receive $FF bytes.</p>
<p>If a disconnection happens during transmission, the input will be pulled up to 1 over a 20uSec period. (TODO: Only measured on a CGB rev E)
This means if the slave was sending a 0 bit at the time of the disconnect, you will read 0 bits for up to 20 μs.
Which on a CGB at the highest speed can be more then a byte.</p>
<h2 id="delays-and-synchronization"><a class="header" href="#delays-and-synchronization">Delays and Synchronization</a></h2>
<p>The master Game Boy should always execute a small
delay after each transfer, in order to ensure that the other
Game Boy has enough time to prepare itself for the next transfer. That is, the
Game Boy with external clock must have set its transfer start bit before
the Game Boy with internal clock starts the transfer. Alternately, the
two Game Boy systems could switch between internal and external clock for each
transferred byte to ensure synchronization.</p>
<p>Transfer is initiated when the master Game Boy sets its Transfer
Start Flag, regardless of the value of this flag on the other device.
This bit is automatically set to 0 (on both) at the end of transfer.
Reading this bit can be used to determine if the transfer is still
active.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timer-and-divider-registers"><a class="header" href="#timer-and-divider-registers">Timer and Divider Registers</a></h1>
<div class="box tip">
<p class="box-title">NOTE</p><p>The Timer described below is the built-in timer in the gameboy. It has
nothing to do with the MBC3s battery buffered Real Time Clock - that’s
a completely different thing, described in
<a href="#mbcs">Memory Bank Controllers</a>.</p>
</div>
<h2 id="ff04--div-divider-register"><a class="header" href="#ff04--div-divider-register">FF04 — DIV: Divider register</a></h2>
<p>This register is incremented at a rate of 16384Hz (~16779Hz on SGB).
Writing any value to this register resets it to $00.
Additionally, this register is reset when executing the <code>stop</code> instruction, and
only begins ticking again once <code>stop</code> mode ends. This also occurs during a
<a href="#ff4d--key1-cgb-mode-only-prepare-speed-switch">speed switch</a>.
(TODO: how is it affected by the wait after a speed switch?)</p>
<p>Note: The divider is affected by CGB double speed mode, and will
increment at 32768Hz in double speed.</p>
<h2 id="ff05--tima-timer-counter"><a class="header" href="#ff05--tima-timer-counter">FF05 — TIMA: Timer counter</a></h2>
<p>This timer is incremented at the clock frequency specified by the TAC
register ($FF07). When the value overflows (exceeds $FF)
it is reset to the value specified in TMA (FF06) and <a href="#int-50--timer-interrupt">an interrupt</a>
is requested, as described below.</p>
<h2 id="ff06--tma-timer-modulo"><a class="header" href="#ff06--tma-timer-modulo">FF06 — TMA: Timer modulo</a></h2>
<p>When TIMA overflows, it is reset to the value in this register and <a href="#int-50--timer-interrupt">an interrupt</a> is requested.
Example of use: if TMA is set to $FF, an interrupt is requested at the clock frequency selected in
TAC (because every increment is an overflow). However, if TMA is set to $FE, an interrupt is
only requested every two increments, which effectively divides the selected clock by two. Setting
TMA to $FD would divide the clock by three, and so on.</p>
<p>If a TMA write is executed on the same cycle as the content of TMA is transferred to TIMA
due to a timer overflow, the old value is transferred to TIMA.</p>
<h2 id="ff07--tac-timer-control"><a class="header" href="#ff07--tac-timer-control">FF07 — TAC: Timer control</a></h2>
<pre><code>Bit  2   - Timer Enable
Bits 1-0 - Input Clock Select
           00: CPU Clock / 1024 (DMG, SGB2, CGB Single Speed Mode:   4096 Hz, SGB1:   ~4194 Hz, CGB Double Speed Mode:   8192 Hz)
           01: CPU Clock / 16   (DMG, SGB2, CGB Single Speed Mode: 262144 Hz, SGB1: ~268400 Hz, CGB Double Speed Mode: 524288 Hz)
           10: CPU Clock / 64   (DMG, SGB2, CGB Single Speed Mode:  65536 Hz, SGB1:  ~67110 Hz, CGB Double Speed Mode: 131072 Hz)
           11: CPU Clock / 256  (DMG, SGB2, CGB Single Speed Mode:  16384 Hz, SGB1:  ~16780 Hz, CGB Double Speed Mode:  32768 Hz)
</code></pre>
<div class="box tip">
<p class="box-title">NOTE</p><p>The “Timer Enable” bit only affects the timer (TIMA). The divider (DIV) is <strong>always</strong> counting.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timer-obscure-behaviour"><a class="header" href="#timer-obscure-behaviour">Timer obscure behaviour</a></h1>
<h2 id="timer-global-circuit"><a class="header" href="#timer-global-circuit">Timer Global Circuit</a></h2>
<p><img src="imgs/timer_simplified.svg" alt="" title="imgs/timer_simplified.svg" /></p>
<h2 id="relation-between-timer-and-divider-register"><a class="header" href="#relation-between-timer-and-divider-register">Relation between Timer and Divider register</a></h2>
<p>This is a schematic of the circuit involving TAC and DIV:</p>
<p><img src="imgs/timer_tac_bug_dmg.svg" alt="" title="imgs/timer_tac_bug_dmg.svg" /></p>
<p>Notice how the values that are connected to the inputs of the
multiplexer are the values of those bits, not the carry of those bits.
This is the reason of a few things:</p>
<ul>
<li>
<p>When writing to DIV, the whole counter is reset, so the timer is
also affected.</p>
</li>
<li>
<p>When writing to DIV, if the current output is 1 and timer is
enabled, as the new value after reseting DIV will be 0, the falling
edge detector will detect a falling edge and TIMA will increase.</p>
</li>
<li>
<p>When writing to TAC, if the previously selected multiplexer input was
1 and the new input is 0, TIMA will increase too. This doesnt
happen when the timer is disabled, but it also happens when disabling
the timer (the same effect as writing to DIV). The following code explains the behaviour in DMG and MGB.</p>
</li>
</ul>
<pre><code>    clocks_array[4] = {1024, 16, 64, 256}

    old_clocks = clocks_array[old_TAC&amp;3]
    new_clocks = clocks_array[new_TAC&amp;3]

    old_enable = old_TAC &amp; BIT(2)
    new_enable = new_TAC &amp; BIT(2)

    sys_clocks = 16 bit system counter

    IF old_enable == 0 THEN
        glitch = 0 (*)
    ELSE
        IF new_enable == 0 THEN
            glitch = (sys_clocks &amp; (old_clocks/2)) != 0
        ELSE
            glitch = ((sys_clocks &amp; (old_clocks/2)) != 0) &amp;&amp; ((sys_clocks &amp; (new_clocks/2)) == 0)
        END IF
    END IF
</code></pre>
<p>The sentence marked with a (*) has a different behaviour in GBC (AGB
and AGS seem to have strange behaviour even in the other statements).
When enabling the timer and maintaining the same frequency it doesnt
glitch. When disabling the timer it doesnt glitch either. When another
change of value happens (so timer is enabled after the write), the
behaviour depends on a race condition, so it cannot be predicted for
every device.</p>
<h2 id="timer-overflow-behaviour"><a class="header" href="#timer-overflow-behaviour">Timer Overflow Behaviour</a></h2>
<p>When TIMA overflows, the value from TMA is loaded and IF timer flag is
set to 1, but this doesnt happen immediately. Timer interrupt is
delayed 1 cycle (4 clocks) from the TIMA overflow. The TMA reload to
TIMA is also delayed. For one cycle, after overflowing TIMA, the value
in TIMA is 00h, not TMA. This happens only when an overflow happens, not
when the upper bit goes from 1 to 0, it cant be done manually writing
to TIMA, the timer has to increment itself.</p>
<p>For example (SYS is the system internal counter divided by 4 for easier
understanding, each increment of the graph is 1 cycle, not 1 clock):</p>
<pre><code>Timer overflows:

              [A] [B]
SYS  FD FE FF |00| 01 02 03
TIMA FF FF FF |00| 23 23 23
TMA  23 23 23 |23| 23 23 23
IF   E0 E0 E0 |E0| E4 E4 E4

Timer doesn't overflow:

              [C]
SYS  FD FE FF 00 01 02 03
TIMA 45 45 45 46 46 46 46
TMA  23 23 23 23 23 23 23
IF   E0 E0 E0 E0 E0 E0 E0
</code></pre>
<ul>
<li>
<p>During the strange cycle [A] you can prevent the IF flag from being
set and prevent the TIMA from being reloaded from TMA by writing a value
to TIMA. That new value will be the one that stays in the TIMA register
after the instruction. Writing to DIV, TAC or other registers wont
prevent the IF flag from being set or TIMA from being reloaded.</p>
</li>
<li>
<p>If you write to TIMA during the cycle that TMA is being loaded to it
[B], the write will be ignored and TMA value will be written to TIMA
instead.</p>
</li>
<li>
<p>If TMA is written the same cycle it is loaded to TIMA [B], TIMA is
also loaded with that value.</p>
</li>
<li>
<p>This is a guessed schematic to explain the priorities with registers
TIMA and TMA:</p>
</li>
</ul>
<p><img src="imgs/timer_tima_tma_detailed.svg" alt="" title="imgs/timer_tima_tma_detailed.svg" /></p>
<p>TMA is a latch. As soon as it is written, the output shows that value.
That explains that when TMA is written and TIMA is being incremented,
the value written to TMA is also written to TIMA. It doesnt affect the
IF flag, though.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h1>
<h2 id="ime-interrupt-master-enable-flag-write-only"><a class="header" href="#ime-interrupt-master-enable-flag-write-only">IME: Interrupt master enable flag [write only]</a></h2>
<pre><code>0 - Disable all interrupts
1 - Enable all interrupts that are enabled in the IE register (FFFF)
</code></pre>
<p>The IME flag is used to disable all interrupts, overriding any enabled
bits in the IE register. It isn’t possible to access the IME flag by
using an I/O address. IME can be modified by
the following instructions/events only:</p>
<pre><code>EI     ; Enables interrupts  (that is, IME=1)
DI     ; Disables interrupts (that is, IME=0)
RETI   ; Enables interrupts and returns (same as the instruction sequence EI, RET)
&lt;ISR&gt;  ; Disables interrupts and calls the interrupt handler
</code></pre>
<p>Where &lt;ISR&gt; is the Interrupt Service Routine that is automatically executed
by the CPU when it services an interrupt request.</p>
<p>The effect of <code>ei</code> is delayed by one instruction. This means that <code>ei</code>
followed immediately by <code>di</code> does not allow any interrupts between them.
This interacts with the <a href="#halt-bug"><code>halt</code> bug</a> in an interesting way.</p>
<h2 id="ffff--ie-interrupt-enable"><a class="header" href="#ffff--ie-interrupt-enable">FFFF — IE: Interrupt enable</a></h2>
<pre><code>Bit 0: VBlank   Interrupt Enable  (INT $40)  (1=Enable)
Bit 1: LCD STAT Interrupt Enable  (INT $48)  (1=Enable)
Bit 2: Timer    Interrupt Enable  (INT $50)  (1=Enable)
Bit 3: Serial   Interrupt Enable  (INT $58)  (1=Enable)
Bit 4: Joypad   Interrupt Enable  (INT $60)  (1=Enable)
</code></pre>
<h2 id="ff0f--if-interrupt-flag"><a class="header" href="#ff0f--if-interrupt-flag">FF0F — IF: Interrupt flag</a></h2>
<pre><code>Bit 0: VBlank   Interrupt Request (INT $40)  (1=Request)
Bit 1: LCD STAT Interrupt Request (INT $48)  (1=Request)
Bit 2: Timer    Interrupt Request (INT $50)  (1=Request)
Bit 3: Serial   Interrupt Request (INT $58)  (1=Request)
Bit 4: Joypad   Interrupt Request (INT $60)  (1=Request)
</code></pre>
<p>When an interrupt request signal changes from low to high, the
corresponding bit in the IF register is set. For example, Bit 0
becomes set when the LCD controller enters the VBlank period.</p>
<p>Any set bits in the IF register are only <strong>requesting</strong> an interrupt.
The actual <strong>execution</strong> of the interrupt handler happens only if both the IME flag and
the corresponding bit in the IE register are set; otherwise the
interrupt “waits” until both IME and IE allow it to be serviced.</p>
<p>Since the CPU automatically sets and clears the bits in the IF register, it
is usually not necessary to write to the IF register. However, the user
may still do that in order to manually request (or discard) interrupts.
Just like real interrupts, a manually requested interrupt isn’t serviced
unless/until IME and IE allow it.</p>
<h2 id="interrupt-handling"><a class="header" href="#interrupt-handling">Interrupt Handling</a></h2>
<ol>
<li>The IF bit corresponding to this interrupt and the IME flag are reset by the CPU.
The former “acknowledges” the interrupt, while the latter prevents any further interrupts
from being handled until the program re-enables them, typically by using the <code>reti</code> instruction.</li>
<li>The corresponding interrupt handler (see the IE and IF register descriptions <a href="#ffff--ie-interrupt-enable">above</a>) is
called by the CPU. This is a regular call, exactly like what would be performed by a <code>call &lt;address&gt;</code> instruction (the current PC is pushed onto the stack
and then set to the address of the interrupt handler).</li>
</ol>
<p>The following interrupt service routine is executed when control is being transferred to an interrupt handler:</p>
<ol>
<li>Two wait states are executed (2 M-cycles pass while nothing happens; presumably the CPU is executing <code>nop</code>s during this time).</li>
<li>The current value of the PC register is pushed onto the stack, consuming 2 more M-cycles.</li>
<li>The PC register is set to the address of the handler (one of: $40, $48, $50, $58, $60).
This consumes one last M-cycle.</li>
</ol>
<p>The entire routine <strong>should</strong> last a total of 5 M-cycles.
This has yet to be tested, but is what the Z80 datasheet implies.</p>
<h2 id="interrupt-priorities"><a class="header" href="#interrupt-priorities">Interrupt Priorities</a></h2>
<p>In the following circumstances it is possible that more than one bit in the IF register is set, requesting more than one interrupt at once:</p>
<ol>
<li>More than one interrupt request signal changed from low to high at the same time.</li>
<li>Several interrupts have been requested while IME/IE didn’t allow them to be serviced.</li>
<li>The user has written a value with several bits set (for example binary 00011111) to the IF register.</li>
</ol>
<p>If IME and IE allow the servicing of more than one of the
requested interrupts, the interrupt with the highest priority
is serviced first. The priorities follow the order of the bits in the IE
and IF registers: Bit 0 (VBlank) has the highest priority, and Bit 4
(Joypad) has the lowest priority.</p>
<h2 id="nested-interrupts"><a class="header" href="#nested-interrupts">Nested Interrupts</a></h2>
<p>The CPU automatically disables all the other interrupts by setting IME=0
when it services an interrupt. Usually IME remains zero until the
interrupt handler returns (and sets IME=1 by means of the <code>reti</code> instruction).
However, if you want to allow the servicing of other interrupts (of any priority)
during the execution of an interrupt handler, you may do so by using the
<code>ei</code> instruction in the handler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupt-sources"><a class="header" href="#interrupt-sources">Interrupt Sources</a></h1>
<h2 id="int-40--vblank-interrupt"><a class="header" href="#int-40--vblank-interrupt">INT $40 — VBlank interrupt</a></h2>
<p>This interrupt is requested every time the Game Boy enters VBlank (<a href="#ff41--stat-lcd-status">Mode 1</a>).</p>
<p>The VBlank interrupt occurs ca. 59.7 times a second on a handheld Game
Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a
Super Game Boy (SGB). This interrupt occurs at the beginning of the
VBlank period (LY=144). During this period video hardware is not using
VRAM so it may be freely accessed. This period lasts approximately 1.1
milliseconds.</p>
<h2 id="int-48--stat-interrupt"><a class="header" href="#int-48--stat-interrupt">INT $48 — STAT interrupt</a></h2>
<p>There are various sources which can trigger this interrupt to occur as
described in <a href="#ff41--stat-lcd-status">STAT register ($FF41)</a>.</p>
<p>The various STAT interrupt sources (modes 0-2 and LYC=LY) have their 
state (inactive=low and active=high) logically ORed into a shared
“STAT interrupt line” if their respective enable bit is turned on.</p>
<p>A STAT interrupt will be triggered by a rising edge (transition from 
low to high) on the STAT interrupt line.</p>
<div class="box warning">
<p class="box-title">STAT blocking</p><p>If a STAT interrupt source logically ORs the interrupt line high while 
(or immediately after) it’s already set high by another source, then 
there will be no low-to-high transition and so no interrupt will occur. 
This phenomenon is known as “STAT blocking” (<a href="https://github.com/Gekkio/mooneye-gb/blob/2d52008228557f9e713545e702d5b7aa233d09bb/tests/acceptance/ppu/stat_irq_blocking.s#L21-L22">test ROM example</a>).</p>
<p>As mentioned in the description of the <a href="#ff41--stat-lcd-status">STAT register</a>,
the PPU cycles through the different modes in a fixed order. So for 
example, if interrupts are enabled for two consecutive modes such as 
Mode 0 and Mode 1, then no interrupt will trigger for Mode 1 (since 
the STAT interrupt line won’t have a chance to go low between them).</p>
</div>
<h3 id="using-the-stat-interrupt"><a class="header" href="#using-the-stat-interrupt">Using the STAT interrupt</a></h3>
<p>One very popular use is to indicate to the user when the video
hardware is about to redraw a given LCD line. This can be useful for
dynamically controlling the SCX/SCY registers ($FF43/$FF42) to <a href="https://github.com/gb-archive/DeadCScroll">perform
special video effects</a>.</p>
<p>Example application: set LYC to WY, enable LY=LYC interrupt, and have
the handler disable sprites. This can be used if you use the window for
a text box (at the bottom of the screen), and you want sprites to be
hidden by the text box.</p>
<h2 id="int-50--timer-interrupt"><a class="header" href="#int-50--timer-interrupt">INT $50 — Timer interrupt</a></h2>
<p>Every time that the timer overflows (that is, when <a href="#ff05--tima-timer-counter">TIMA</a> exceeds $FF),
an interrupt is requested by setting bit 2 in the IF register
($FF0F). As soon as that interrupt is enabled, the CPU will execute it by
calling the timer interrupt vector at $0050.</p>
<h2 id="int-58--serial-interrupt"><a class="header" href="#int-58--serial-interrupt">INT $58 — Serial interrupt</a></h2>
<p><strong>XXXXXX…</strong></p>
<p>Transmitting and receiving serial data is done simultaneously. The
received data is automatically stored in SB.</p>
<p>The serial I/O port on the Game Boy is a very simple setup and is crude
compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports.
There are no start or stop bits.</p>
<p>During a transfer, a byte is shifted in at the same time that a byte is
shifted out. The rate of the shift is determined by whether the clock
source is internal or external. The most significant bit is shifted in
and out first.</p>
<p>When the internal clock is selected, it drives the clock pin on the game
link port and it stays high when not used. During a transfer it will go
low eight times to clock in/out each bit.</p>
<p>The state of the last bit shifted out determines the state of the output
line until another transfer takes place.</p>
<p>If a serial transfer with internal clock is performed and no external
Game Boy is present, a value of $FF will be received in the transfer.</p>
<p>The following code initiates the process of shifting $75 out the serial
port and a byte to be shifted into $FF01:</p>
<pre><code class="language-rgbasm">   ld a, $75
   ld [$FF01], a
   ld a, $81
   ld [$FF02], a
</code></pre>
<p>The Game Boy does not support wake-on-LAN. Completion of an externally
clocked serial transfer does not exit STOP mode.</p>
<h2 id="int-60--joypad-interrupt"><a class="header" href="#int-60--joypad-interrupt">INT $60 — Joypad interrupt</a></h2>
<p>The Joypad interrupt is requested when any of <a href="#ff00--p1joyp-joypad"><code>P1</code></a> bits 0-3 change
from High to Low. This happens when a button is
pressed (provided that the action/direction buttons are enabled by
bit 5/4, respectively), however, due to switch bounce, one or more High to Low
transitions are usually produced when pressing a button.</p>
<h3 id="using-the-joypad-interrupt"><a class="header" href="#using-the-joypad-interrupt">Using the joypad interrupt</a></h3>
<p>This interrupt is useful to identify button presses if we have only selected
either action (bit 5) or direction (bit 4), but not both.
If both are selected and, for example, a bit is already held Low by an action button,
pressing the corresponding direction button would
make no difference. The only meaningful purpose of the Joypad
interrupt would be to terminate the STOP (low power) standby state. GBA SP,
because of the different buttons used, seems to not be affected by
switch bounce.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="halt"><a class="header" href="#halt"><code>halt</code></a></h1>
<p><code>halt</code> is an instruction that pauses the CPU (during which less power is
consumed) when executed. The CPU wakes up as soon as an interrupt is pending,
that is, when the bitwise AND of <a href="#ffff--ie-interrupt-enable"><code>IE</code></a>
and <a href="#ff0f--if-interrupt-flag"><code>IF</code></a> is non-zero.</p>
<p>Most commonly, <a href="#ime-interrupt-master-enable-flag-write-only"><code>IME</code></a> is
set. In this case, the CPU simply wakes up, and before executing the instruction
after the <code>halt</code>, the <a href="#interrupt-handling">interrupt handler is called</a>
normally.</p>
<p>If <code>IME</code> is <em>not</em> set, there are two distinct cases, depending on whether an
interrupt is pending as the <code>halt</code> instruction is first executed.</p>
<ul>
<li>If no interrupt is pending, <code>halt</code> executes as normal, and the CPU resumes
regular execution as soon as an interrupt becomes pending. However, since
<code>IME</code>=0, the interrupt is not handled.</li>
<li>If an interrupt is pending, <code>halt</code> immediately exits, as expected, however
the “<code>halt</code> bug”, explained below, is triggered.</li>
</ul>
<h2 id="halt-bug"><a class="header" href="#halt-bug"><code>halt</code> bug</a></h2>
<p>Under some circumstances, <code>pc</code> fails to be normally incremented.</p>
<p>The most typical trigger, <code>halt</code> with <code>IME</code>=0 and <code>[IE] &amp; [IF] != 0</code>, causes
the byte after the <code>halt</code> to be read twice.</p>
<p>The behavior is different when <code>ei</code> (whose effect is typically delayed by one
instruction) is followed immediately by a <code>halt</code>, and an interrupt is pending
as the <code>halt</code> is executed. The interrupt is serviced and the handler called,
but the interrupt returns to the <code>halt</code>, which is executed again, and thus
waits for another interrupt.
(<a href="https://github.com/LIJI32/SameSuite/blob/master/interrupt/ei_delay_halt.asm">Source</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cgb-registers"><a class="header" href="#cgb-registers">CGB Registers</a></h1>
<p>This chapter describes only Game Boy Color (GBC or CGB) registers that didn’t
fit into normal categories — most CGB registers are described in the
chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA
Transfers, and changed meaning of Bit 0 of LCDC Control register). Also,
a changed bit is noted in the chapter about the Serial/Link port.</p>
<h2 id="unlocking-cgb-functions"><a class="header" href="#unlocking-cgb-functions">Unlocking CGB functions</a></h2>
<p>When using any CGB registers (including those in the Video/Link
chapters), you must first unlock CGB features by changing byte 0143h in
the cartridge header. Typically, use a value of 80h for games which
support both CGB and monochrome Game Boy systems, and C0h for games which work
on CGBs only. Otherwise, the CGB will operate in monochrome “Non CGB”
compatibility mode.</p>
<h2 id="detecting-cgb-and-gba-functions"><a class="header" href="#detecting-cgb-and-gba-functions">Detecting CGB (and GBA) functions</a></h2>
<p>CGB hardware can be detected by examining the CPU accumulator (A-register)
directly after startup. A value of 11h indicates CGB (or GBA) hardware,
if so, CGB functions can be used (if unlocked, see above). When A=11h,
you may also examine Bit 0 of the CPUs B-Register to separate between
CGB (bit cleared) and GBA (bit set), by that detection it is possible to
use “repaired” color palette data matching for GBA displays.</p>
<h2 id="documented-registers"><a class="header" href="#documented-registers">Documented registers</a></h2>
<h3 id="lcd-vram-dma-transfers"><a class="header" href="#lcd-vram-dma-transfers">LCD VRAM DMA Transfers</a></h3>
<h4 id="ff51ff52--hdma1-hdma2-cgb-mode-only-vram-dma-source-high-low-write-only"><a class="header" href="#ff51ff52--hdma1-hdma2-cgb-mode-only-vram-dma-source-high-low-write-only">FF51–FF52 — HDMA1, HDMA2 (CGB Mode only): VRAM DMA source (high, low) [write-only]</a></h4>
<p>These two registers specify the address at which the transfer will read
data from. Normally, this should be either in ROM, SRAM or WRAM, thus
either in range 0000-7FF0 or A000-DFF0. [Note: this has yet to be
tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source
address in VRAM will cause garbage to be copied.</p>
<p>The four lower bits of this address will be ignored and treated as 0.</p>
<h4 id="ff53ff54--hdma3-hdma4-cgb-mode-only-vram-dma-destination-high-low-write-only"><a class="header" href="#ff53ff54--hdma3-hdma4-cgb-mode-only-vram-dma-destination-high-low-write-only">FF53–FF54 — HDMA3, HDMA4 (CGB Mode only): VRAM DMA destination (high, low) [write-only]</a></h4>
<p>These two registers specify the address within 8000-9FF0 to which the
data will be copied. Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.</p>
<h4 id="ff55--hdma5-cgb-mode-only-vram-dma-lengthmodestart"><a class="header" href="#ff55--hdma5-cgb-mode-only-vram-dma-lengthmodestart">FF55 — HDMA5 (CGB Mode only): VRAM DMA length/mode/start</a></h4>
<p>These registers are used to initiate a DMA transfer from ROM or RAM to
VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0,
the lower four bits of the address are ignored (treated as zero). The
Destination Start Address may be located at 8000-9FF0, the lower four
bits of the address are ignored (treated as zero), the upper 3 bits are
ignored either (destination is always in VRAM).</p>
<p>Writing to this register starts the transfer, the lower 7 bits of which
specify the Transfer Length (divided by 10h, minus 1), that is, lengths of
10h-800h bytes can be defined by the values 00h-7Fh. The upper bit
indicates the Transfer Mode:</p>
<h5 id="bit-7--0--general-purpose-dma"><a class="header" href="#bit-7--0--general-purpose-dma">Bit 7 = 0 — General-Purpose DMA</a></h5>
<p>When using this transfer method,
all data is transferred at once. The execution of the program is halted
until the transfer has completed. Note that the General Purpose DMA
blindly attempts to copy the data, even if the LCD controller is
currently accessing VRAM. So General Purpose DMA should be used only if
the Display is disabled, or during VBlank, or (for rather short blocks)
during HBlank. The execution of the program continues when the transfer
has been completed, and FF55 then contains a value of FFh.</p>
<h5 id="bit-7--1--hblank-dma"><a class="header" href="#bit-7--1--hblank-dma">Bit 7 = 1 — HBlank DMA</a></h5>
<p>The HBlank DMA transfers 10h bytes of
data during each HBlank, that is, at LY=0-143, no data is transferred during
VBlank (LY=144-153), but the transfer will then continue at LY=00. The
execution of the program is halted during the separate transfers, but
the program execution continues during the “spaces” between each data
block. Note that the program should not change the Destination VRAM bank
(FF4F), or the Source ROM/RAM bank (in case data is transferred from
bankable memory) until the transfer has completed! (The transfer should
be paused as described below while the banks are switched)</p>
<p>Reading from Register FF55 returns the remaining length (divided by 10h,
minus 1), a value of 0FFh indicates that the transfer has completed. It
is also possible to terminate an active HBlank transfer by writing zero
to Bit 7 of FF55. In that case reading from FF55 will return how many
$10 “blocks” remained (minus 1) in the lower 7 bits, but Bit 7 will
be read as “1”. Stopping the transfer doesn’t set HDMA1-4 to $FF.</p>
<div class="box warning">
<p class="box-title">WARNING</p><p>HBlank DMA should not be started (write to FF55) during a HBlank
period (STAT mode 0).</p>
<p>If the transfer’s destination address overflows, the transfer stops
prematurely.
The status of the registers if this happens still needs to be <a href="https://github.com/gbdev/pandocs/issues/364">investigated</a>.</p>
</div>
<h4 id="confirming-if-the-dma-transfer-is-active"><a class="header" href="#confirming-if-the-dma-transfer-is-active">Confirming if the DMA Transfer is Active</a></h4>
<p>Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is
active (1=Not Active, 0=Active). This works under any circumstances -
after completion of General Purpose, or HBlank Transfer, and after
manually terminating a HBlank Transfer.</p>
<h4 id="transfer-timings"><a class="header" href="#transfer-timings">Transfer Timings</a></h4>
<p>In both Normal Speed and Double Speed Mode it takes about 8 μs to
transfer a block of $10 bytes.
That is, 8 M-cycles in Normal Speed Mode <a href="imgs/hdma_single_speed.png">[1]</a>,
and 16 “fast” M-cycles in Double Speed Mode <a href="imgs/hdma_double_speed.png">[2]</a>.
Older MBC controllers (like MBC1-3) and slower ROMs are not guaranteed to support General
Purpose or HBlank DMA, that’s because there are always 2 bytes
transferred per microsecond (even if the itself program runs it Normal
Speed Mode).</p>
<h3 id="vram-banks"><a class="header" href="#vram-banks">VRAM Banks</a></h3>
<p>The CGB has twice the VRAM of the DMG, but it is banked and either bank
has a different purpose.</p>
<h4 id="ff4f--vbk-cgb-mode-only-vram-bank"><a class="header" href="#ff4f--vbk-cgb-mode-only-vram-bank">FF4F — VBK (CGB Mode only): VRAM bank</a></h4>
<p>This register can be written to change VRAM banks. Only bit 0
matters, all other bits are ignored.</p>
<h4 id="vram-bank-1"><a class="header" href="#vram-bank-1">VRAM bank 1</a></h4>
<p>VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles
(just like in bank 0), which can be accessed the same way as (and at the
same time as) bank 0 tiles. 9800-9FFF contains the attributes for the
corresponding Tile Maps.</p>
<p>Reading from this register will return the number of the currently
loaded VRAM bank in bit 0, and all other bits will be set to 1.</p>
<h3 id="ff4d--key1-cgb-mode-only-prepare-speed-switch"><a class="header" href="#ff4d--key1-cgb-mode-only-prepare-speed-switch">FF4D — KEY1 (CGB Mode only): Prepare speed switch</a></h3>
<pre><code> Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
 Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)
</code></pre>
<p>This register is used to prepare the Game Boy to switch between CGB
Double Speed Mode and Normal Speed Mode. The actual speed switch is
performed by executing a <code>stop</code> instruction after Bit 0 has been set. After
that, Bit 0 will be cleared automatically, and the Game Boy will operate
at the “other” speed. The recommended speed switching procedure in
pseudocode would be:</p>
<pre><code>IF KEY1_BIT7 != DESIRED_SPEED THEN
   IE = $00       ; (FFFF) = $00
   JOYP = $30     ; (FF00) = $30
   KEY1 = $01     ; (FF4D) = $01
   STOP
ENDIF
</code></pre>
<p>The CGB is operating in Normal Speed Mode when it is first turned on. Note
that using the Double Speed Mode increases the power consumption; therefore, it
would be recommended to use Single Speed whenever possible.</p>
<p>In Double Speed Mode the following will operate twice as fast as normal:</p>
<ul>
<li>The CPU (2.10 MHz, so 1 cycle = approx. 0.5 µs)</li>
<li>Timer and Divider Registers</li>
<li>Serial Port (Link Cable)</li>
<li>DMA Transfer to OAM</li>
</ul>
<p>And the following will keep operating as usual:</p>
<ul>
<li>LCD Video Controller</li>
<li>HDMA Transfer to VRAM</li>
<li>All Sound Timings and Frequencies</li>
</ul>
<p>The CPU stops for 2050 cycles (= 8200 clocks) after the <code>stop</code> instruction is
executed. During this time, the CPU is in a strange state. <code>DIV</code> does not tick, so
<em>some</em> audio events are not processed. Additionally, VRAM/OAM/… locking is “frozen”, yielding
different results depending on the <a href="#ff41--stat-lcd-status">STAT mode</a> it’s started in:</p>
<ul>
<li>HBlank / VBlank (Mode 0 / Mode 1): The PPU cannot access any video memory, and produces black pixels</li>
<li>OAM scan (Mode 2): The PPU can access VRAM just fine, but not OAM, leading to rendering background, but not sprites</li>
<li>Rendering (Mode 3): The PPU can access everything correctly, and so rendering is not affected</li>
</ul>
<p>TODO: confirm whether interrupts can occur (just the joypad one?) during the pause, and consequences if so</p>
<h3 id="ff56--rp-cgb-mode-only-infrared-communications-port"><a class="header" href="#ff56--rp-cgb-mode-only-infrared-communications-port">FF56 — RP (CGB Mode only): Infrared communications port</a></h3>
<p>This register allows to input and output data through the CGBs built-in
Infrared Port. When reading data, bit 6 and 7 must be set (and obviously
Bit 0 must be cleared — if you don’t want to receive your own Game Boy’s
IR signal). After sending or receiving data you should reset the
register to 00h to reduce battery power consumption again.</p>
<pre><code> Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
 Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
 Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)
</code></pre>
<p>Note that the receiver will adapt itself to the normal level of IR
pollution in the air, so if you would send a LED ON signal for a longer
period, then the receiver would treat that as normal (=OFF) after a
while. For example, a Philips TV Remote Control sends a series of 32 LED
ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent
880us LED ON signal. Even though being generally CGB compatible, the GBA
does not include an infra-red port.</p>
<h3 id="ff6c--opri-cgb-mode-only-object-priority-mode"><a class="header" href="#ff6c--opri-cgb-mode-only-object-priority-mode">FF6C — OPRI (CGB Mode only): Object priority mode</a></h3>
<p>This register serves as a flag for which object priority mode to use. While
the DMG prioritizes objects by x-coordinate, the CGB prioritizes them by
location in OAM. This flag is set by the CGB bios after checking the game’s CGB compatibility.</p>
<p>OPRI has an effect if a PGB value (<code>0xX8</code>, <code>0xXC</code>) is written to KEY0 but STOP hasn’t been executed yet, and the write takes effect instantly.</p>
<div class="box warning">
<p class="box-title">TO BE VERIFIED</p><p>It does not have an effect, at least not an instant effect, if written to during CGB or DMG mode after the boot ROM has been unmapped.
It is not known if triggering a PSM NMI, which remaps the boot ROM, has an effect on this register’s behavior.</p>
</div>
<pre><code>Bit 0: OBJ Priority Mode (0=OAM Priority, 1=Coordinate Priority) (Read/Write)
</code></pre>
<h3 id="ff70--svbk-cgb-mode-only-wram-bank"><a class="header" href="#ff70--svbk-cgb-mode-only-wram-bank">FF70 — SVBK (CGB Mode only): WRAM bank</a></h3>
<p>In CGB Mode 32 KBytes internal RAM are available. This memory is divided
into 8 banks of 4 KBytes each. Bank 0 is always available in memory at
C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.</p>
<pre><code> Bit 0-2  Select WRAM Bank (Read/Write)
</code></pre>
<p>Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h
will select Bank 1 too.</p>
<h2 id="undocumented-registers"><a class="header" href="#undocumented-registers">Undocumented registers</a></h2>
<p>These are undocumented CGB Registers. The purpose of these registers is
unknown (if any). It isn’t recommended to use them in your software,
but you could, for example, use them to check if you are running on an
emulator or on DMG hardware.</p>
<h3 id="ff72ff73--bits-07-cgb-mode-only"><a class="header" href="#ff72ff73--bits-07-cgb-mode-only">FF72–FF73 — Bits 0–7 (CGB Mode only)</a></h3>
<p>Both of these registers are fully read/write.
Their initial value is $00.</p>
<h3 id="ff74--bits-07-cgb-mode-only"><a class="header" href="#ff74--bits-07-cgb-mode-only">FF74 — Bits 0–7 (CGB Mode only)</a></h3>
<p>In CGB mode, this register is fully readable and writable.
Its initial value is $00.</p>
<p>Otherwise, this register is read-only, and locked at value $FF.</p>
<h3 id="ff75--bits-46-cgb-mode-only"><a class="header" href="#ff75--bits-46-cgb-mode-only">FF75 — Bits 4–6 (CGB Mode only)</a></h3>
<p>Only bits 4, 5 and 6 of this register are read/write enabled.
Their initial value is 0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gbc-infrared-communication"><a class="header" href="#gbc-infrared-communication">GBC Infrared Communication</a></h1>
<p><small>This section was originally compiled by Shonumi in the “Dan Docs”. Upstream source can be found <a href="https://shonumi.github.io/dandocs.html" target="_blank">here</a>.</small></p>
<p>The Game Boy Color came with an infrared port on the very top of the handheld. Previously, where IR communications had to be done with special cartridges (like the HuC-1 variants), the Game Boy itself now had the hardware built-in. Unfortunately, the feature was never popular outside of a few games and accessories. The IR port essentially sends out signals and is also capable of receiving them, allowing for fast, wireless, line-of-sight transmission.</p>
<ul>
<li>GBC comes with one IR port. Capable of sending and receiving an IR signal (two separate diodes).</li>
<li>Turning on the IR light does drain battery, hence not recommended leaving it on when not in use</li>
<li>IR port can communicate with non-GBC devices, e.g. anything that sends an IR signal (TV remotes, Wiimotes, household lamps, etc)</li>
</ul>
<h2 id="communication-types"><a class="header" href="#communication-types">Communication Types</a></h2>
<p>While a number of games may use similar formats for their IR communications, there is no “standard” protocol that all games use. IR communication is entirely determined by the game’s code, hence it can vary wildly depending on needs. However, all communications fall into one of several general categories as described below:</p>
<ul>
<li>1-Player Init: These only require one GBC to initiate IR transfers. Both GBCs typically wait for an infrared signal. When one player presses a button, the GBC starts sending pulses. This setup is not unlike how 2-Player Serial I/O is handled (with master and slave Game Boys). Examples include Super Mario Bros. DX score exchange and the GBC-to-GBC Mystery Gifts in Pokemon Gold/Silver/Crystal. Most IR compatible games fall into this group.</li>
<li>2-Player Init: Transfers require both GBCs to initiate at roughly the same time. Examples include Pokemon Pinball score exchange, Pokemon TCG’s “Card Pop”, and trading/fighting Charaboms in the Bomberman games.</li>
<li>Active Object Init: Transfers require the GBC to interact with another non-GBC device capable of both sending and receiving infrared signals. These objects are designed to work specifically with GBCs and send pulses in much the same manner as a GBC would. Examples include Mystery Gifts via the Pokemon Pikachu 2 and trading Points via the Pocket Sakura.</li>
<li>Inactive Object Init: Transfers require the GBC to interact with another non-GBC device capable of sending infrared signals but not necessarily receiving them. These objects may not be designed to work specifically with GBCs (notable exception is the Full Changer). Communication is input-only for these cases. Examples include Zok Zok Heroes, Chee Chai Alien, the Bomberman Max games’ special stages, and Mission Impossible’s TV remote feature.</li>
</ul>
<h2 id="communication-protocol"><a class="header" href="#communication-protocol">Communication Protocol</a></h2>
<p>Again, there is no set or established infrared protocol that games must follow. Many games vary in their approach. For example, the 2nd Generation Pokemon games use the GBC’s hardware timers, while others have hardcoded values that count cycles to check timing. The simplest form is a bare-bones communication protocol, i.e. something like a binary Morse code where a “0” is a long ON-OFF pulse and “1” is a short ON-OFF pulse or vice versa. Properly done, data could have been short, compact, and easily converted into bytes in RAM. Sakura Taisen GB seems to follow this model in its communications with the Pocket Sakura. Not all games do this, however, and appear to be doing who knows that, opting instead for customized and specialized communications unique to each title. To illustrate this idea, it would be possible to use a table of given lengths of IR ON-OFF pulses so that individual bytes could be sent all at once instead of in a binary, bit-by-bit manner. A number of games try to send a few pulses when pressing input like the A button and wait for another GBC to echo that in response, but after the handshake, most of the IR pulses are impossible to understand without disassembling the code.</p>
<p>One thing to note is that 4 games in particular do share somewhat similar IR protocols, at least regarding the initial handshake between 2 GBCs. They are Pokemon TCG 1 &amp; 2 and Bombermax Red &amp; Blue, all from the “2-Player Init” category above. Typically, IR capable GBC games will continually wait for an IR signal on both sides, i.e. the “1-Player Init” category. When one player presses certain input, that GBC takes the initiative and sends out a few IR pulses. That is to say, for most IR games, it only takes <em>just one</em> player to start the entire process.</p>
<p>The handshake for the 4 games previously mentioned, however, requires <em>both</em> players to input at almost the same time. One has to be slightly faster or slower than the other. Each side continually sends a few IR pulses, then reads the sensor to see if anything was received. If so, the GBCs begin to sync. The idea is that one side should be sending while the other is checking, and then the handshake completes. This is why one side needs to be faster or slower to input; if they are sending IR signals at the same time, they don’t see anything when reading the sensor. As a result, both GBCs cannot input at exactly the same time. Practically speaking, this is unlikely to happen under normal circumstances, since most humans can’t synchronize their actions down to a handful of microseconds, so the handshake will normally succeed.</p>
<h2 id="rp-register"><a class="header" href="#rp-register">RP Register</a></h2>
<p>The following is just theory. This handshake is possibly an artifact of the HuC-1. Consider that the Japanese version of Pokemon TCG 1 used the HuC-1 for its IR communications, and the developers may have borrowed the “best practices” used by other HuC-1/“GB KISS” games. When bringing Pokemon TCG 1 overseas, the IR handling code was likely minimally adapted to use the GBC’s IR port, with the underlying protocol remaining unchanged in most regards. Pokemon TCG 2 ditched the HuC-1 in favor of the GBC IR port, so the IR code from non-Japanese versions of Pokemon TCG 1 was copy+pasted. The Bomberman games were made by Hudson Soft, literally the same people who created the HuC-1 in the first place. They too probably used the same protocol that had worked forever in their “GB KISS” games, so they used the same handshake method as before, just on the GBC IR port now. More research into the HuC-1 itself and the games needs to be done to confirm any of this.</p>
<p>On the GBC, the MMIO register located at 0xFF56 controls infrared communication. Simply known as “RP” (Radiation Port? Reception Port? Red Port???), it is responsible for sending and receiving IR signals. Below is a diagram of the 8-bit register:</p>
<div class="table-wrapper"><table><thead><tr><th>Bit(s)</th><th>Effect</th><th>Access</th></tr></thead><tbody>
<tr><td>0</td><td>Turn IR light ON (1) or OFF (0)</td><td>R/W</td></tr>
<tr><td>1</td><td>Bit 1 = 1</td><td>R</td></tr>
<tr><td>2-5</td><td>Unused</td><td></td></tr>
<tr><td>6-7</td><td>Signal Read Enable (0 = Disable) (3 = Enable)</td><td>R/W</td></tr>
</tbody></table>
</div>
<p>Turning on the IR light is as simple as writing to Bit 0 of RP. Reading is a bit more complicated. Bits 6 and 7 must both be set (0xC0), to read Bit 1, otherwise Bit 1 returns 1, acting as if no signal is detected, except in edge cases detailed below in “Obscure Behavior”. With signal reading enabled, Bit 1 will determine the status of any incoming IR signals. Like other Game Boy MMIO registers, unused bits read high (set to 1).</p>
<h2 id="signal-fade"><a class="header" href="#signal-fade">Signal Fade</a></h2>
<p>The IR sensor in the GBC adapts to the current level of IR light. That is to say, if the GBC receives a sustained IR signal beyond a certain amount of time, eventually the sensor treats this as a new “normal” level of IR light, and Bit 1 of RP goes back to 1. This is called the signal “fade” because it may appear as if the signal disappears.</p>
<p>Signal fade time is dependent on length and has an inverse relationship with the distance between a GBC and the IR light. The closer a GBC is to the IR source, the longer the fade time. The farther away a GBC is to the IR source, the shorter the fade time. One possible explanation for everything is that the IR signal is weaker on the receiving end, so the signal is prone to get “lost” to surrounding noise. The GBC IR sensor is probably good at sending IR signals (evidenced by the Mission Impossible cheat to turn a GBC into a TV remote) but not so good at picking up signals (evidenced by Chee Chai Aliens plastic add-on to enhance IR reception).</p>
<p>At about 3.0 to 3.5 inches (7.62 to 8.89 cm) signal fade time appears to be around 3ms. Optimal distance seems to be 2.5 to 4.0 inches (6.35 to 10.16 cm) to maintain a fade time close to 3ms and avoid potential miscommunication. One oddity of note is that putting two GBCs very close together (physically touching) produced unusually short fade times, far shorter than 3ms. There may be some sort of interference at that range.</p>
<h2 id="obscure-behavior"><a class="header" href="#obscure-behavior">Obscure Behavior</a></h2>
<p>The RP register has one very strange quirk. Disabling Bits 6 and 7 and then subsequently re-enabling them causes Bit 1 to go to zero under certain conditions. In other words, the IR sensor will act as if it is detecting a signal if reading the signal is disabled then enabled. It seems this behavior happens in the presence of any light; covering up the sensor during the read signal disable/enable causes the sensor to act normally. It’s possible that the sensor resets itself (to its lowest level of detection???) and immediately detects any infrared sources, even from ambient/environmental light. The presence of any noise may temporarily trick the sensor into “seeing” IR light. By abusing this behavior, the GBC has some rudimentary ability to gauge the type of nearby lighting:</p>
<div class="table-wrapper"><table><thead><tr><th>Result of 1st RP Write (0x00)</th><th>Result of 2nd RP Write (0xC0)</th><th>Type of Lighting</th></tr></thead><tbody>
<tr><td>Bit 1 = 1</td><td>Bit 1 = 1</td><td>Dark</td></tr>
<tr><td>Bit 1 = 0</td><td>Bit 1 = 1</td><td>Ambient</td></tr>
<tr><td>Bit 1 = 0 (sometimes 1)</td><td>Bit 1 = 0</td><td>Bright</td></tr>
</tbody></table>
</div>
<p>Writing 0x00 to RP, followed by 0xC0 will trigger these results listed above. One very important thing to note is that when enabling Bits 6 and 7 (writing 0xC0), it does take some time for the sensor to register legitimate IR light coming into the sensor. I.e. if you want to use this method to detect what kind of light a GBC is looking at, the software needs to loop for a bit until Bit 1 of RP changes. Generally a few hundred cycles in double-speed mode will suffice. If Bit 1 of RP remains 1 after the loop, it’s safe to assume the lighting is either ambient or dark. This delay doesn’t seem to happen when Bits 6 and 7 are never disabled (which is what most official GBC software does). Games typically write either 0xC0 or 0xC1 to RP, with a small handful setting it to 0x00 initially when setting up other MMIO registers (Pokemon G/S/C does this).</p>
<p>The downside to this method is that when detecting a bright IR source, the sensor quickly adjusts to this new level, and the next attempt at writing 0x00 followed by 0xC0 to RP will result in readings of dark or ambient (typically dark though). Essentially the bright result only appears briefly when transitioning from lower levels of light, then it “disappears” thanks to the short time it takes for IR signal fade. Designing a game mechanic (darkness and light) around this quirk is still possible, although it would require careful thought and planning to properly work around the observed limitations.</p>
<p>One suggested method: once the Bright setting is detected, switch to writing only 0xC0 to RP so that the IR sensor works normally. If IR light stops being detected, switch to alternating 0x00 and 0xC0 writes as described above to determine Dark or Ambient settings. Whether it’s practical or not to do this in a game remains theoretical at this point.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sgb-description"><a class="header" href="#sgb-description">SGB Description</a></h1>
<h2 id="general-description"><a class="header" href="#general-description">General Description</a></h2>
<p>Basically, the SGB (Super Game Boy) is an adapter cartridge that allows
to play Game Boy games on a SNES (Super Nintendo Entertainment System)
gaming console. In detail, you plug the Game Boy cartridge into the SGB
cartridge, then plug the SGB cartridge into the SNES, and then connect
the SNES to your TV Set. In result, games can be played and viewed on
the TV Set, and are controlled by using the SNES joypad(s).</p>
<h2 id="more-technical-description"><a class="header" href="#more-technical-description">More Technical Description</a></h2>
<p>The SGB cartridge just contains a normal Game Boy CPU and normal Game Boy
video controller. Normally the video signal from this controller would
be sent to the LCD screen, however, in this special case the SNES read
out the video signal and displays it on the TV set by using a special
SNES BIOS ROM which is located in the SGB cartridge. Also, normal
Game Boy sound output is forwared to the SNES and output to the TV Set,
vice versa, joypad input is forwared from the SNES controller(s) to the
Game Boy joypad inputs.</p>
<h2 id="normal-monochrome-games"><a class="header" href="#normal-monochrome-games">Normal Monochrome Games</a></h2>
<p>Any Game Boy games which have been designed for monochrome handheld
Game Boy systems will work with the SGB hardware as well. The SGB will
apply a four color palette to these games by replacing the normal four
grayshades. The 160x144 pixel gamescreen is displayed in the middle of
the 256x224 pixel SNES screen (the unused area is filled by a screen
border bitmap). The user may access built-in menues, allowing to change
color palette data, to select between several pre-defined borders, etc.</p>
<p>Games that have been designed to support SGB functions may also access
the following additional features:</p>
<h2 id="colorized-game-screen"><a class="header" href="#colorized-game-screen">Colorized Game Screen</a></h2>
<p>There’s limited ability to colorize the gamescreen by assigning custom
color palettes to each 20x18 display characters, however, this works
mainly for static display data such like title screens or status bars,
the 20x18 color attribute map is non-scrollable, and it is not possible
to assign separate colors to moveable foreground sprites (OBJs), so that
animated screen regions will be typically restricted to using a single
palette of four colors only.</p>
<h2 id="snes-foreground-sprites"><a class="header" href="#snes-foreground-sprites">SNES Foreground Sprites</a></h2>
<p>Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can
be displayed. When replacing (or just overlaying) the normal Game Boy
OBJs by SNES OBJs it’d be thus possible to display OBJs with other
colors than normal background area. This method doesn’t appear to be
very popular, even though it appears to be quite easy to implement,
however, the bottommost character line of the gamescreen will be masked
out because this area is used to transfer OAM data to the SNES.</p>
<h2 id="the-sgb-border"><a class="header" href="#the-sgb-border">The SGB Border</a></h2>
<p>The possibly most popular and most impressive feature is to replace the
default SGB screen border by a custom bitmap which is stored in the game
cartridge.</p>
<h2 id="multiple-joypads"><a class="header" href="#multiple-joypads">Multiple Joypads</a></h2>
<p>Up to four joypads can be conected to the SNES, and SGB software may
read-out each of these joypads separately, allowing up to four players
to play the same game simultaneously. Unlike for multiplayer handheld
games, this requires only one game cartridge and only one SGB/SNES, and
no link cables are required, the downside is that all players must share
the same display screen.</p>
<h2 id="sound-functions"><a class="header" href="#sound-functions">Sound Functions</a></h2>
<p>Beside for normal Game Boy sound, a number of digital sound effects is
pre-defined in the SNES BIOS, these effects may be accessed quite
easily. Programmers whom are familiar with SNES sounds may also access
the SNES sound chip, or use the SNES MIDI engine directly in order to
produce other sound effects or music.</p>
<h2 id="taking-control-of-the-snes-cpu"><a class="header" href="#taking-control-of-the-snes-cpu">Taking Control of the SNES CPU</a></h2>
<p>Finally, it is possible to write program code or data into SNES memory,
and to execute such program code by using the SNES CPU.</p>
<h2 id="sgb-system-clock"><a class="header" href="#sgb-system-clock">SGB System Clock</a></h2>
<p>Because the SGB is synchronized to the SNES CPU, the Game Boy system
clock is directly chained to the SNES system clock. In result, the
Game Boy CPU, video controller, timers, and sound frequencies will be all
operated approx 2.4% faster than handheld systems. Basically, this
should be no problem, and the game will just run a little bit faster.
However sensitive musicians may notice that sound frequencies are a bit
too high, programs that support SGB functions may avoid this effect by
reducing frequencies of Game Boy sounds when having detected SGB
hardware. Also, “PAL version” SNES models which use a
50Hz display refresh rate (rather than 60Hz) result in
respectively slower Game Boy timings.</p>
<ul>
<li>NTSC SGB: 21.477 MHz master clock, 4.2955 MHz GB clock, 2.41% fast</li>
<li>PAL SGB: 21.281 MHz master clock, 4.2563 MHz GB clock, 1.48% fast</li>
<li>NTSC SGB2: Separate 20.972 MHz crystal, correct speed</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unlocking-and-detecting-sgb-functions"><a class="header" href="#unlocking-and-detecting-sgb-functions">Unlocking and Detecting SGB Functions</a></h1>
<h2 id="cartridge-header"><a class="header" href="#cartridge-header">Cartridge Header</a></h2>
<p>SGB games are required to have a cartridge header with Nintendo logo and
proper checksum just as normal Game Boy games. Also, two special entries
must be set in order to unlock SGB functions:</p>
<ul>
<li><a href="#0146--sgb-flag">SGB flag</a>: Must be set to $03 for SGB games</li>
<li><a href="#014b--old-licensee-code">Old licensee code</a>: Must be set to $33 for SGB games</li>
</ul>
<p>When these entries aren’t set, the game will still work just like all
“monochrome” Game Boy games, but it cannot access any of the special
SGB functions.</p>
<h2 id="detecting-sgb-hardware"><a class="header" href="#detecting-sgb-hardware">Detecting SGB hardware</a></h2>
<p>SGB hardware can be detected by examining the initial value of the C
register directly after startup: a value of $14 indicates SGB or SGB2
hardware. It is also possible to separate between SGB and SGB2 by
examining the initial value of the A register directly after startup.
Note that the DMG and MGB share initial A register values with the SGB
and SGB2 respectively.</p>
<div class="table-wrapper"><table><thead><tr><th>Console</th><th>A Register</th><th>C Register</th></tr></thead><tbody>
<tr><td>DMG</td><td>$01</td><td>$13</td></tr>
<tr><td>SGB</td><td>$01</td><td>$14</td></tr>
<tr><td>MGB</td><td>$FF</td><td>$13</td></tr>
<tr><td>SGB2</td><td>$FF</td><td>$14</td></tr>
<tr><td>CGB</td><td>$11</td><td>$00</td></tr>
<tr><td>AGB</td><td>$11</td><td>$00</td></tr>
</tbody></table>
</div>
<p>For initial register values on all systems, see the table of all <a href="#cpu-registers">CPU
registers after power-up</a>.</p>
<p>The SGB2 doesn’t have any extra features which’d require separate SGB2
detection except for curiosity purposes, for example, the game “Tetris
DX” chooses to display an alternate SGB border on SGB2s.</p>
<p>Only the SGB2 contains a link port.</p>
<p>SGB hardware has traditionally been detected by sending <a href="#sgb-command-11--mlt_req"><code>MLT_REQ</code> commands</a>, but this
method is more complicated and slower than checking the value of the A
and C registers after startup. The <code>MLT_REQ</code> command enables two (or four)
joypads; a normal handheld Game Boy will ignore this command, but an SGB
will return incrementing joypad IDs each time when deselecting keypad
lines (<a href="#reading-multiple-controllers-joypads">see <code>MLT_REQ</code> description</a>). The joypad state/IDs can
then be read out several times, and if the IDs are changing, then it is
an SGB (a normal Game Boy would typically always return $0F as the ID).
Finally, when not intending to use more than one joypad, send another
<code>MLT_REQ</code> command in order to disable the multi-controller mode.
Detection works regardless of how many joypads are physically connected
to the SNES. However, unlike the C register method, this detection works only when
SGB functions <a href="#cartridge-header">are unlocked from the cartridge header</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-packet-transfers"><a class="header" href="#command-packet-transfers">Command Packet Transfers</a></h1>
<p>Command packets (aka Register Files) are transferred from the Game Boy to
the SNES by using P14 and P15 output lines of the JOYPAD register
(FF00h).  These same lines are also used to select the two rows in the
Game Boy keyboard matrix (which still works).</p>
<h2 id="transferring-bits"><a class="header" href="#transferring-bits">Transferring Bits</a></h2>
<p>A command packet transfer must be initiated by setting both P14 and P15
to LOW; this will reset and start the ICD2 packet receiving circuit.
Data is then transferred (LSB first), setting P14=LOW will indicate a
“0” bit, and setting P15=LOW will indicate a “1” bit. For example:</p>
<pre><code>    RESET  0   0   1   1   0   1   0
P14  --_---_---_-----------_-------_--...
P15  --_-----------_---_-------_------...
       ↑         ↑         ↑         ↑
Time   0         50       100       150
</code></pre>
<p><a href="#super-game-boy-sgb-sgb2">The boot ROM</a> and licensed software keep data and reset pulses LOW for at least 5 μs and leave P14 and P15 HIGH for at least 15 μs after each pulse.
Though the hardware is capable of receiving pulses and spaces as short as 2 μs (as tested using <a href="https://github.com/zlago/sgb-speedtest/">sgb-speedtest</a>),
following the common practice of 5-cycle pulses and 15-cycle spaces may improve reliability in some corner case that the community has not yet discovered.
Obviously, it’d be no good idea to access <a href="#ff00--p1joyp-joypad">the joypad register</a> during the transfer,
for example, in case that your VBlank interrupt procedure reads-out
joypad states each frame, so be sure to disable that interrupt during the
transfer (or disable only the joypad procedure by using a software
flag).</p>
<h2 id="transferring-packets"><a class="header" href="#transferring-packets">Transferring Packets</a></h2>
<p>Each packet is invoked by a RESET pulse, then 128 bits of data are
transferred (16 bytes, LSB of first byte first), and finally, a
“0” bit must be transferred as a stop bit.
These 130 bit periods correspond to at least 2600 cycles at the recommended rate.</p>
<p>The structure of the first packet in a transmission is:</p>
<ol>
<li>1 pulse: Start signal</li>
<li>1 byte: Header byte (Command Code * 8 + Length)</li>
<li>15 bytes: Parameter Data</li>
<li>1 bit: Stop Bit (0)</li>
</ol>
<p>The above “Length” indicates the total number of packets (1-7,
including the first packet) which will be sent.  If more than 15
parameter bytes are used, then further packet(s) will follow, as such:</p>
<ol>
<li>1 pulse: Start signal</li>
<li>16 bytes: Parameter Data</li>
<li>1 bit: Stop Bit (0)</li>
</ol>
<p>By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don’t matter.
The GB program should wait 60 ms (4 frames) between each packet transfer and the next,
as the “bomb” tool to erase a user-drawn border can cause the SGB system software not to check for packets for 4 frames.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vram-transfers"><a class="header" href="#vram-transfers">VRAM Transfers</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Beside for the packet transfer method, larger data blocks of 4KBytes can
be transferred by using the video signal. These transfers are invoked by
first sending one of the commands with the ending _TRN (by using normal
packet transfer), the 4K data block is then read-out by the SNES from
Game Boy display memory during the next frame.</p>
<h2 id="transfer-data"><a class="header" href="#transfer-data">Transfer Data</a></h2>
<p>Normally, transfer data should be stored at 8000h-8FFFh in Game Boy VRAM,
even though the SNES receives the data in from display scanlines, it
will automatically re-produce the same ordering of bits and bytes, as
being originally stored at 8000h-8FFFh in Game Boy memory.</p>
<h2 id="preparing-the-display"><a class="header" href="#preparing-the-display">Preparing the Display</a></h2>
<p>The above method works only when recursing the following things: BG Map
must display unsigned characters 00h-FFh on the screen; 00h..13h in
first line, 14h..27h in next line, etc. The Game Boy display must be
enabled, the display may not be scrolled, OBJ sprites should not overlap
the background tiles, the BGP palette register must be set to E4h.</p>
<h2 id="transfer-time"><a class="header" href="#transfer-time">Transfer Time</a></h2>
<p>Note that the transfer data should be prepared in VRAM <strong>before</strong> sending
the transfer command packet. The actual transfer starts at the beginning
of the next frame after the command has been sent, and the transfer ends
at the end of the 5th frame after the command has been sent (not
counting the frame in which the command has been sent). The displayed
data must not be modified during the transfer, as the SGB reads it in
multiple chunks.</p>
<h2 id="avoiding-screen-garbage"><a class="header" href="#avoiding-screen-garbage">Avoiding Screen Garbage</a></h2>
<p>The display will contain “garbage” during the transfer, this
dirt-effect can be avoided by freezing the screen (in the state which
has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on an SGB
(and not on handheld Game Boy systems), it’d be thus required to detect
the presence of SGB hardware before blindly sending VRAM data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color-palettes-overview"><a class="header" href="#color-palettes-overview">Color Palettes Overview</a></h1>
<h2 id="available-snes-palettes"><a class="header" href="#available-snes-palettes">Available SNES Palettes</a></h2>
<p>The SGB/SNES provides 8 palettes of 16 colors each, each color may be
defined out of a selection of 32768 colors (15 bit). Palettes 0-3 are
used to colorize the gamescreen, only the first four colors of each of
these palettes are used. Palettes 4-7 are used for the SGB Border, all
16 colors of each of these palettes may be used.</p>
<h2 id="color-format"><a class="header" href="#color-format">Color format</a></h2>
<p>Colors are encoded as 16-bit RGB numbers, in the following way:</p>
<pre><code>FEDC BA98 7654 3210
0BBB BBGG GGGR RRRR
</code></pre>
<p>Here’s a formula to convert 24-bit RGB into SNES format:
<code>(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19</code></p>
<p>The palettes are encoded <strong>little-endian</strong>, thus, the R/G byte comes
first in memory.</p>
<h2 id="color-0-restriction"><a class="header" href="#color-0-restriction">Color 0 Restriction</a></h2>
<p>Color 0 of each of the eight palettes is transparent, causing the
backdrop color to be displayed instead. The backdrop color is typically
defined by the most recently color being assigned to Color 0 (regardless
of the palette number being used for that operation). Effectively,
gamescreen palettes can have only three custom colors each, and SGB
border palettes only 15 colors each, additionally, color 0 can be used
for for all palettes, which will then all share the same color though.</p>
<h2 id="translation-of-grayshades-into-colors"><a class="header" href="#translation-of-grayshades-into-colors">Translation of Grayshades into Colors</a></h2>
<p>Because the SGB/SNES reads out the Game Boy video controllers display
signal, it translates the different grayshades from the signal into SNES
colors as such:</p>
<pre><code>White       --&gt;  Color #0
Light Gray  --&gt;  Color #1
Dark Gray   --&gt;  Color #2
Black       --&gt;  Color #3
</code></pre>
<p>Note that Game Boy colors 0-3 are assigned to user-selectable grayshades
by the Game Boy’s BGP, OBP0, and OBP1 registers. There is thus no fixed
relationship between Game Boy colors 0-3 and SNES colors 0-3.</p>
<h3 id="using-game-boy-bgpobp-registers"><a class="header" href="#using-game-boy-bgpobp-registers">Using Game Boy BGP/OBP Registers</a></h3>
<p>A direct translation of GB color 0-3 into SNES color 0-3 may be produced
by setting BGP/OBPx registers to a value of 0E4h each. However, in case
that your program uses black background for example, then you may
internally assign background as “White” at the Game Boy side by BGP/OBP
registers (which is then interpreted as SNES color 0, which is shared
for all SNES palettes). The advantage is that you may define Color 0 as
Black at the SNES side, and may assign custom colors for Colors 1-3 of
each SNES palette.</p>
<h2 id="system-color-palette-memory"><a class="header" href="#system-color-palette-memory">System Color Palette Memory</a></h2>
<p>Beside for the actually visible palettes, up to 512 palettes of 4 colors
each may be defined in SNES RAM. The palettes are just stored in RAM
without any relationship to the displayed picture; however, these
pre-defined colors may be transferred to actually visible palettes
slightly faster than when transferring palette data by separate command
packets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-summary"><a class="header" href="#command-summary">Command Summary</a></h1>
<h2 id="sgb-system-command-table"><a class="header" href="#sgb-system-command-table">SGB System Command Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Name</th><th>Explanation</th></tr></thead><tbody>
<tr><td>$00</td><td><a href="#sgb-command-00--pal01">PAL01</a></td><td>Set SGB Palette 0 &amp; 1</td></tr>
<tr><td>$01</td><td><a href="#sgb-command-01--pal23">PAL23</a></td><td>Set SGB Palette 2 &amp; 3</td></tr>
<tr><td>$02</td><td><a href="#sgb-command-02--pal03">PAL03</a></td><td>Set SGB Palette 0 &amp; 3</td></tr>
<tr><td>$03</td><td><a href="#sgb-command-03--pal12">PAL12</a></td><td>Set SGB Palette 1 &amp; 2</td></tr>
<tr><td>$04</td><td><a href="#sgb-command-04--attr_blk">ATTR_BLK</a></td><td>“Block” Area Designation Mode</td></tr>
<tr><td>$05</td><td><a href="#sgb-command-05--attr_lin">ATTR_LIN</a></td><td>“Line” Area Designation Mode</td></tr>
<tr><td>$06</td><td><a href="#sgb-command-06--attr_div">ATTR_DIV</a></td><td>“Divide” Area Designation Mode</td></tr>
<tr><td>$07</td><td><a href="#sgb-command-07--attr_chr">ATTR_CHR</a></td><td>“1CHR” Area Designation Mode</td></tr>
<tr><td>$08</td><td><a href="#sgb-command-08--sound">SOUND</a></td><td>Sound On/Off</td></tr>
<tr><td>$09</td><td><a href="#sgb-command-09--sou_trn">SOU_TRN</a></td><td>Transfer Sound PRG/DATA</td></tr>
<tr><td>$0A</td><td><a href="#sgb-command-0a--pal_set">PAL_SET</a></td><td>Set SGB Palette Indirect</td></tr>
<tr><td>$0B</td><td><a href="#sgb-command-0b--pal_trn">PAL_TRN</a></td><td>Set System Color Palette Data</td></tr>
<tr><td>$0C</td><td><a href="#sgb-command-0c--atrc_en">ATRC_EN</a></td><td>Enable/disable Attraction Mode</td></tr>
<tr><td>$0D</td><td><a href="#sgb-command-0d--test_en">TEST_EN</a></td><td>Speed Function</td></tr>
<tr><td>$0E</td><td><a href="#sgb-command-0e--icon_en">ICON_EN</a></td><td>SGB Function</td></tr>
<tr><td>$0F</td><td><a href="#sgb-command-0f--data_snd">DATA_SND</a></td><td>SUPER NES WRAM Transfer 1</td></tr>
<tr><td>$10</td><td><a href="#sgb-command-10--data_trn">DATA_TRN</a></td><td>SUPER NES WRAM Transfer 2</td></tr>
<tr><td>$11</td><td><a href="#sgb-command-11--mlt_req">MLT_REQ</a></td><td>Multiple Controllers Request</td></tr>
<tr><td>$12</td><td><a href="#sgb-command-12--jump">JUMP</a></td><td>Set SNES Program Counter</td></tr>
<tr><td>$13</td><td><a href="#sgb-command-13--chr_trn">CHR_TRN</a></td><td>Transfer Character Font Data</td></tr>
<tr><td>$14</td><td><a href="#sgb-command-14--pct_trn">PCT_TRN</a></td><td>Set Screen Data Color Data</td></tr>
<tr><td>$15</td><td><a href="#sgb-command-15--attr_trn">ATTR_TRN</a></td><td>Set Attribute from ATF</td></tr>
<tr><td>$16</td><td><a href="#sgb-command-16--attr_set">ATTR_SET</a></td><td>Set Data to ATF</td></tr>
<tr><td>$17</td><td><a href="#sgb-command-17--mask_en">MASK_EN</a></td><td>Game Boy Window Mask</td></tr>
<tr><td>$18</td><td><a href="#sgb-command-18--obj_trn">OBJ_TRN</a></td><td>Super NES OBJ Mode</td></tr>
<tr><td>$19</td><td><a href="#sgb-command-19--pal_pri">PAL_PRI</a></td><td>System palette priority</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="palette-commands"><a class="header" href="#palette-commands">Palette Commands</a></h1>
<h2 id="sgb-command-00--pal01"><a class="header" href="#sgb-command-00--pal01">SGB Command $00 — PAL01</a></h2>
<p>Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1,
color 1-3 (without separate color 0).</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=01h)
 1-E   Color Data for 7 colors of 2 bytes (16 bits) each:
         Bit 0-4   - Red Intensity   (0-31)
         Bit 5-9   - Green Intensity (0-31)
         Bit 10-14 - Blue Intensity  (0-31)
         Bit 15    - Not used (zero)
 F     Not used (00h)
</code></pre>
<p>This is the same RGB5 format as <a href="#lcd-color-palettes-cgb-only">Game Boy Color palette
entry</a>, though
without the LCD correction. The value transferred as color 0 will be
applied for all four palettes.</p>
<h2 id="sgb-command-01--pal23"><a class="header" href="#sgb-command-01--pal23">SGB Command $01 — PAL23</a></h2>
<p>Same as above PAL01, but for Palettes 2 and 3 respectively.</p>
<h2 id="sgb-command-02--pal03"><a class="header" href="#sgb-command-02--pal03">SGB Command $02 — PAL03</a></h2>
<p>Same as above PAL01, but for Palettes 0 and 3 respectively.</p>
<h2 id="sgb-command-03--pal12"><a class="header" href="#sgb-command-03--pal12">SGB Command $03 — PAL12</a></h2>
<p>Same as above PAL01, but for Palettes 1 and 2 respectively.</p>
<h2 id="sgb-command-0a--pal_set"><a class="header" href="#sgb-command-0a--pal_set">SGB Command $0A — PAL_SET</a></h2>
<p>Used to copy pre-defined palette data from SGB system color palettes to
actual SNES palettes.</p>
<p>Note: all palette numbers are little-endian.</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1-2   System Palette number for SGB Color Palette 0 (0-511)
 3-4   System Palette number for SGB Color Palette 1 (0-511)
 5-6   System Palette number for SGB Color Palette 2 (0-511)
 7-8   System Palette number for SGB Color Palette 3 (0-511)
 9     Attribute File
         Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
         Bit 6   - Cancel Mask           (0=No change, 1=Yes)
         Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
 A-F   Not used (zero)
</code></pre>
<p>Before using this function, System Palette data should be initialized by
PAL_TRN command, and (when used) Attribute File data should be
initialized by ATTR_TRN.</p>
<h2 id="sgb-command-0b--pal_trn"><a class="header" href="#sgb-command-0b--pal_trn">SGB Command $0B — PAL_TRN</a></h2>
<p>Used to initialize SGB system color palettes in SNES RAM. System color
palette memory contains 512 pre-defined palettes, these palettes do not
directly affect the display, however, the PAL_SET command may be later
used to transfer four of these “logical” palettes to actual visible
“physical” SGB palettes. Also, the OBJ_TRN function will use groups
of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16
colors).</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1-F   Not used (zero)
</code></pre>
<p>The palette data is sent by VRAM-Transfer (4 KBytes).</p>
<pre><code> 000-FFF  Data for System Color Palette 0-511
</code></pre>
<p>Each Palette consists of four 16-bit color definitions (8 bytes). Note:
The data is stored at 3000h-3FFFh in SNES memory.</p>
<h2 id="sgb-command-19--pal_pri"><a class="header" href="#sgb-command-19--pal_pri">SGB Command $19 — PAL_PRI</a></h2>
<p>If the player overrides the active palette set (a pre-defined or the custom one), it stays in effect until the smiley face is selected again, or the player presses the X button on their SNES controller.</p>
<p>However, if <code>PAL_PRI</code> is enabled, then changing the palette set (via any of the above commands except <code>PAL_TRN</code>) will switch back to the game’s newly-modified palette set, if it wasn’t already active.</p>
<p><em>Donkey Kong</em> (1994) is one known game that appears to use this.</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1     Palette priority when a palette packet is sent
         Bit 0 - Priority (0=User, 1=Software)
 2-F   Not used (zero)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color-attribute-commands"><a class="header" href="#color-attribute-commands">Color Attribute Commands</a></h1>
<h2 id="sgb-command-04--attr_blk"><a class="header" href="#sgb-command-04--attr_blk">SGB Command $04 — ATTR_BLK</a></h2>
<p>Used to specify color attributes for the inside or outside of one or
more rectangular screen regions.</p>
<pre><code> Byte  Content
 0     Command*8+Length (length=1..7)
 1     Number of Data Sets (01h..12h)
 2-7   Data Set #1
         Byte 0 - Control Code (0-7)
           Bit 0 - Change Colors inside of surrounded area     (1=Yes)
           Bit 1 - Change Colors of surrounding character line (1=Yes)
           Bit 2 - Change Colors outside of surrounded area    (1=Yes)
           Bit 3-7 - Not used (zero)
           Exception: When changing only the Inside or Outside, then the
           Surrounding line becomes automatically changed to same color.
         Byte 1 - Color Palette Designation
           Bit 0-1 - Palette Number for inside of surrounded area
           Bit 2-3 - Palette Number for surrounding character line
           Bit 4-5 - Palette Number for outside of surrounded area
           Bit 6-7 - Not used (zero)
         Data Set Byte 2 - Coordinate X1 (left)
         Data Set Byte 3 - Coordinate Y1 (upper)
         Data Set Byte 4 - Coordinate X2 (right)
         Data Set Byte 5 - Coordinate Y2 (lower)
           Specifies the coordinates of the surrounding rectangle.
 8-D   Data Set #2 (if any)
 E-F   Data Set #3 (continued at 0-3 in next packet) (if any)
</code></pre>
<p>When sending three or more data sets, data is continued in further
packet(s). Unused bytes at the end of the last packet should be set to
zero. The format of the separate Data Sets is described below.</p>
<h2 id="sgb-command-05--attr_lin"><a class="header" href="#sgb-command-05--attr_lin">SGB Command $05 — ATTR_LIN</a></h2>
<p>Used to specify color attributes of one or more horizontal or vertical
character lines.</p>
<pre><code> Byte  Content
 0     Command*8+Length (length=1..7)
 1     Number of Data Sets (01h..6Eh) (one byte each)
 2     Data Set #1
         Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
         Bit 5-6 - Palette Number (0-3)
         Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
 3     Data Set #2 (if any)
 4     Data Set #3 (if any)
 etc.
</code></pre>
<p>When sending 15 or more data sets, data is continued in further
packet(s). Unused bytes at the end of the last packet should be set to
zero. The format of the separate Data Sets (one byte each) is described
below. The length of each line reaches from one end of the screen to the
other end. In case that some lines overlap each other, then lines from
lastmost data sets will overwrite lines from previous data sets.</p>
<h2 id="sgb-command-06--attr_div"><a class="header" href="#sgb-command-06--attr_div">SGB Command $06 — ATTR_DIV</a></h2>
<p>Used to split the screen into two halfes, and to assign separate color
attributes to each half, and to the division line between them.</p>
<pre><code> Byte  Content
 0     Command*8+Length   (fixed length=1)
 1     Color Palette Numbers and H/V Mode Bit
         Bit 0-1  Palette Number below/right of division line
         Bit 2-3  Palette Number above/left of division line
         Bit 4-5  Palette Number for division line
         Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
 2     X- or Y-Coordinate (depending on H/V bit)
 3-F   Not used (zero)
</code></pre>
<h2 id="sgb-command-07--attr_chr"><a class="header" href="#sgb-command-07--attr_chr">SGB Command $07 — ATTR_CHR</a></h2>
<p>Used to specify color attributes for separate characters.</p>
<pre><code> Byte  Content
 0     Command*8+Length (length=1..6)
 1     Beginning X-Coordinate
 2     Beginning Y-Coordinate
 3-4   Number of Data Sets (1-360)
 5     Writing Style   (0=Left to Right, 1=Top to Bottom)
 6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
 7     Data Sets 5-8   (if any)
 8     Data Sets 9-12  (if any)
 etc.
</code></pre>
<p>When sending 41 or more data sets, data is continued in further
packet(s). Unused bytes at the end of the last packet should be set to
zero. Each data set consists of two bits, indicating the palette number
for one character. Depending on the writing style, data sets are written
from left to right, or from top to bottom. In either case the function
wraps to the next row/column when reaching the end of the screen.</p>
<h2 id="sgb-command-15--attr_trn"><a class="header" href="#sgb-command-15--attr_trn">SGB Command $15 — ATTR_TRN</a></h2>
<p>Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists
of 20x18 color attributes for the Game Boy screen. This function does not
directly affect display attributes. Instead, one of the defined ATFs may
be copied to actual display memory at a later time by using ATTR_SET or
PAL_SET functions.</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1-F   Not used (zero)
</code></pre>
<p>The ATF data is sent by VRAM-Transfer (4 KBytes).</p>
<pre><code> 000-FD1  Data for ATF0 through ATF44 (4050 bytes)
 FD2-FFF  Not used
</code></pre>
<p>Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of
the 18 character lines of the Game Boy window. The two most significant
bits of the first byte define the color attribute (0-3) for the first
character of the first line, the next two bits the next character, and
so on.</p>
<h2 id="sgb-command-16--attr_set"><a class="header" href="#sgb-command-16--attr_set">SGB Command $16 — ATTR_SET</a></h2>
<p>Used to transfer attributes from Attribute File (ATF) to Game Boy window.</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
 2-F   Not used (zero)
</code></pre>
<p>When above Bit 6 is set, the Game Boy screen becomes re-enabled after the
transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET
commands, as described in the chapter about Color Palette Commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-functions-1"><a class="header" href="#sound-functions-1">Sound Functions</a></h1>
<h2 id="sgb-command-08--sound"><a class="header" href="#sgb-command-08--sound">SGB Command $08 — SOUND</a></h2>
<p>Used to start/stop internal sound effect, start/stop sound using
internal tone data.</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1     Sound Effect A (Port 1) Decrescendo 8-bit Sound Code
 2     Sound Effect B (Port 2) Sustain     8-bit Sound Code
 3     Sound Effect Attributes
         Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
         Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
         Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
         Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
 4     Music Score Code (must be zero if not used)
 5-F   Not used (zero)
</code></pre>
<p>See Sound Effect Tables below for a list of available pre-defined
effects.</p>
<p>Notes:</p>
<ol>
<li>Mute is only active when both bits D2 and D3 are 1.</li>
<li>When the volume is set for either Sound Effect A or Sound Effect B,
mute is turned off.</li>
<li>When Mute on/off has been executed, the sound fades out/fades in.</li>
<li>Mute on/off operates on the (BGM) which is reproduced by Sound
Effect A, Sound Effect B, and the Super NES APU. A “mute off” flag
does not exist by itself. When mute flag is set, volume and pitch of
Sound Effect A (port 1) and Sound Effect B (port 2) must be set.</li>
</ol>
<h2 id="sgb-command-09--sou_trn"><a class="header" href="#sgb-command-09--sou_trn">SGB Command $09 — SOU_TRN</a></h2>
<p>Used to transfer sound code or data to SNES Audio Processing Unit memory
(APU-RAM).</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1-F   Not used (zero)
</code></pre>
<p>The sound code/data is sent by <a href="#vram-transfers">VRAM transfer</a> as a contiguous list of “packets”.</p>
<p>All 16-bit values are little-endian.</p>
<p>Data transfer packet format:</p>
<pre><code> 0-1    Size of data below (N); if zero, this is instead a jump packet
 2-3    Destination address in S-APU RAM (typically $2B00, see below)
 4-N+3  Data to be transferred
</code></pre>
<p>Jump packet format:</p>
<pre><code> 0-1  Must be $0000
 2-3  S-APU jump address, use $0400 to safely restart the built-in SGB BIOS' N-SPC sound engine
</code></pre>
<p>Possible destinations in APU-RAM are:</p>
<div class="table-wrapper"><table><thead><tr><th>Memory range</th><th>Description</th></tr></thead><tbody>
<tr><td>$0400-2AFF</td><td>APU-RAM Program Area (9.75KBytes)</td></tr>
<tr><td>$2B00-4AFF</td><td>APU-RAM Sound Score Area (8Kbytes)</td></tr>
<tr><td>$4DB0-EEFF</td><td>APU-RAM Sampling Data Area (40.25 Kbytes)</td></tr>
</tbody></table>
</div>
<p>This function may be used to take control of the SNES sound chip, and/or
to access the SNES MIDI engine. In either case it requires deeper
knowledge of SNES sound programming.</p>
<h2 id="sgb-sound-effect-ab-tables"><a class="header" href="#sgb-sound-effect-ab-tables">SGB Sound Effect A/B Tables</a></h2>
<p>Below lists the digital sound effects that are pre-defined in the
SGB BIOS, and which can be used with the SGB “SOUND” Command.
Effect A and B may be simultaneously used.
Sound Effect A uses channels 6 and 7, Sound Effect B uses channels
0, 1, 4 and 5. Effects that use less channels will use only the upper channels
(eg. 4 and 5 for a B Effect with only two channels).</p>
<h2 id="sound-effect-a-flag-table"><a class="header" href="#sound-effect-a-flag-table">Sound Effect A Flag Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Description</th><th>Recommended pitch</th><th>Nb of channels used</th></tr></thead><tbody>
<tr><td>00</td><td>Dummy flag, re-trigger</td><td>-</td><td>2</td></tr>
<tr><td>01</td><td>Nintendo</td><td>3</td><td>1</td></tr>
<tr><td>02</td><td>Game Over</td><td>3</td><td>2</td></tr>
<tr><td>03</td><td>Drop</td><td>3</td><td>1</td></tr>
<tr><td>04</td><td>OK … A</td><td>3</td><td>2</td></tr>
<tr><td>05</td><td>OK … B</td><td>3</td><td>2</td></tr>
<tr><td>06</td><td>Select…A</td><td>3</td><td>2</td></tr>
<tr><td>07</td><td>Select…B</td><td>3</td><td>1</td></tr>
<tr><td>08</td><td>Select…C</td><td>2</td><td>2</td></tr>
<tr><td>09</td><td>Mistake…Buzzer</td><td>2</td><td>1</td></tr>
<tr><td>0A</td><td>Catch Item</td><td>2</td><td>2</td></tr>
<tr><td>0B</td><td>Gate squeaks 1 time</td><td>2</td><td>2</td></tr>
<tr><td>0C</td><td>Explosion…small</td><td>1</td><td>2</td></tr>
<tr><td>0D</td><td>Explosion…medium</td><td>1</td><td>2</td></tr>
<tr><td>0E</td><td>Explosion…large</td><td>1</td><td>2</td></tr>
<tr><td>0F</td><td>Attacked…A</td><td>3</td><td>1</td></tr>
<tr><td>10</td><td>Attacked…B</td><td>3</td><td>2</td></tr>
<tr><td>11</td><td>Hit (punch)…A</td><td>0</td><td>2</td></tr>
<tr><td>12</td><td>Hit (punch)…B</td><td>0</td><td>2</td></tr>
<tr><td>13</td><td>Breath in air</td><td>3</td><td>2</td></tr>
<tr><td>14</td><td>Rocket Projectile…A</td><td>3</td><td>2</td></tr>
<tr><td>15</td><td>Rocket Projectile…B</td><td>3</td><td>2</td></tr>
<tr><td>16</td><td>Escaping Bubble</td><td>2</td><td>1</td></tr>
<tr><td>17</td><td>Jump</td><td>3</td><td>1</td></tr>
<tr><td>18</td><td>Fast Jump</td><td>3</td><td>1</td></tr>
<tr><td>19</td><td>Jet (rocket) takeoff</td><td>0</td><td>1</td></tr>
<tr><td>1A</td><td>Jet (rocket) landing</td><td>0</td><td>1</td></tr>
<tr><td>1B</td><td>Cup breaking</td><td>2</td><td>2</td></tr>
<tr><td>1C</td><td>Glass breaking</td><td>1</td><td>2</td></tr>
<tr><td>1D</td><td>Level UP</td><td>2</td><td>2</td></tr>
<tr><td>1E</td><td>Insert air</td><td>1</td><td>1</td></tr>
<tr><td>1F</td><td>Sword swing</td><td>1</td><td>1</td></tr>
<tr><td>20</td><td>Water falling</td><td>2</td><td>1</td></tr>
<tr><td>21</td><td>Fire</td><td>1</td><td>1</td></tr>
<tr><td>22</td><td>Wall collapsing</td><td>1</td><td>2</td></tr>
<tr><td>23</td><td>Cancel</td><td>1</td><td>2</td></tr>
<tr><td>24</td><td>Walking</td><td>1</td><td>2</td></tr>
<tr><td>25</td><td>Blocking strike</td><td>1</td><td>2</td></tr>
<tr><td>26</td><td>Picture floats on &amp; off</td><td>3</td><td>2</td></tr>
<tr><td>27</td><td>Fade in</td><td>0</td><td>2</td></tr>
<tr><td>28</td><td>Fade out</td><td>0</td><td>2</td></tr>
<tr><td>29</td><td>Window being opened</td><td>1</td><td>2</td></tr>
<tr><td>2A</td><td>Window being closed</td><td>0</td><td>2</td></tr>
<tr><td>2B</td><td>Big Laser</td><td>3</td><td>2</td></tr>
<tr><td>2C</td><td>Stone gate closes/opens</td><td>0</td><td>2</td></tr>
<tr><td>2D</td><td>Teleportation</td><td>3</td><td>1</td></tr>
<tr><td>2E</td><td>Lightning</td><td>0</td><td>2</td></tr>
<tr><td>2F</td><td>Earthquake</td><td>0</td><td>2</td></tr>
<tr><td>30</td><td>Small Laser</td><td>2</td><td>2</td></tr>
<tr><td>80</td><td>Effect A, stop/silent</td><td>-</td><td>2</td></tr>
</tbody></table>
</div>
<p>Sound effect A is used for formanto sounds (percussion sounds).</p>
<h2 id="sound-effect-b-flag-table"><a class="header" href="#sound-effect-b-flag-table">Sound Effect B Flag Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Description</th><th>Recommended pitch</th><th>Nb of channels used</th></tr></thead><tbody>
<tr><td>00</td><td>Dummy flag, re-trigger</td><td>-</td><td>4</td></tr>
<tr><td>01</td><td>Applause…small group</td><td>2</td><td>1</td></tr>
<tr><td>02</td><td>Applause…medium group</td><td>2</td><td>2</td></tr>
<tr><td>03</td><td>Applause…large group</td><td>2</td><td>4</td></tr>
<tr><td>04</td><td>Wind</td><td>1</td><td>2</td></tr>
<tr><td>05</td><td>Rain</td><td>1</td><td>1</td></tr>
<tr><td>06</td><td>Storm</td><td>1</td><td>3</td></tr>
<tr><td>07</td><td>Storm with wind/thunder</td><td>2</td><td>4</td></tr>
<tr><td>08</td><td>Lightning</td><td>0</td><td>2</td></tr>
<tr><td>09</td><td>Earthquake</td><td>0</td><td>2</td></tr>
<tr><td>0A</td><td>Avalanche</td><td>0</td><td>2</td></tr>
<tr><td>0B</td><td>Wave</td><td>0</td><td>1</td></tr>
<tr><td>0C</td><td>River</td><td>3</td><td>2</td></tr>
<tr><td>0D</td><td>Waterfall</td><td>2</td><td>2</td></tr>
<tr><td>0E</td><td>Small character running</td><td>3</td><td>1</td></tr>
<tr><td>0F</td><td>Horse running</td><td>3</td><td>1</td></tr>
<tr><td>10</td><td>Warning sound</td><td>1</td><td>1</td></tr>
<tr><td>11</td><td>Approaching car</td><td>0</td><td>1</td></tr>
<tr><td>12</td><td>Jet flying</td><td>1</td><td>1</td></tr>
<tr><td>13</td><td>UFO flying</td><td>2</td><td>1</td></tr>
<tr><td>14</td><td>Electromagnetic waves</td><td>0</td><td>1</td></tr>
<tr><td>15</td><td>Score UP</td><td>3</td><td>1</td></tr>
<tr><td>16</td><td>Fire</td><td>2</td><td>1</td></tr>
<tr><td>17</td><td>Camera shutter, formanto</td><td>3</td><td>4</td></tr>
<tr><td>18</td><td>Write, formanto</td><td>0</td><td>1</td></tr>
<tr><td>19</td><td>Show up title, formanto</td><td>0</td><td>1</td></tr>
<tr><td>80</td><td>Effect B, stop/silent</td><td>-</td><td>4</td></tr>
</tbody></table>
</div>
<p>Sound effect B is mainly used for looping sounds (sustained sounds).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-control-commands"><a class="header" href="#system-control-commands">System Control Commands</a></h1>
<h2 id="sgb-command-17--mask_en"><a class="header" href="#sgb-command-17--mask_en">SGB Command $17 — MASK_EN</a></h2>
<p>Used to mask the Game Boy window, among others this can be used to freeze
the Game Boy screen before transferring data through VRAM (the SNES then
keeps displaying the Game Boy screen, even though VRAM doesn’t contain
meaningful display information during the transfer).</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1     Game Boy Screen Mask (0-3)
         0  Cancel Mask   (Display activated)
         1  Freeze Screen (Keep displaying current picture)
         2  Blank Screen  (Black)
         3  Blank Screen  (Color 0)
 2-F   Not used (zero)
</code></pre>
<p>Freezing works only if the SNES has stored a picture, that is, if necessary
wait one or two frames before freezing (rather than freezing directly
after having displayed the picture). The Cancel Mask function may be
also invoked (optionally) by completion of PAL_SET and ATTR_SET
commands.</p>
<h2 id="sgb-command-0c--atrc_en"><a class="header" href="#sgb-command-0c--atrc_en">SGB Command $0C — ATRC_EN</a></h2>
<p>Used to enable/disable Attraction mode, which is enabled by default.</p>
<p>Built-in borders other than the Game Boy frame and the plain black
border have a “screen saver” activated by pressing R, L, L, L, L, R or
by leaving the controller alone for roughly 7 minutes (tested with 144p
Test Suite). It is speculated that the animation may have interfered
with rarely-used SGB features, such as OBJ_TRN or JUMP, and that
Attraction Disable disables this animation.</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1     Attraction Disable  (0=Enable, 1=Disable)
 2-F   Not used (zero)
</code></pre>
<h2 id="sgb-command-0d--test_en"><a class="header" href="#sgb-command-0d--test_en">SGB Command $0D — TEST_EN</a></h2>
<p>Used to enable/disable test mode for “SGB-CPU variable clock speed
function”. This function is disabled by default.</p>
<p>This command does nothing on some SGB revisions. (SGBv2 confirmed,
unknown on others)</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1     Test Mode Enable    (0=Disable, 1=Enable)
 2-F   Not used (zero)
</code></pre>
<p>Maybe intended to determine whether SNES operates at 50Hz or 60Hz
display refresh rate ??? Possibly result can be read-out from joypad
register ???</p>
<h2 id="sgb-command-0e--icon_en"><a class="header" href="#sgb-command-0e--icon_en">SGB Command $0E — ICON_EN</a></h2>
<p>Used to enable/disable ICON function. Possibly meant to enable/disable
SGB/SNES popup menues which might otherwise activated during Game Boy
game play. By default all functions are enabled (0).</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1     Disable Bits
         Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
         Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
         Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
         Bit 3-6 - Not used (zero)
 2-F   Not used (zero)
</code></pre>
<p>Above Bit 2 will suppress all further packets/commands when set, this
might be useful when starting a monochrome game from inside of the
SGB-menu of a multi-gamepak which contains a collection of different
games.</p>
<h2 id="sgb-command-0f--data_snd"><a class="header" href="#sgb-command-0f--data_snd">SGB Command $0F — DATA_SND</a></h2>
<p>Used to write one or more bytes directly into SNES Work RAM.</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1     SNES Destination Address, low
 2     SNES Destination Address, high
 3     SNES Destination Address, bank number
 4     Number of bytes to write (01h-0Bh)
 5     Data Byte #1
 6     Data Byte #2 (if any)
 7     Data Byte #3 (if any)
 etc.
</code></pre>
<p>Unused bytes at the end of the packet should be set to zero, this
function is restricted to a single packet, so that not more than 11
bytes can be defined at once. Free Addresses in SNES memory are Bank 0
1800h-1FFFh, Bank 7Fh 0000h-FFFFh.</p>
<h2 id="sgb-command-10--data_trn"><a class="header" href="#sgb-command-10--data_trn">SGB Command $10 — DATA_TRN</a></h2>
<p>Used to transfer binary code or data directly into SNES RAM.</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1     SNES Destination Address, low
 2     SNES Destination Address, high
 3     SNES Destination Address, bank number
 4-F   Not used (zero)
</code></pre>
<p>The data is sent by VRAM-Transfer (4 KBytes).</p>
<pre><code> 000-FFF  Data
</code></pre>
<p>Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh
0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that
directly writing to the free 2KBytes at 0:1800h would be a not so good
idea ???</p>
<h2 id="sgb-command-12--jump"><a class="header" href="#sgb-command-12--jump">SGB Command $12 — JUMP</a></h2>
<p>Used to set the SNES program counter and NMI (vblank interrupt) handler
to specific addresses.</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1     SNES Program Counter, low
 2     SNES Program Counter, high
 3     SNES Program Counter, bank number
 4     SNES NMI Handler, low
 5     SNES NMI Handler, high
 6     SNES NMI Handler, bank number
 7-F   Not used, zero
</code></pre>
<p>The game <em>Space Invaders</em> uses this function when selecting “Arcade
mode” to execute SNES program code which has been previously
transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22,
which combines a 65C816 core licensed from WDC with a custom memory
controller. For more information, see <a href="https://problemkaputt.de/fullsnes.htm">“fullsnes” by
nocash</a>.</p>
<p>Some notes for intrepid Super NES programmers seeking to use a flash
cartridge in a Super Game Boy as a storage server:</p>
<ul>
<li>JUMP overwrites the NMI handler even if it is $000000.</li>
<li>The SGB system software does not appear to use NMIs.</li>
<li>JUMP can return to SGB system software via a 16-bit RTS. To do this,
JML to a location in bank $00 containing byte value $60, such as
any of the <a href="#stubbed-commands">stubbed commands</a>.</li>
<li>IRQs and COP and BRK instructions are not useful because their
handlers still point into SGB ROM. Use SEI WAI.</li>
<li>If a program called through JUMP does not intend to return to SGB
system software, it can overwrite all Super NES RAM except $0000BB
through $0000BD, the NMI vector.</li>
<li>To enter APU boot ROM, write $FE to $2140. Echo will still be on
though.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiplayer-command"><a class="header" href="#multiplayer-command">Multiplayer Command</a></h1>
<h2 id="sgb-command-11--mlt_req"><a class="header" href="#sgb-command-11--mlt_req">SGB Command $11 — MLT_REQ</a></h2>
<p>Used to request multiplayer mode (that is, input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the Game
Boy program, it can also be used to detect SGB hardware.</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
         0 = One player
         1 = Two players
         3 = Four players
 2-F   Not used (zero)
</code></pre>
<p>In one-player mode, the second joypad (if any) can only be used for
the SGB BIOS. In two-player mode, both joypads are used for the game.
Because SNES only has two joypad sockets, four-player mode requires an
external “Multiplayer 5” adapter.</p>
<p>Changing the number of active players ANDs the currently selected player
minus one with the number of players in that mode minus one. For example,
if you go from four players to two players while player 4 was active,
player 2 will then be active because <code>3 &amp; 1 = 1</code>. However, sending the
<code>MLT_REQ</code> command will increment the counter several times so results may
not be exactly as expected. The most frequent case is going from one
player to two-or-four player which will always start with player 1
active.</p>
<h2 id="reading-multiple-controllers-joypads"><a class="header" href="#reading-multiple-controllers-joypads">Reading Multiple Controllers (Joypads)</a></h2>
<p>When having enabled multiple controllers by <code>MLT_REQ</code>, data for each
joypad can be read out through <a href="#ff00--p1joyp-joypad">the <code>P1</code> register</a> as follows: First
set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you
can now read the lower 4 bits of <code>P1</code>, which indicate the joypad ID for
the following joypad input:</p>
<div class="table-wrapper"><table><thead><tr><th>Byte</th><th>Player #</th></tr></thead><tbody>
<tr><td>$xF</td><td>1</td></tr>
<tr><td>$xE</td><td>2</td></tr>
<tr><td>$xD</td><td>3</td></tr>
<tr><td>$xC</td><td>4</td></tr>
</tbody></table>
</div>
<p>Next, read joypad state normally.
The next joypad is automatically selected when P15 goes from LOW (0) to HIGH (1) (<a href="https://github.com/CasualPokePlayer/test-roms/blob/sgb-mlt-test/src/intro.asm">source</a>), so you can simply repeat reading the joypad state normally until all two (or four) joypads have been read out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="border-and-obj-commands"><a class="header" href="#border-and-obj-commands">Border and OBJ Commands</a></h1>
<h2 id="sgb-command-13--chr_trn"><a class="header" href="#sgb-command-13--chr_trn">SGB Command $13 — CHR_TRN</a></h2>
<p>Used to transfer tile data (characters) to SNES Tile memory in VRAM.
This normally used to define BG tiles for the SGB Border (see PCT_TRN),
but might be also used to define moveable SNES foreground sprites (see
OBJ_TRN).</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1     Tile Transfer Destination
         Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
         Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
         Bit 2-7 - Not used (zero)
 2-F   Not used (zero)
</code></pre>
<p>The tile data is sent by VRAM-Transfer (4 KBytes).</p>
<pre><code> 000-FFF  Bitmap data for 128 Tiles
</code></pre>
<p>Each tile occupies 32 bytes (8x8 pixels, 16 colors each). When intending
to transfer more than 128 tiles, call this function twice (once for
tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems
to have no effect and writes to the same VRAM addresses for both BG and
OBJ ???</p>
<p>Each tile is stored in 4-bit-per-pixel format consisting of bit planes 0 and 1 interleaved by row, followed by bit planes 2 and 3 interleaved by row.
In effect, each tile consists of two Game Boy tiles, the first to determine bits 0 and 1 (choosing among color 0, 1, 2, or 3 within a 4-color subpalette), and the second to determine bits 2 and 3 (choosing among colors 0-3, 4-7, 8-11, or 12-15).</p>
<h2 id="sgb-command-14--pct_trn"><a class="header" href="#sgb-command-14--pct_trn">SGB Command $14 — PCT_TRN</a></h2>
<p>Used to transfer tile map data and palette data to SNES BG Map memory in
VRAM to be used for the SGB border. The actual tiles must be separately
transferred by using the CHR_TRN function.</p>
<pre><code> Byte  Content
 0     Command*8+Length    (fixed length=1)
 1-F   Not used (zero)
</code></pre>
<p>The map data is sent by VRAM-Transfer (4 KBytes).</p>
<pre><code> 000-6FF  BG Map 32x28 Entries of 16 bits each (1792 bytes)
 700-7FF  Not used, don't care
 800-85F  BG Palette Data (Palettes 4-6, 16 little-endian RGB555 colors each)
 860-FFF  Not used, don't care
</code></pre>
<p>Each BG Map Entry consists of a 16-bit value as such:
`VH01 PP00 NNNN NNNN```</p>
<pre><code> Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
 Bit 10-12 - Palette Number   (use only 4-6)
 Bit 13    - BG Priority      (use only 0)
 Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
 Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)
</code></pre>
<p>The 32x28 map entries correspond to 256x224 pixels of the Super NES
screen. The 20x18 entries in the center of the 32x28 area should be set
to a blank (solid color 0) tile as transparent space for the Game Boy
window to be displayed inside. Non-transparent border data will cover
the Game Boy window (for example, <em>Mario’s Picross</em> does this, as does
<em>WildSnake</em> to a lesser extent).</p>
<p>A border designed for a modern (post-2006) widescreen television may use the center 256×176 pixels and leave the top and bottom 24 lines blank.
Using letterbox allows more tile variety in the portion of the border that a widescreen TV’s zoom mode does not cut off.</p>
<p>All borders repeat tiles. Assuming that the blank space for the GB
screen is a blank tile, and the letterbox (if any) is a solid tile, a
border defining all unique tiles would have to define this many tiles:</p>
<ul>
<li>(256*224-160*144)/64+1 = 537 tiles in full-screen border</li>
<li>(256*176-160*144)/64+2 = 346 tiles in letterboxed border</li>
</ul>
<p>Because the CHR RAM allocated by SGB for border holds only 256 tiles, a full-screen border must repeat at least 281 tiles and a letterboxed border at least 90.</p>
<p>The Super NES supports 8 background palettes.
The SGB system software (when run in a LLE such as Mesen-S) has been observed to use background palette 0 for the GB screen, palettes 1, 2, 3, and 7 for the menus, and palettes 4, 5, and 6 for the border.
Thus a border can use three 15-color palettes.</p>
<h2 id="sgb-command-18--obj_trn"><a class="header" href="#sgb-command-18--obj_trn">SGB Command $18 — OBJ_TRN</a></h2>
<p>Used to transfer OBJ attributes to SNES OAM memory. Unlike all other
functions with the ending _TRN, this function does not use the usual
one-shot 4KBytes VRAM transfer method. Instead, when enabled (below
execute bit set), data is permanently (each frame) read out from the
lower character line of the Game Boy screen. To suppress garbage on the
display, the lower line is masked, and only the upper 20x17 characters
of the Game Boy window are used - the masking method is unknwon - frozen,
black, or recommended to be covered by the SGB border, or else ??? Also,
when the function is enabled, “system attract mode is not performed” -
whatever that means ???</p>
<p>This command does nothing on some SGB revisions. (SGBv2, SGB2?)</p>
<pre><code> Byte  Content
 0     Command*8+Length (fixed length=1)
 1     Control Bits
         Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
         Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
         Bit 2-7 - Not used (zero)
 2-3   System Color Palette Number for OBJ Palette 4 (0-511)
 4-5   System Color Palette Number for OBJ Palette 5 (0-511)
 6-7   System Color Palette Number for OBJ Palette 6 (0-511)
 8-9   System Color Palette Number for OBJ Palette 7 (0-511)
         These color entries are ignored if above Control Bit 1 is zero.
         Because each OBJ palette consists of 16 colors, four system
         palette entries (of 4 colors each) are transferred into each
         OBJ palette. The system palette numbers are not required to be
         aligned to a multiple of four, and will wrap to palette number
         0 when exceeding 511. For example, a value of 511 would copy
         system palettes 511, 0, 1, 2 to the SNES OBJ palette.
 A-F   Not used (zero)
</code></pre>
<p>The recommended method is to “display” Game Boy BG tiles F9h..FFh from
left to right as first 7 characters of the bottom-most character line of
the Game Boy screen. As for normal 4KByte VRAM transfers, this area
should not be scrolled, should not be overlapped by Game Boy OBJs, and
the Game Boy BGP palette register should be set up properly. By following
that method, SNES OAM data can be defined in the 70h bytes of the
Game Boy BG tile memory at following addresses:</p>
<pre><code> 8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
 8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
 8FF6-8FFF  Not used, don't care (10 bytes)
</code></pre>
<p>The format of SNES OAM Entries is:</p>
<pre><code>  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)
</code></pre>
<p>The format of SNES OAM MSB Entries is:</p>
<p>Actually, the format is unknown ??? However, 2 bits are used per entry:
One bit is the most significant bit of the OBJ X-Position.
The other bit specifies the OBJ size (8x8 or 16x16 pixels).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="undocumented-sgb-commands"><a class="header" href="#undocumented-sgb-commands">Undocumented SGB commands</a></h1>
<p>The following information has been extracted from disassembling a SGB1v2
firmware; it should be verified on other SGB revisions.</p>
<p>The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This
leaves undocumented commands $1A to $1D inclusive.</p>
<h2 id="stubbed-commands"><a class="header" href="#stubbed-commands">Stubbed commands</a></h2>
<p>Commands $1A to $1F (inclusive)’s handlers are stubs (only contain an
<code>RTS</code>). This is interesting, since the command-processing function
explicitly ignores commands $1E and $1F.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cpu-registers-and-flags"><a class="header" href="#cpu-registers-and-flags">CPU registers and flags</a></h1>
<h2 id="registers"><a class="header" href="#registers">Registers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>16-bit</th><th>Hi</th><th>Lo</th><th>Name/Function</th></tr></thead><tbody>
<tr><td>AF</td><td>A</td><td>-</td><td>Accumulator &amp; Flags</td></tr>
<tr><td>BC</td><td>B</td><td>C</td><td>BC</td></tr>
<tr><td>DE</td><td>D</td><td>E</td><td>DE</td></tr>
<tr><td>HL</td><td>H</td><td>L</td><td>HL</td></tr>
<tr><td>SP</td><td>-</td><td>-</td><td>Stack Pointer</td></tr>
<tr><td>PC</td><td>-</td><td>-</td><td>Program Counter/Pointer</td></tr>
</tbody></table>
</div>
<p>As shown above, most registers can be accessed either as one 16-bit
register, or as two separate 8-bit registers.</p>
<h2 id="the-flags-register-lower-8-bits-of-af-register"><a class="header" href="#the-flags-register-lower-8-bits-of-af-register">The Flags Register (lower 8 bits of AF register)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Bit</th><th>Name</th><th>Explanation</th></tr></thead><tbody>
<tr><td>7</td><td>z</td><td>Zero flag</td></tr>
<tr><td>6</td><td>n</td><td>Subtraction flag (BCD)</td></tr>
<tr><td>5</td><td>h</td><td>Half Carry flag (BCD)</td></tr>
<tr><td>4</td><td>c</td><td>Carry flag</td></tr>
</tbody></table>
</div>
<p>Contains information about the result of the most recent instruction that has affected
flags.</p>
<h2 id="the-zero-flag-z"><a class="header" href="#the-zero-flag-z">The Zero Flag (Z)</a></h2>
<p>This bit is set if and only if the result of an operation is zero. Used by conditional jumps.</p>
<h2 id="the-carry-flag-c-or-cy"><a class="header" href="#the-carry-flag-c-or-cy">The Carry Flag (C, or Cy)</a></h2>
<p>Is set in these cases:</p>
<ul>
<li>When the result of an 8-bit addition is higher than $FF.</li>
<li>When the result of a 16-bit addition is higher than $FFFF.</li>
<li>When the result of a subtraction or comparison
is lower than zero (like in Z80 and 80x86 CPUs, but unlike in
65XX and ARM CPUs).</li>
<li>When a rotate/shift operation shifts out a “1” bit.</li>
</ul>
<p>Used by conditional jumps and
instructions such as ADC, SBC, RL, RLA, etc.</p>
<h2 id="the-bcd-flags-n-h"><a class="header" href="#the-bcd-flags-n-h">The BCD Flags (N, H)</a></h2>
<p>These flags are used by the DAA instruction only. N indicates
whether the previous instruction has been a subtraction,
and H indicates carry for the lower 4 bits of the result. DAA also uses the C flag,
which must indicate carry for the upper 4 bits. After adding/subtracting two
BCD numbers, DAA is used to convert the result to BCD format. BCD
numbers range from $00 to $99 rather than $00 to $FF. Because only two flags
(C and H) exist to indicate carry-outs of BCD digits, DAA is ineffective for
16-bit operations (which have 4 digits), and use for INC/DEC operations
(which do not affect C-flag) has limits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cpu-instruction-set"><a class="header" href="#cpu-instruction-set">CPU Instruction Set</a></h1>
<p>Tables below specify the mnemonic, encoding, clock cycles, affected
flags (ordered as znhc), and description. The timings assume a CPU
clock frequency of 4.194304 MHz (or 8.4 MHz for CGB in double speed
mode), called “T-states”.  Because all Game Boy timings are divisible
by 4, many people specify timings and clock frequency divided by 4,
called “M-cycles”.</p>
<h2 id="8-bit-load-instructions"><a class="header" href="#8-bit-load-instructions">8-bit Load instructions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mnemonic</th><th>Encoding</th><th>Clock cycles</th><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>ld   r,r</td><td>xx</td><td>4</td><td>––</td><td>r=r</td></tr>
<tr><td>ld   r,n</td><td>xx nn</td><td>8</td><td>––</td><td>r=n</td></tr>
<tr><td>ld   r,(HL)</td><td>xx</td><td>8</td><td>––</td><td>r=(HL)</td></tr>
<tr><td>ld   (HL),r</td><td>7x</td><td>8</td><td>––</td><td>(HL)=r</td></tr>
<tr><td>ld   (HL),n</td><td>36 nn</td><td>12</td><td>––</td><td>(HL)=n</td></tr>
<tr><td>ld   A,(BC)</td><td>0A</td><td>8</td><td>––</td><td>A=(BC)</td></tr>
<tr><td>ld   A,(DE)</td><td>1A</td><td>8</td><td>––</td><td>A=(DE)</td></tr>
<tr><td>ld   A,(nn)</td><td>FA</td><td>16</td><td>––</td><td>A=(nn)</td></tr>
<tr><td>ld   (BC),A</td><td>02</td><td>8</td><td>––</td><td>(BC)=A</td></tr>
<tr><td>ld   (DE),A</td><td>12</td><td>8</td><td>––</td><td>(DE)=A</td></tr>
<tr><td>ld   (nn),A</td><td>EA</td><td>16</td><td>––</td><td>(nn)=A</td></tr>
<tr><td>ld   A,(FF00+n)</td><td>F0 nn</td><td>12</td><td>––</td><td>read from io-port n (memory FF00+n)</td></tr>
<tr><td>ld   (FF00+n),A</td><td>E0 nn</td><td>12</td><td>––</td><td>write to io-port n (memory FF00+n)</td></tr>
<tr><td>ld   A,(FF00+C)</td><td>F2</td><td>8</td><td>––</td><td>read from io-port C (memory FF00+C)</td></tr>
<tr><td>ld   (FF00+C),A</td><td>E2</td><td>8</td><td>––</td><td>write to io-port C (memory FF00+C)</td></tr>
<tr><td>ldi  (HL),A</td><td>22</td><td>8</td><td>––</td><td>(HL)=A, HL=HL+1</td></tr>
<tr><td>ldi  A,(HL)</td><td>2A</td><td>8</td><td>––</td><td>A=(HL), HL=HL+1</td></tr>
<tr><td>ldd  (HL),A</td><td>32</td><td>8</td><td>––</td><td>(HL)=A, HL=HL-1</td></tr>
<tr><td>ldd  A,(HL)</td><td>3A</td><td>8</td><td>––</td><td>A=(HL), HL=HL-1</td></tr>
</tbody></table>
</div>
<h2 id="16-bit-load-instructions"><a class="header" href="#16-bit-load-instructions">16-bit Load instructions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mnemonic</th><th>Encoding</th><th>Clock cycles</th><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>ld   rr,nn</td><td>x1 nn nn</td><td>12</td><td>––</td><td>rr=nn (rr may be BC,DE,HL or SP)</td></tr>
<tr><td>ld   (nn),SP</td><td>08 nn nn</td><td>20</td><td>––</td><td>(nn)=SP</td></tr>
<tr><td>ld   SP,HL</td><td>F9</td><td>8</td><td>––</td><td>SP=HL</td></tr>
<tr><td>push rr</td><td>x5</td><td>16</td><td>––</td><td>SP=SP-2  (SP)=rr ; rr may be BC,DE,HL,AF</td></tr>
<tr><td>pop  rr</td><td>x1</td><td>12</td><td>(AF)</td><td>rr=(SP)  SP=SP+2 ; rr may be BC,DE,HL,AF</td></tr>
</tbody></table>
</div>
<h2 id="8-bit-arithmeticlogic-instructions"><a class="header" href="#8-bit-arithmeticlogic-instructions">8-bit Arithmetic/Logic instructions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mnemonic</th><th>Encoding</th><th>Clock cycles</th><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>add  A,r</td><td>8x</td><td>4</td><td>z0hc</td><td>A=A+r</td></tr>
<tr><td>add  A,n</td><td>C6 nn</td><td>8</td><td>z0hc</td><td>A=A+n</td></tr>
<tr><td>add  A,(HL)</td><td>86</td><td>8</td><td>z0hc</td><td>A=A+(HL)</td></tr>
<tr><td>adc  A,r</td><td>8x</td><td>4</td><td>z0hc</td><td>A=A+r+cy</td></tr>
<tr><td>adc  A,n</td><td>CE nn</td><td>8</td><td>z0hc</td><td>A=A+n+cy</td></tr>
<tr><td>adc  A,(HL)</td><td>8E</td><td>8</td><td>z0hc</td><td>A=A+(HL)+cy</td></tr>
<tr><td>sub  r</td><td>9x</td><td>4</td><td>z1hc</td><td>A=A-r</td></tr>
<tr><td>sub  n</td><td>D6 nn</td><td>8</td><td>z1hc</td><td>A=A-n</td></tr>
<tr><td>sub  (HL)</td><td>96</td><td>8</td><td>z1hc</td><td>A=A-(HL)</td></tr>
<tr><td>sbc  A,r</td><td>9x</td><td>4</td><td>z1hc</td><td>A=A-r-cy</td></tr>
<tr><td>sbc  A,n</td><td>DE nn</td><td>8</td><td>z1hc</td><td>A=A-n-cy</td></tr>
<tr><td>sbc  A,(HL)</td><td>9E</td><td>8</td><td>z1hc</td><td>A=A-(HL)-cy</td></tr>
<tr><td>and  r</td><td>Ax</td><td>4</td><td>z010</td><td>A=A &amp; r</td></tr>
<tr><td>and  n</td><td>E6 nn</td><td>8</td><td>z010</td><td>A=A &amp; n</td></tr>
<tr><td>and  (HL)</td><td>A6</td><td>8</td><td>z010</td><td>A=A &amp; (HL)</td></tr>
<tr><td>xor  r</td><td>Ax</td><td>4</td><td>z000</td><td>A=A xor r</td></tr>
<tr><td>xor  n</td><td>EE nn</td><td>8</td><td>z000</td><td>A=A xor n</td></tr>
<tr><td>xor  (HL)</td><td>AE</td><td>8</td><td>z000</td><td>A=A xor (HL)</td></tr>
<tr><td>or   r</td><td>Bx</td><td>4</td><td>z000</td><td>A=A | r</td></tr>
<tr><td>or   n</td><td>F6 nn</td><td>8</td><td>z000</td><td>A=A | n</td></tr>
<tr><td>or   (HL)</td><td>B6</td><td>8</td><td>z000</td><td>A=A | (HL)</td></tr>
<tr><td>cp   r</td><td>Bx</td><td>4</td><td>z1hc</td><td>compare A-r</td></tr>
<tr><td>cp   n</td><td>FE nn</td><td>8</td><td>z1hc</td><td>compare A-n</td></tr>
<tr><td>cp   (HL)</td><td>BE</td><td>8</td><td>z1hc</td><td>compare A-(HL)</td></tr>
<tr><td>inc  r</td><td>xx</td><td>4</td><td>z0h-</td><td>r=r+1</td></tr>
<tr><td>inc  (HL)</td><td>34</td><td>12</td><td>z0h-</td><td>(HL)=(HL)+1</td></tr>
<tr><td>dec  r</td><td>xx</td><td>4</td><td>z1h-</td><td>r=r-1</td></tr>
<tr><td>dec  (HL)</td><td>35</td><td>12</td><td>z1h-</td><td>(HL)=(HL)-1</td></tr>
<tr><td>daa</td><td>27</td><td>4</td><td>z-0c</td><td>decimal adjust A</td></tr>
<tr><td>cpl</td><td>2F</td><td>4</td><td>-11-</td><td>A = A xor FF</td></tr>
</tbody></table>
</div>
<h2 id="16-bit-arithmeticlogic-instructions"><a class="header" href="#16-bit-arithmeticlogic-instructions">16-bit Arithmetic/Logic instructions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mnemonic</th><th>Encoding</th><th>Clock cycles</th><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>add  HL,rr</td><td>x9</td><td>8</td><td>-0hc</td><td>HL = HL+rr     ; rr may be BC,DE,HL,SP</td></tr>
<tr><td>inc  rr</td><td>x3</td><td>8</td><td>––</td><td>rr = rr+1      ; rr may be BC,DE,HL,SP</td></tr>
<tr><td>dec  rr</td><td>xB</td><td>8</td><td>––</td><td>rr = rr-1      ; rr may be BC,DE,HL,SP</td></tr>
<tr><td>add  SP,dd</td><td>E8 dd</td><td>16</td><td>00hc</td><td>SP = SP +/- dd ; dd is 8-bit signed number</td></tr>
<tr><td>ld   HL,SP+dd</td><td>F8 dd</td><td>12</td><td>00hc</td><td>HL = SP +/- dd ; dd is 8-bit signed number</td></tr>
</tbody></table>
</div>
<h2 id="rotate-and-shift-instructions"><a class="header" href="#rotate-and-shift-instructions">Rotate and Shift instructions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mnemonic</th><th>Encoding</th><th>Clock cycles</th><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>rlca</td><td>07</td><td>4</td><td>000c</td><td>rotate A left</td></tr>
<tr><td>rla</td><td>17</td><td>4</td><td>000c</td><td>rotate A left through carry</td></tr>
<tr><td>rrca</td><td>0F</td><td>4</td><td>000c</td><td>rotate A right</td></tr>
<tr><td>rra</td><td>1F</td><td>4</td><td>000c</td><td>rotate A right through carry</td></tr>
<tr><td>rlc  r</td><td>CB 0x</td><td>8</td><td>z00c</td><td>rotate left</td></tr>
<tr><td>rlc  (HL)</td><td>CB 06</td><td>16</td><td>z00c</td><td>rotate left</td></tr>
<tr><td>rl   r</td><td>CB 1x</td><td>8</td><td>z00c</td><td>rotate left through carry</td></tr>
<tr><td>rl   (HL)</td><td>CB 16</td><td>16</td><td>z00c</td><td>rotate left through carry</td></tr>
<tr><td>rrc  r</td><td>CB 0x</td><td>8</td><td>z00c</td><td>rotate right</td></tr>
<tr><td>rrc  (HL)</td><td>CB 0E</td><td>16</td><td>z00c</td><td>rotate right</td></tr>
<tr><td>rr   r</td><td>CB 1x</td><td>8</td><td>z00c</td><td>rotate right through carry</td></tr>
<tr><td>rr   (HL)</td><td>CB 1E</td><td>16</td><td>z00c</td><td>rotate right through carry</td></tr>
<tr><td>sla  r</td><td>CB 2x</td><td>8</td><td>z00c</td><td>shift left arithmetic (b0=0)</td></tr>
<tr><td>sla  (HL)</td><td>CB 26</td><td>16</td><td>z00c</td><td>shift left arithmetic (b0=0)</td></tr>
<tr><td>swap r</td><td>CB 3x</td><td>8</td><td>z000</td><td>exchange low/hi-nibble</td></tr>
<tr><td>swap (HL)</td><td>CB 36</td><td>16</td><td>z000</td><td>exchange low/hi-nibble</td></tr>
<tr><td>sra  r</td><td>CB 2x</td><td>8</td><td>z00c</td><td>shift right arithmetic (b7=b7)</td></tr>
<tr><td>sra  (HL)</td><td>CB 2E</td><td>16</td><td>z00c</td><td>shift right arithmetic (b7=b7)</td></tr>
<tr><td>srl  r</td><td>CB 3x</td><td>8</td><td>z00c</td><td>shift right logical (b7=0)</td></tr>
<tr><td>srl  (HL)</td><td>CB 3E</td><td>16</td><td>z00c</td><td>shift right logical (b7=0)</td></tr>
</tbody></table>
</div>
<h2 id="single-bit-operation-instructions"><a class="header" href="#single-bit-operation-instructions">Single-bit Operation instructions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mnemonic</th><th>Encoding</th><th>Clock cycles</th><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>bit  n,r</td><td>CB xx</td><td>8</td><td>z01-</td><td>test bit n</td></tr>
<tr><td>bit  n,(HL)</td><td>CB xx</td><td>12</td><td>z01-</td><td>test bit n</td></tr>
<tr><td>set  n,r</td><td>CB xx</td><td>8</td><td>––</td><td>set bit n</td></tr>
<tr><td>set  n,(HL)</td><td>CB xx</td><td>16</td><td>––</td><td>set bit n</td></tr>
<tr><td>res  n,r</td><td>CB xx</td><td>8</td><td>––</td><td>reset bit n</td></tr>
<tr><td>res  n,(HL)</td><td>CB xx</td><td>16</td><td>––</td><td>reset bit n</td></tr>
</tbody></table>
</div>
<h2 id="cpu-control-instructions"><a class="header" href="#cpu-control-instructions">CPU Control instructions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mnemonic</th><th>Encoding</th><th>Clock cycles</th><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>ccf</td><td>3F</td><td>4</td><td>-00c</td><td>cy=cy xor 1</td></tr>
<tr><td>scf</td><td>37</td><td>4</td><td>-001</td><td>cy=1</td></tr>
<tr><td>nop</td><td>00</td><td>4</td><td>––</td><td>no operation</td></tr>
<tr><td>halt</td><td>76</td><td>N*4</td><td>––</td><td>halt until interrupt occurs (low power)</td></tr>
<tr><td>stop</td><td>10 00</td><td>?</td><td>––</td><td>low power standby mode (VERY low power)</td></tr>
<tr><td>di</td><td>F3</td><td>4</td><td>––</td><td>disable interrupts, IME=0</td></tr>
<tr><td>ei</td><td>FB</td><td>4</td><td>––</td><td>enable interrupts, IME=1</td></tr>
</tbody></table>
</div>
<h2 id="jump-instructions"><a class="header" href="#jump-instructions">Jump instructions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mnemonic</th><th>Encoding</th><th>Clock cycles</th><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>jp   nn</td><td>C3 nn nn</td><td>16</td><td>––</td><td>jump to nn, PC=nn</td></tr>
<tr><td>jp   HL</td><td>E9</td><td>4</td><td>––</td><td>jump to HL, PC=HL</td></tr>
<tr><td>jp   f,nn</td><td>xx nn nn</td><td>16/12</td><td>––</td><td>conditional jump if nz,z,nc,c</td></tr>
<tr><td>jr   PC+dd</td><td>18 dd</td><td>12</td><td>––</td><td>relative jump to nn (PC=PC+8-bit signed)</td></tr>
<tr><td>jr   f,PC+dd</td><td>xx dd</td><td>12/8</td><td>––</td><td>conditional relative jump if nz,z,nc,c</td></tr>
<tr><td>call nn</td><td>CD nn nn</td><td>24</td><td>––</td><td>call to nn, SP=SP-2, (SP)=PC, PC=nn</td></tr>
<tr><td>call f,nn</td><td>xx nn nn</td><td>24/12</td><td>––</td><td>conditional call if nz,z,nc,c</td></tr>
<tr><td>ret</td><td>C9</td><td>16</td><td>––</td><td>return, PC=(SP), SP=SP+2</td></tr>
<tr><td>ret  f</td><td>xx</td><td>20/8</td><td>––</td><td>conditional return if nz,z,nc,c</td></tr>
<tr><td>reti</td><td>D9</td><td>16</td><td>––</td><td>return and enable interrupts (IME=1)</td></tr>
<tr><td>rst  n</td><td>xx</td><td>16</td><td>––</td><td>call to 00,08,10,18,20,28,30,38</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="cpu-comparison-with-z80"><a class="header" href="#cpu-comparison-with-z80">CPU Comparison with Z80</a></h1>
<h2 id="comparison-with-8080"><a class="header" href="#comparison-with-8080">Comparison with 8080</a></h2>
<p>The Game Boy CPU has a bit more in common with an older Intel 8080 CPU
than the more powerful Zilog Z80 CPU. It is missing a handful of 8080
instructions but does support JR and almost all CB-prefixed
instructions. Also, all known Game Boy assemblers use the more obvious
Z80-style syntax, rather than the chaotic 8080-style syntax.</p>
<p>Unlike the 8080 and Z80, the Game Boy has no dedicated I/O bus and no
IN/OUT opcodes. Instead, I/O ports are accessed directly by normal LD
instructions, or by new LD (FF00+n) opcodes.</p>
<p>The sign and parity/overflow flags have been removed, as have the 12
RET, CALL, and JP instructions conditioned on them. So have EX (SP),HL
(XTHL) and EX DE,HL (XCHG).</p>
<h2 id="comparison-with-z80"><a class="header" href="#comparison-with-z80">Comparison with Z80</a></h2>
<p>In addition to the removed 8080 instructions, the other exchange
instructions have been removed (including total absence of second
register set).</p>
<p>All DD- and FD-prefixed instructions are missing. That means no IX- or
IY-registers.</p>
<p>All ED-prefixed instructions are missing. That means 16-bit memory
accesses are mostly missing, 16-bit arithmetic functions are heavily
cut-down, and some other missing instructions. IN/OUT (C) are replaced with
new LD ($FF00+C) opcodes. Block instructions are gone, but autoincrementing
HL accesses are added.</p>
<p>The Game Boy operates approximately as fast as a 4 MHz Z80 (8 MHz in CGB
double speed mode), with execution time of all instructions having been
rounded up to a multiple of 4 cycles.</p>
<h2 id="moved-removed-and-added-opcodes"><a class="header" href="#moved-removed-and-added-opcodes">Moved, Removed, and Added Opcodes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Opcode</th><th>Z80</th><th>GB CPU</th></tr></thead><tbody>
<tr><td>08</td><td>EX   AF,AF</td><td>LD   (nn),SP</td></tr>
<tr><td>10</td><td>DJNZ PC+dd</td><td>STOP</td></tr>
<tr><td>22</td><td>LD   (nn),HL</td><td>LDI  (HL),A</td></tr>
<tr><td>2A</td><td>LD   HL,(nn)</td><td>LDI  A,(HL)</td></tr>
<tr><td>32</td><td>LD   (nn),A</td><td>LDD  (HL),A</td></tr>
<tr><td>3A</td><td>LD   A,(nn)</td><td>LDD  A,(HL)</td></tr>
<tr><td>D3</td><td>OUT  (n),A</td><td>-</td></tr>
<tr><td>D9</td><td>EXX</td><td>RETI</td></tr>
<tr><td>DB</td><td>IN   A,(n)</td><td>-</td></tr>
<tr><td>DD</td><td>&lt;IX&gt; prefix</td><td>-</td></tr>
<tr><td>E0</td><td>RET  PO</td><td>LD   (FF00+n),A</td></tr>
<tr><td>E2</td><td>JP   PO,nn</td><td>LD   (FF00+C),A</td></tr>
<tr><td>E3</td><td>EX   (SP),HL</td><td>-</td></tr>
<tr><td>E4</td><td>CALL P0,nn</td><td>-</td></tr>
<tr><td>E8</td><td>RET  PE</td><td>ADD  SP,dd</td></tr>
<tr><td>EA</td><td>JP   PE,nn</td><td>LD   (nn),A</td></tr>
<tr><td>EB</td><td>EX   DE,HL</td><td>-</td></tr>
<tr><td>EC</td><td>CALL PE,nn</td><td>-</td></tr>
<tr><td>ED</td><td>&lt;prefix&gt;</td><td>-</td></tr>
<tr><td>F0</td><td>RET  P</td><td>LD   A,(FF00+n)</td></tr>
<tr><td>F2</td><td>JP   P,nn</td><td>LD   A,(FF00+C)</td></tr>
<tr><td>F4</td><td>CALL P,nn</td><td>-</td></tr>
<tr><td>F8</td><td>RET  M</td><td>LD   HL,SP+dd</td></tr>
<tr><td>FA</td><td>JP   M,nn</td><td>LD   A,(nn)</td></tr>
<tr><td>FC</td><td>CALL M,nn</td><td>-</td></tr>
<tr><td>FD</td><td>&lt;IY&gt; prefix</td><td>-</td></tr>
<tr><td>CB 3X</td><td>SLL  r/(HL)</td><td>SWAP r/(HL)</td></tr>
</tbody></table>
</div>
<p>Note: The unused (-) opcodes will lock up the Game Boy CPU when used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-cartridge-header"><a class="header" href="#the-cartridge-header">The Cartridge Header</a></h1>
<p>Each cartridge contains a header, located at the address range <code>$0100</code>—<code>$014F</code>.
The cartridge header provides the following information about the game itself and the hardware it expects to run on:</p>
<h2 id="0100-0103--entry-point"><a class="header" href="#0100-0103--entry-point">0100-0103 — Entry point</a></h2>
<p>After displaying the Nintendo logo, the built-in <a href="#power-up-sequence">boot ROM</a> jumps to the address <code>$0100</code>, which should then jump to the actual main program in the cartridge.
Most commercial games fill this 4-byte area with a <a href="https://rgbds.gbdev.io/docs/v0.5.2/gbz80.7/#NOP"><code>nop</code> instruction</a> followed by a <a href="https://rgbds.gbdev.io/docs/v0.5.2/gbz80.7/#JP_n16"><code>jp $0150</code></a>.</p>
<h2 id="0104-0133--nintendo-logo"><a class="header" href="#0104-0133--nintendo-logo">0104-0133 — Nintendo logo</a></h2>
<p>This area contains a bitmap image that is displayed when the Game Boy is powered on.
It must match the following (hexadecimal) dump, otherwise <a href="#power-up-sequence">the boot ROM</a> won’t allow the game to run:</p>
<pre><code>CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E
</code></pre>
<p>The way the pixels are encoded is as follows: (<a href="https://github.com/ISSOtm/gb-bootroms/blob/2dce25910043ce2ad1d1d3691436f2c7aabbda00/src/dmg.asm#L259-L269">more visual aid</a>)</p>
<ul>
<li>The bytes <code>$0104</code>—<code>$011B</code> encode the top half of the logo while the bytes <code>$011C</code>–<code>$0133</code> encode the bottom half.</li>
<li>For each half, each nibble encodes 4 pixels (the MSB corresponds to the leftmost pixel, the LSB to the rightmost); a pixel is lit if the corresponding bit is set.</li>
<li>The 4-pixel “groups” are laid out top to bottom, left to right.</li>
<li>Finally, the monochrome models upscale the entire thing by a factor of 2 (leading to somewhat chunky pixels).</li>
</ul>
<p>The Game Boy’s boot procedure <a href="#bypass">first displays the logo and then checks</a> that it matches the dump above.
If it doesn’t, the boot ROM <strong>locks itself up</strong>.</p>
<p>The CGB and later models <a href="#behavior">only check the top half of the logo</a> (the first <code>$18</code> bytes).</p>
<h2 id="0134-0143--title"><a class="header" href="#0134-0143--title">0134-0143 — Title</a></h2>
<p>These bytes contain the title of the game in upper case ASCII.
If the title is less than 16 characters long, the remaining bytes should be padded with <code>$00</code>s.</p>
<p>Parts of this area actually have a different meaning on later cartridges, reducing the actual title size to 15 (<code>$0134</code>–<code>$0142</code>) or 11 (<code>$0134</code>–<code>$013E</code>) characters; see below.</p>
<h2 id="013f-0142--manufacturer-code"><a class="header" href="#013f-0142--manufacturer-code">013F-0142 — Manufacturer code</a></h2>
<p>In older cartridges these bytes were part of the Title (see above).
In newer cartridges they contain a 4-character manufacturer code (in uppercase ASCII).
The purpose of the manufacturer code is unknown.</p>
<h2 id="0143--cgb-flag"><a class="header" href="#0143--cgb-flag">0143 — CGB flag</a></h2>
<p>In older cartridges this byte was part of the Title (see above).
The CGB and later models interpret this byte to decide whether to enable Color mode (“CGB Mode”) or to fall back to monochrome compatibility mode (“Non-CGB Mode”).</p>
<p>Typical values are:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>$80</code></td><td>The game supports CGB enhancements, but is backwards compatible with monochrome Game Boys</td></tr>
<tr><td><code>$C0</code></td><td>The game works on CGB only (the hardware ignores bit 6, so this really functions the same as <code>$80</code>)</td></tr>
</tbody></table>
</div>
<p>Values with bit 7 and either bit 2 or 3 set will switch the Game Boy into a special non-CGB-mode called “PGB mode”.</p>
<div class="box tip">
<p class="box-title">Research needed</p><p>The PGB mode is not well researched or documented yet.
Help is welcome!</p>
</div>
<h2 id="0144-0145--new-licensee-code"><a class="header" href="#0144-0145--new-licensee-code">0144-0145 — New licensee code</a></h2>
<p>This area contains a two-character ASCII “licensee code” indicating the game’s publisher.
It is only meaningful if the <a href="#014b--old-licensee-code">Old licensee</a> is exactly <code>$33</code> (which is the case for essentially all games made after the SGB was released); otherwise, the old code must be considered.</p>
<p>Sample licensee codes:</p>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Publisher</th></tr></thead><tbody>
<tr><td><code>00</code></td><td>None</td></tr>
<tr><td><code>01</code></td><td>Nintendo R&amp;D1</td></tr>
<tr><td><code>08</code></td><td>Capcom</td></tr>
<tr><td><code>13</code></td><td>Electronic Arts</td></tr>
<tr><td><code>18</code></td><td>Hudson Soft</td></tr>
<tr><td><code>19</code></td><td>b-ai</td></tr>
<tr><td><code>20</code></td><td>kss</td></tr>
<tr><td><code>22</code></td><td>pow</td></tr>
<tr><td><code>24</code></td><td>PCM Complete</td></tr>
<tr><td><code>25</code></td><td>san-x</td></tr>
<tr><td><code>28</code></td><td>Kemco Japan</td></tr>
<tr><td><code>29</code></td><td>seta</td></tr>
<tr><td><code>30</code></td><td>Viacom</td></tr>
<tr><td><code>31</code></td><td>Nintendo</td></tr>
<tr><td><code>32</code></td><td>Bandai</td></tr>
<tr><td><code>33</code></td><td>Ocean/Acclaim</td></tr>
<tr><td><code>34</code></td><td>Konami</td></tr>
<tr><td><code>35</code></td><td>Hector</td></tr>
<tr><td><code>37</code></td><td>Taito</td></tr>
<tr><td><code>38</code></td><td>Hudson</td></tr>
<tr><td><code>39</code></td><td>Banpresto</td></tr>
<tr><td><code>41</code></td><td>Ubi Soft</td></tr>
<tr><td><code>42</code></td><td>Atlus</td></tr>
<tr><td><code>44</code></td><td>Malibu</td></tr>
<tr><td><code>46</code></td><td>angel</td></tr>
<tr><td><code>47</code></td><td>Bullet-Proof</td></tr>
<tr><td><code>49</code></td><td>irem</td></tr>
<tr><td><code>50</code></td><td>Absolute</td></tr>
<tr><td><code>51</code></td><td>Acclaim</td></tr>
<tr><td><code>52</code></td><td>Activision</td></tr>
<tr><td><code>53</code></td><td>American sammy</td></tr>
<tr><td><code>54</code></td><td>Konami</td></tr>
<tr><td><code>55</code></td><td>Hi tech entertainment</td></tr>
<tr><td><code>56</code></td><td>LJN</td></tr>
<tr><td><code>57</code></td><td>Matchbox</td></tr>
<tr><td><code>58</code></td><td>Mattel</td></tr>
<tr><td><code>59</code></td><td>Milton Bradley</td></tr>
<tr><td><code>60</code></td><td>Titus</td></tr>
<tr><td><code>61</code></td><td>Virgin</td></tr>
<tr><td><code>64</code></td><td>LucasArts</td></tr>
<tr><td><code>67</code></td><td>Ocean</td></tr>
<tr><td><code>69</code></td><td>Electronic Arts</td></tr>
<tr><td><code>70</code></td><td>Infogrames</td></tr>
<tr><td><code>71</code></td><td>Interplay</td></tr>
<tr><td><code>72</code></td><td>Broderbund</td></tr>
<tr><td><code>73</code></td><td>sculptured</td></tr>
<tr><td><code>75</code></td><td>sci</td></tr>
<tr><td><code>78</code></td><td>THQ</td></tr>
<tr><td><code>79</code></td><td>Accolade</td></tr>
<tr><td><code>80</code></td><td>misawa</td></tr>
<tr><td><code>83</code></td><td>lozc</td></tr>
<tr><td><code>86</code></td><td>Tokuma Shoten Intermedia</td></tr>
<tr><td><code>87</code></td><td>Tsukuda Original</td></tr>
<tr><td><code>91</code></td><td>Chunsoft</td></tr>
<tr><td><code>92</code></td><td>Video system</td></tr>
<tr><td><code>93</code></td><td>Ocean/Acclaim</td></tr>
<tr><td><code>95</code></td><td>Varie</td></tr>
<tr><td><code>96</code></td><td>Yonezawa/s’pal</td></tr>
<tr><td><code>97</code></td><td>Kaneko</td></tr>
<tr><td><code>99</code></td><td>Pack in soft</td></tr>
<tr><td><code>A4</code></td><td>Konami (Yu-Gi-Oh!)</td></tr>
</tbody></table>
</div>
<h2 id="0146--sgb-flag"><a class="header" href="#0146--sgb-flag">0146 — SGB flag</a></h2>
<p>This byte specifies whether the game supports SGB functions.
The SGB will ignore any <a href="#command-packet-transfers">command packets</a> if this byte is set to a value other than <code>$03</code> (typically <code>$00</code>).</p>
<h2 id="0147--cartridge-type"><a class="header" href="#0147--cartridge-type">0147 — Cartridge type</a></h2>
<p>This byte indicates what kind of hardware is present on the cartridge — most notably its <a href="#mbcs">mapper</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Type</th></tr></thead><tbody>
<tr><td><code>$00</code></td><td>ROM ONLY</td></tr>
<tr><td><code>$01</code></td><td>MBC1</td></tr>
<tr><td><code>$02</code></td><td>MBC1+RAM</td></tr>
<tr><td><code>$03</code></td><td>MBC1+RAM+BATTERY</td></tr>
<tr><td><code>$05</code></td><td>MBC2</td></tr>
<tr><td><code>$06</code></td><td>MBC2+BATTERY</td></tr>
<tr><td><code>$08</code></td><td>ROM+RAM <sup class="footnote-reference"><a href="#rom_ram">1</a></sup></td></tr>
<tr><td><code>$09</code></td><td>ROM+RAM+BATTERY <sup class="footnote-reference"><a href="#rom_ram">1</a></sup></td></tr>
<tr><td><code>$0B</code></td><td>MMM01</td></tr>
<tr><td><code>$0C</code></td><td>MMM01+RAM</td></tr>
<tr><td><code>$0D</code></td><td>MMM01+RAM+BATTERY</td></tr>
<tr><td><code>$0F</code></td><td>MBC3+TIMER+BATTERY</td></tr>
<tr><td><code>$10</code></td><td>MBC3+TIMER+RAM+BATTERY <sup class="footnote-reference"><a href="#mbc30">2</a></sup></td></tr>
<tr><td><code>$11</code></td><td>MBC3</td></tr>
<tr><td><code>$12</code></td><td>MBC3+RAM <sup class="footnote-reference"><a href="#mbc30">2</a></sup></td></tr>
<tr><td><code>$13</code></td><td>MBC3+RAM+BATTERY <sup class="footnote-reference"><a href="#mbc30">2</a></sup></td></tr>
<tr><td><code>$19</code></td><td>MBC5</td></tr>
<tr><td><code>$1A</code></td><td>MBC5+RAM</td></tr>
<tr><td><code>$1B</code></td><td>MBC5+RAM+BATTERY</td></tr>
<tr><td><code>$1C</code></td><td>MBC5+RUMBLE</td></tr>
<tr><td><code>$1D</code></td><td>MBC5+RUMBLE+RAM</td></tr>
<tr><td><code>$1E</code></td><td>MBC5+RUMBLE+RAM+BATTERY</td></tr>
<tr><td><code>$20</code></td><td>MBC6</td></tr>
<tr><td><code>$22</code></td><td>MBC7+SENSOR+RUMBLE+RAM+BATTERY</td></tr>
<tr><td><code>$FC</code></td><td>POCKET CAMERA</td></tr>
<tr><td><code>$FD</code></td><td>BANDAI TAMA5</td></tr>
<tr><td><code>$FE</code></td><td>HuC3</td></tr>
<tr><td><code>$FF</code></td><td>HuC1+RAM+BATTERY</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="rom_ram"><sup class="footnote-definition-label">1</sup>
<p>No licensed cartridge makes use of this option. The exact behavior is unknown.</p>
</div>
<div class="footnote-definition" id="mbc30"><sup class="footnote-definition-label">2</sup>
<p>MBC3 with 64 KiB of SRAM refers to MBC30, used only in <em>Pocket Monsters: Crystal Version</em> (the Japanese version of <em>Pokémon Crystal Version</em>).</p>
</div>
<h2 id="0148--rom-size"><a class="header" href="#0148--rom-size">0148 — ROM size</a></h2>
<p>This byte indicates how much ROM is present on the cartridge.
In most cases, the ROM size is given by <code>32 KiB × (1 &lt;&lt; &lt;value&gt;)</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>ROM size</th><th>Number of ROM banks</th></tr></thead><tbody>
<tr><td><code>$00</code></td><td>32 KiB</td><td>2 (no banking)</td></tr>
<tr><td><code>$01</code></td><td>64 KiB</td><td>4</td></tr>
<tr><td><code>$02</code></td><td>128 KiB</td><td>8</td></tr>
<tr><td><code>$03</code></td><td>256 KiB</td><td>16</td></tr>
<tr><td><code>$04</code></td><td>512 KiB</td><td>32</td></tr>
<tr><td><code>$05</code></td><td>1 MiB</td><td>64</td></tr>
<tr><td><code>$06</code></td><td>2 MiB</td><td>128</td></tr>
<tr><td><code>$07</code></td><td>4 MiB</td><td>256</td></tr>
<tr><td><code>$08</code></td><td>8 MiB</td><td>512</td></tr>
<tr><td><code>$52</code></td><td>1.1 MiB</td><td>72 <sup class="footnote-reference"><a href="#weird_rom_sizes">3</a></sup></td></tr>
<tr><td><code>$53</code></td><td>1.2 MiB</td><td>80 <sup class="footnote-reference"><a href="#weird_rom_sizes">3</a></sup></td></tr>
<tr><td><code>$54</code></td><td>1.5 MiB</td><td>96 <sup class="footnote-reference"><a href="#weird_rom_sizes">3</a></sup></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="weird_rom_sizes"><sup class="footnote-definition-label">3</sup>
<p>Only listed in unofficial docs. No cartridges or ROM files using these sizes are known.
As the other ROM sizes are all powers of 2, these are likely inaccurate.
The source of these values is unknown.</p>
</div>
<h2 id="0149--ram-size"><a class="header" href="#0149--ram-size">0149 — RAM size</a></h2>
<p>This byte indicates how much RAM is present on the cartridge, if any.</p>
<p>If the <a href="#0147--cartridge-type">cartridge type</a> does not include “RAM” in its name, this should be set to 0.
This includes MBC2, since its 512 × 4 bits of memory are built directly into the mapper.</p>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>SRAM size</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>$00</code></td><td>0</td><td>No RAM</td></tr>
<tr><td><code>$01</code></td><td>–</td><td>Unused <sup class="footnote-reference"><a href="#2kib_sram">4</a></sup></td></tr>
<tr><td><code>$02</code></td><td>8 KiB</td><td>1 bank</td></tr>
<tr><td><code>$03</code></td><td>32 KiB</td><td>4 banks of 8 KiB each</td></tr>
<tr><td><code>$04</code></td><td>128 KiB</td><td>16 banks of 8 KiB each</td></tr>
<tr><td><code>$05</code></td><td>64 KiB</td><td>8 banks of 8 KiB each</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="2kib_sram"><sup class="footnote-definition-label">4</sup>
<p>Listed in various unofficial docs as 2 KiB.
However, a 2 KiB RAM chip was never used in a cartridge.
The source of this value is unknown.</p>
</div>
<p>Various “PD” ROMs (“Public Domain” homebrew ROMs, generally tagged with <code>(PD)</code> in the filename) are known to use the <code>$01</code> RAM Size tag, but this is believed to have been a mistake with early homebrew tools, and the PD ROMs often don’t use cartridge RAM at all.</p>
<h2 id="014a--destination-code"><a class="header" href="#014a--destination-code">014A — Destination code</a></h2>
<p>This byte specifies whether this version of the game is intended to be sold in Japan or elsewhere.</p>
<p>Only two values are defined:</p>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Destination</th></tr></thead><tbody>
<tr><td><code>$00</code></td><td>Japan (and possibly overseas)</td></tr>
<tr><td><code>$01</code></td><td>Overseas only</td></tr>
</tbody></table>
</div>
<h2 id="014b--old-licensee-code"><a class="header" href="#014b--old-licensee-code">014B — Old licensee code</a></h2>
<p>This byte is used in older (pre-SGB) cartridges to specify the game’s publisher.
However, the value <code>$33</code> indicates that the <a href="#0144%E2%80%930145%20%E2%80%94%20New%20licensee%20code">New licensee codes</a> must be considered instead.
(The SGB will ignore any <a href="#command-packet-transfers">command packets</a> unless this value is <code>$33</code>.)</p>
<p>Here is a list of known Old licensee codes (<a href="https://raw.githubusercontent.com/gb-archive/salvage/master/txt-files/gbrom.txt">source</a>).</p>
<div class="table-wrapper"><table><thead><tr><th>HEX</th><th>Licensee</th></tr></thead><tbody>
<tr><td>00</td><td>None</td></tr>
<tr><td>01</td><td>Nintendo</td></tr>
<tr><td>08</td><td>Capcom</td></tr>
<tr><td>09</td><td>Hot-B</td></tr>
<tr><td>0A</td><td>Jaleco</td></tr>
<tr><td>0B</td><td>Coconuts Japan</td></tr>
<tr><td>0C</td><td>Elite Systems</td></tr>
<tr><td>13</td><td>EA (Electronic Arts)</td></tr>
<tr><td>18</td><td>Hudsonsoft</td></tr>
<tr><td>19</td><td>ITC Entertainment</td></tr>
<tr><td>1A</td><td>Yanoman</td></tr>
<tr><td>1D</td><td>Japan Clary</td></tr>
<tr><td>1F</td><td>Virgin Interactive</td></tr>
<tr><td>24</td><td>PCM Complete</td></tr>
<tr><td>25</td><td>San-X</td></tr>
<tr><td>28</td><td>Kotobuki Systems</td></tr>
<tr><td>29</td><td>Seta</td></tr>
<tr><td>30</td><td>Infogrames</td></tr>
<tr><td>31</td><td>Nintendo</td></tr>
<tr><td>32</td><td>Bandai</td></tr>
<tr><td>33</td><td>Indicates that the <a href="#0144%E2%80%930145%20%E2%80%94%20New%20licensee%20code">New licensee code</a> should be used instead.</td></tr>
<tr><td>34</td><td>Konami</td></tr>
<tr><td>35</td><td>HectorSoft</td></tr>
<tr><td>38</td><td>Capcom</td></tr>
<tr><td>39</td><td>Banpresto</td></tr>
<tr><td>3C</td><td>.Entertainment i</td></tr>
<tr><td>3E</td><td>Gremlin</td></tr>
<tr><td>41</td><td>Ubisoft</td></tr>
<tr><td>42</td><td>Atlus</td></tr>
<tr><td>44</td><td>Malibu</td></tr>
<tr><td>46</td><td>Angel</td></tr>
<tr><td>47</td><td>Spectrum Holoby</td></tr>
<tr><td>49</td><td>Irem</td></tr>
<tr><td>4A</td><td>Virgin Interactive</td></tr>
<tr><td>4D</td><td>Malibu</td></tr>
<tr><td>4F</td><td>U.S. Gold</td></tr>
<tr><td>50</td><td>Absolute</td></tr>
<tr><td>51</td><td>Acclaim</td></tr>
<tr><td>52</td><td>Activision</td></tr>
<tr><td>53</td><td>American Sammy</td></tr>
<tr><td>54</td><td>GameTek</td></tr>
<tr><td>55</td><td>Park Place</td></tr>
<tr><td>56</td><td>LJN</td></tr>
<tr><td>57</td><td>Matchbox</td></tr>
<tr><td>59</td><td>Milton Bradley</td></tr>
<tr><td>5A</td><td>Mindscape</td></tr>
<tr><td>5B</td><td>Romstar</td></tr>
<tr><td>5C</td><td>Naxat Soft</td></tr>
<tr><td>5D</td><td>Tradewest</td></tr>
<tr><td>60</td><td>Titus</td></tr>
<tr><td>61</td><td>Virgin Interactive</td></tr>
<tr><td>67</td><td>Ocean Interactive</td></tr>
<tr><td>69</td><td>EA (Electronic Arts)</td></tr>
<tr><td>6E</td><td>Elite Systems</td></tr>
<tr><td>6F</td><td>Electro Brain</td></tr>
<tr><td>70</td><td>Infogrames</td></tr>
<tr><td>71</td><td>Interplay</td></tr>
<tr><td>72</td><td>Broderbund</td></tr>
<tr><td>73</td><td>Sculptered Soft</td></tr>
<tr><td>75</td><td>The Sales Curve</td></tr>
<tr><td>78</td><td>t.hq</td></tr>
<tr><td>79</td><td>Accolade</td></tr>
<tr><td>7A</td><td>Triffix Entertainment</td></tr>
<tr><td>7C</td><td>Microprose</td></tr>
<tr><td>7F</td><td>Kemco</td></tr>
<tr><td>80</td><td>Misawa Entertainment</td></tr>
<tr><td>83</td><td>Lozc</td></tr>
<tr><td>86</td><td>Tokuma Shoten Intermedia</td></tr>
<tr><td>8B</td><td>Bullet-Proof Software</td></tr>
<tr><td>8C</td><td>Vic Tokai</td></tr>
<tr><td>8E</td><td>Ape</td></tr>
<tr><td>8F</td><td>I’Max</td></tr>
<tr><td>91</td><td>Chunsoft Co.</td></tr>
<tr><td>92</td><td>Video System</td></tr>
<tr><td>93</td><td>Tsubaraya Productions Co.</td></tr>
<tr><td>95</td><td>Varie Corporation</td></tr>
<tr><td>96</td><td>Yonezawa/S’Pal</td></tr>
<tr><td>97</td><td>Kaneko</td></tr>
<tr><td>99</td><td>Arc</td></tr>
<tr><td>9A</td><td>Nihon Bussan</td></tr>
<tr><td>9B</td><td>Tecmo</td></tr>
<tr><td>9C</td><td>Imagineer</td></tr>
<tr><td>9D</td><td>Banpresto</td></tr>
<tr><td>9F</td><td>Nova</td></tr>
<tr><td>A1</td><td>Hori Electric</td></tr>
<tr><td>A2</td><td>Bandai</td></tr>
<tr><td>A4</td><td>Konami</td></tr>
<tr><td>A6</td><td>Kawada</td></tr>
<tr><td>A7</td><td>Takara</td></tr>
<tr><td>A9</td><td>Technos Japan</td></tr>
<tr><td>AA</td><td>Broderbund</td></tr>
<tr><td>AC</td><td>Toei Animation</td></tr>
<tr><td>AD</td><td>Toho</td></tr>
<tr><td>AF</td><td>Namco</td></tr>
<tr><td>B0</td><td>acclaim</td></tr>
<tr><td>B1</td><td>ASCII or Nexsoft</td></tr>
<tr><td>B2</td><td>Bandai</td></tr>
<tr><td>B4</td><td>Square Enix</td></tr>
<tr><td>B6</td><td>HAL Laboratory</td></tr>
<tr><td>B7</td><td>SNK</td></tr>
<tr><td>B9</td><td>Pony Canyon</td></tr>
<tr><td>BA</td><td>Culture Brain</td></tr>
<tr><td>BB</td><td>Sunsoft</td></tr>
<tr><td>BD</td><td>Sony Imagesoft</td></tr>
<tr><td>BF</td><td>Sammy</td></tr>
<tr><td>C0</td><td>Taito</td></tr>
<tr><td>C2</td><td>Kemco</td></tr>
<tr><td>C3</td><td>Squaresoft</td></tr>
<tr><td>C4</td><td>Tokuma Shoten Intermedia</td></tr>
<tr><td>C5</td><td>Data East</td></tr>
<tr><td>C6</td><td>Tonkinhouse</td></tr>
<tr><td>C8</td><td>Koei</td></tr>
<tr><td>C9</td><td>UFL</td></tr>
<tr><td>CA</td><td>Ultra</td></tr>
<tr><td>CB</td><td>Vap</td></tr>
<tr><td>CC</td><td>Use Corporation</td></tr>
<tr><td>CD</td><td>Meldac</td></tr>
<tr><td>CE</td><td>.Pony Canyon or</td></tr>
<tr><td>CF</td><td>Angel</td></tr>
<tr><td>D0</td><td>Taito</td></tr>
<tr><td>D1</td><td>Sofel</td></tr>
<tr><td>D2</td><td>Quest</td></tr>
<tr><td>D3</td><td>Sigma Enterprises</td></tr>
<tr><td>D4</td><td>ASK Kodansha Co.</td></tr>
<tr><td>D6</td><td>Naxat Soft</td></tr>
<tr><td>D7</td><td>Copya System</td></tr>
<tr><td>D9</td><td>Banpresto</td></tr>
<tr><td>DA</td><td>Tomy</td></tr>
<tr><td>DB</td><td>LJN</td></tr>
<tr><td>DD</td><td>NCS</td></tr>
<tr><td>DE</td><td>Human</td></tr>
<tr><td>DF</td><td>Altron</td></tr>
<tr><td>E0</td><td>Jaleco</td></tr>
<tr><td>E1</td><td>Towa Chiki</td></tr>
<tr><td>E2</td><td>Yutaka</td></tr>
<tr><td>E3</td><td>Varie</td></tr>
<tr><td>E5</td><td>Epcoh</td></tr>
<tr><td>E7</td><td>Athena</td></tr>
<tr><td>E8</td><td>Asmik ACE Entertainment</td></tr>
<tr><td>E9</td><td>Natsume</td></tr>
<tr><td>EA</td><td>King Records</td></tr>
<tr><td>EB</td><td>Atlus</td></tr>
<tr><td>EC</td><td>Epic/Sony Records</td></tr>
<tr><td>EE</td><td>IGS</td></tr>
<tr><td>F0</td><td>A Wave</td></tr>
<tr><td>F3</td><td>Extreme Entertainment</td></tr>
<tr><td>FF</td><td>LJN</td></tr>
</tbody></table>
</div>
<h2 id="014c--mask-rom-version-number"><a class="header" href="#014c--mask-rom-version-number">014C — Mask ROM version number</a></h2>
<p>This byte specifies the version number of the game.
It is usually <code>$00</code>.</p>
<h2 id="014d--header-checksum"><a class="header" href="#014d--header-checksum">014D — Header checksum</a></h2>
<p>This byte contains an 8-bit checksum computed from the cartridge header bytes $0134–014C.
The boot ROM computes the checksum as follows:</p>
<pre><code class="language-c">uint8_t checksum = 0;
for (uint16_t address = 0x0134; address &lt;= 0x014C; address++) {
    checksum = checksum - rom[address] - 1;
}
</code></pre>
<p>The boot ROM verifies this checksum.
If the byte at <code>$014D</code> does not match the lower 8 bits of <code>checksum</code>, the boot ROM will lock up and the program in the
cartridge <strong>won’t run</strong>.</p>
<h2 id="014e-014f--global-checksum"><a class="header" href="#014e-014f--global-checksum">014E-014F — Global checksum</a></h2>
<p>These bytes contain a 16-bit (big-endian) checksum simply computed as the sum of
all the bytes of the cartridge ROM (except these two checksum bytes).</p>
<p>This checksum is not verified, except by Pokémon Stadium’s “GB Tower” emulator (presumably to detect Transfer Pak errors).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mbcs"><a class="header" href="#mbcs">MBCs</a></h1>
<p>As the Game Boy’s 16-bit address bus offers only limited space for
ROM and RAM addressing, many games are using Memory Bank Controllers
(MBCs) to expand the available address space by bank switching.
These MBC chips are located in the game cartridge (that is, not in
the Game Boy itself).</p>
<p>In each cartridge, the required (or preferred) MBC type should be
specified in the byte at $0147 of the ROM, as described
<a href="#0147--cartridge-type">in the cartridge header</a>.  Several MBC
types are available:</p>
<h2 id="mbc-timing-issues"><a class="header" href="#mbc-timing-issues">MBC Timing Issues</a></h2>
<p>Among Nintendo MBCs, only the MBC5 is guaranteed by Nintendo to support
the tighter timing of CGB Double Speed Mode. There have been rumours
that older MBCs (like MBC1-3) wouldn’t be fast enough in that mode. If
so, it might be nevertheless possible to use Double Speed during periods
which use only code and data which is located in internal RAM. Despite the 
above, a self-made MBC1-EPROM card appears to work stable and fine even in 
Double Speed Mode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no-mbc"><a class="header" href="#no-mbc">No MBC</a></h1>
<p>(32 KiB ROM only)</p>
<p>Small games of not more than 32 KiB ROM do not require a MBC chip for
ROM banking. The ROM is directly mapped to memory at $0000-7FFF.
Optionally up to 8 KiB of RAM could be connected at $A000-BFFF, using
a discrete logic decoder <!--74HC138?--> in place of a full MBC chip.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mbc1"><a class="header" href="#mbc1">MBC1</a></h1>
<p>(max 2MByte ROM and/or 32 KiB RAM)</p>
<p>This is the first MBC chip for the Game Boy. Any newer MBC chips
work similarly, so it is relatively easy to upgrade a program from one
MBC chip to another — or to make it compatible with several
types of MBCs.</p>
<p>In its default configuration, MBC1 supports up to 512 KiB ROM with up to 32 KiB of banked RAM.
Some cartridges wire the MBC differently, where the 2-bit RAM banking register is wired as an extension of the ROM banking register (instead of to RAM) in order to support up to 2 MiB ROM, at the cost of only supporting a fixed 8 KiB of cartridge RAM.
All MBC1 cartridges with 1 MiB of ROM or more use this alternate wiring.
Also see the note on MBC1M multi-game compilation carts below.</p>
<p>Note that the memory in range 0000–7FFF is used both for reading from
ROM and writing to the MBCs Control Registers.</p>
<h2 id="memory"><a class="header" href="#memory">Memory</a></h2>
<h3 id="00003fff--rom-bank-x0-read-only"><a class="header" href="#00003fff--rom-bank-x0-read-only">0000–3FFF — ROM Bank X0 [read-only]</a></h3>
<p>This area normally contains the first 16 KiB (bank 00) of the cartridge
ROM.</p>
<p>In 1 MiB and larger cartridges (that use the 2-bit second banking register for extended ROM banking), entering mode 1 (see below) will allow that second banking register to apply to reads from this region in addition to the regular 4000–7FFF banked region, resulting in accessing banks $20/$40/$60 for regular large ROM carts, or banks $10/$20/$30 for an MBC1M multi-cart (see note below).</p>
<h3 id="40007fff--rom-bank-01-7f-read-only"><a class="header" href="#40007fff--rom-bank-01-7f-read-only">4000–7FFF — ROM Bank 01-7F [read-only]</a></h3>
<p>This area may contain any of the further 16 KiB banks of the ROM. If the main 5-bit ROM banking register is 0, it reads the bank as if it was set to 1.</p>
<p>For 1 MiB+ ROM, this means any bank that is possible to accessible via the 0000–3FFF region is not accessible in this region. i.e. banks $00/$20/$40/$60 in regular large ROM carts, or banks $00/$10/$20/$30 in MBC1M multi-game compilation carts. Instead, it automatically maps to 1 bank
higher ($01/$21/$41/$61 or $01/$11/$21/$31 respectively).</p>
<h3 id="a000bfff--ram-bank-0003-if-any"><a class="header" href="#a000bfff--ram-bank-0003-if-any">A000–BFFF — RAM Bank 00–03, if any</a></h3>
<p>This area is used to address external RAM in the cartridge (if any). The RAM is only accessible if RAM is enabled, otherwise reads return open bus values (often $FF, but not guaranteed) and writes are ignored.</p>
<p>Available RAM sizes are 8 KiB (at $A000–BFFF) and 32 KiB (in form of four 8K banks at $A000–BFFF). 32 KiB is only available in cartridges with ROM &lt;= 512 KiB.</p>
<p>External RAM is often battery-backed, allowing for the storage of game data while the Game Boy is turned off, or if the cartridge is removed from the Game Boy. External RAM is no slower than the Game Boy’s internal RAM, so many games use part of the external RAM as extra working RAM, even if they use another part of it for battery-backed saves.</p>
<h2 id="registers-1"><a class="header" href="#registers-1">Registers</a></h2>
<p>All of the MBC1 registers default to 00h on power-up, which for the “ROM Bank Number” register is <em>treated as</em> 01h.</p>
<h3 id="00001fff--ram-enable-write-only"><a class="header" href="#00001fff--ram-enable-write-only">0000–1FFF — RAM Enable (Write Only)</a></h3>
<p>Before external RAM can be read or written, it must be enabled by
writing $A to this address space.
Any value with $A in the lower 4 bits enables the RAM attached to the MBC and any
other value disables the RAM. It is unknown why $A is the value used to enable RAM.</p>
<pre><code>$00  Disable RAM (default)
$0A  Enable RAM
</code></pre>
<p>It is recommended to disable external RAM
after accessing it, in order to protect its contents from corruption during
power down of the Game Boy or removal of the cartridge. Once the cartridge has <em>completely</em> lost power from the Game Boy, the RAM is automatically disabled to protect it.</p>
<h3 id="20003fff--rom-bank-number-write-only"><a class="header" href="#20003fff--rom-bank-number-write-only">2000–3FFF — ROM Bank Number (Write Only)</a></h3>
<p>This 5-bit register (range $01-$1F) selects the ROM bank number for the 4000–7FFF region. Higher
bits are discarded — writing $E1 (binary ~~111~~00001) to this register
would select bank $01.</p>
<p>If this register is set to $00, it behaves as if it is set to $01. This means you cannot duplicate bank $00 into both the 0000–3FFF and 4000–7FFF ranges by setting this register to $00.</p>
<p>If the ROM Bank Number is set to a higher value than the number of banks
in the cart, the bank number is masked to the required number of bits.
e.g. a 256 KiB cart only needs a 4-bit bank number to address all of its
16 banks, so this register is masked to 4 bits. The upper bit would be
ignored for bank selection.</p>
<p>Even with smaller ROMs that use less than 5 bits for bank selection, the full 5-bit register is still compared for the bank 00→01 translation logic. As a result if the ROM is 256 KiB or smaller, it <em>is</em> possible to map bank 0 to the 4000–7FFF region — by setting the 5th bit to 1 it will prevent the 00→01 translation (which looks at the full 5-bit register, and sees the value $10, not $00), while the bits actually used for bank selection (4, in this example) are all 0, so bank $00 is selected.</p>
<p>On larger carts which need a &gt;5 bit bank number, the secondary banking
register at 4000–5FFF is used to supply an additional 2 bits for the
effective bank number:
<code>Selected ROM Bank = (Secondary Bank &lt;&lt; 5) + ROM Bank</code>.<sup class="footnote-reference"><a href="#MBC1M_banking">1</a></sup></p>
<div class="footnote-definition" id="MBC1M_banking"><sup class="footnote-definition-label">1</sup>
<p>MBC1M has a different formula, see below</p>
</div>
<p>These additional two bits are ignored for the bank 00→01 translation. This causes a problem — attempting to access banks 20h, 40h, and 60h only set bits in the upper 2-bit register, with the lower 5-bit register set to 00. As a result, any
attempt to address these ROM Banks will select Bank $21, $41 and $61
instead. The only way to access banks $20, $40 or $60 at all is to enter mode 1,
which remaps the 0000–3FFF range. This has its own problems for game
developers as that range contains interrupt handlers, so it’s usually only
used in multi-game compilation carts (see below).</p>
<h3 id="40005fff--ram-bank-number--or--upper-bits-of-rom-bank-number-write-only"><a class="header" href="#40005fff--ram-bank-number--or--upper-bits-of-rom-bank-number-write-only">4000–5FFF — RAM Bank Number — or — Upper Bits of ROM Bank Number (Write Only)</a></h3>
<p>This second 2-bit register can be used to select a RAM Bank in range from
$00–$03 (32 KiB ram carts only), or to specify the upper two bits (bits 5-6)
of the ROM Bank number (1 MiB ROM or larger carts only). If neither ROM nor
RAM is large enough, setting this register does nothing.</p>
<p>In 1MB MBC1 multi-carts (see below), this 2-bit register is instead
applied to bits 4-5 of the ROM bank number and the top bit of the main
5-bit main ROM banking register is ignored.</p>
<h3 id="60007fff--banking-mode-select-write-only"><a class="header" href="#60007fff--banking-mode-select-write-only">6000–7FFF — Banking Mode Select (Write Only)</a></h3>
<p>This 1-bit register selects between the two MBC1 banking modes, controlling
the behaviour of the secondary 2-bit banking register (above). If the cart
is not large enough to use the 2-bit register (&lt;= 8 KiB RAM and &lt;= 512 KiB ROM)
this mode select has no observable effect. The program may freely switch
between the two modes at any time.</p>
<pre><code>00 = Simple Banking Mode (default)
     0000–3FFF and A000–BFFF locked to bank 0 of ROM/RAM
01 = RAM Banking Mode / Advanced ROM Banking Mode
     0000–3FFF and A000–BFFF can be bank-switched via the 4000–5FFF bank register
</code></pre>
<p>Technically, the MBC1 has AND gates between the both bank registers and the second-highest bit of the address. This is intended to cause accesses to the 0000–3FFF region (which has that address bit set to 0) to treat both registers as always 0, so that only bank 0 is accessible through this address.</p>
<p>However, when the second bank register is connected to RAM, this has the side effect of also locking RAM to bank 0, as the RAM address space (A000–BFFF) <em>also</em> has the second-highest address bit set to 0.</p>
<p>Setting the mode to 1 disables these AND gates, allowing the two-bit register to switch the selected bank in both these regions.</p>
<h2 id="addressing-diagrams"><a class="header" href="#addressing-diagrams">Addressing diagrams</a></h2>
<p>The following diagrams show how the address within the ROM/RAM chips are calculated from the accessed address and banking registers</p>
<h3 id="00003fff"><a class="header" href="#00003fff">0000–3FFF</a></h3>
<p>In mode 0:</p>
<pre><code>Bits: 20 19 18 17 16 15 14 13 12 .. 01 00
      \___/ \____________/ \____________/
        |          |            \----------- From Game Boy address
        |          \------------------------ Always 0
        \----------------------------------- Always 0
</code></pre>
<p>In mode 1:</p>
<pre><code>Bits: 20 19 18 17 16 15 14 13 12 .. 01 00
      \___/ \____________/ \____________/
        |          |            \----------- From Game Boy address
        |          \------------------------ Always 0
        \----------------------------------- As 4000–5FFF bank register
</code></pre>
<h3 id="40007fff"><a class="header" href="#40007fff">4000–7FFF</a></h3>
<p>Regardless of mode:</p>
<pre><code>                              /------------- In a smaller cart, only the needed
                              |              bits are used (e.g 128kiB uses 17)
                  /---------------------\
Bits: 20 19 18 17 16 15 14 13 12 .. 01 00
      \___/ \____________/ \____________/
        |          |            \----------- From Game Boy address
        |          \------------------------ As 2000–3FFF bank register
        \----------------------------------- As 4000–5FFF bank register
</code></pre>
<h3 id="a000bfff"><a class="header" href="#a000bfff">A000–BFFF</a></h3>
<p>In mode 0:</p>
<pre><code>Bits: 14 13 12 .. 01 00
      \___/ \_________/
        |        \-------- From Game Boy address
        \----------------- Always 0
</code></pre>
<p>In mode 1:</p>
<pre><code>Bits: 14 13 12 .. 01 00
      \___/ \_________/
        |        \-------- From Game Boy address
        \----------------- As 4000–5FFF bank register
</code></pre>
<h2 id="mbc1m-1-mib-multi-game-compilation-carts"><a class="header" href="#mbc1m-1-mib-multi-game-compilation-carts">“MBC1M” 1 MiB Multi-Game Compilation Carts</a></h2>
<p>Known as MBC1M, these carts have an alternative wiring, that ignores
the top bit of the main ROM banking register (making it effectively a 4-bit register for banking, though the full 5 bit register is still used for 00→01 translation)
and applies the 2-bit register to bits 4-5 of the bank number (instead of
the usual bits 5-6). This means that in mode 1 the 2-bit register selects
banks $00, $10, $20, or $30, rather than the usual $00, $20, $40 or $60.</p>
<p>These carts make use of the fact that mode 1 remaps the 0000–3FFF area
to switch games. The 2-bit register is used to select the game — switching
the zero bank and the region of banks that the 4000–7FFF ROM area can
access to those for the selected game and then the game only changes the
main ROM banking register. As far as the selected game knows, it’s running
from a 256 KiB cart!</p>
<p>These carts can normally be identified by having a Nintendo copyright
header in bank $10. A badly dumped multi-cart ROM can be identified by
having duplicate content in banks $10-$1F (dupe of $00–$0F) and banks $30-$3F
(dupe of $20-$2F).
There is a known bad dump of the Mortal Kombat I &amp; II collection around.</p>
<p>An “MBC1M” compilation cart ROM can be converted into a regular MBC1 ROM
by increasing the ROM size to 2 MiB and duplicating each sub-ROM — $00–$0F
duplicated into $10-$1F, the original $10-$1F placed in $20-$2F and
duplicated into $30-$3F and so on.</p>
<h2 id="mbc1m-addressing-diagrams"><a class="header" href="#mbc1m-addressing-diagrams">MBC1M addressing diagrams:</a></h2>
<h3 id="00003fff-1"><a class="header" href="#00003fff-1">0000–3FFF</a></h3>
<p>(In mode 1)</p>
<pre><code>Bits: 19 18    17 16 15 14 13 12 .. 01 00
      \___/ \____________/ \____________/
        |          |            \----------- From Game Boy address
        |          \------------------------ Always 0
        \----------------------------------- As 4000–5FFF bank register
</code></pre>
<h3 id="40007fff-1"><a class="header" href="#40007fff-1">4000–7FFF</a></h3>
<p>Regardless of mode:</p>
<pre><code>Bits: 19 18    17 16 15 14 13 12 .. 01 00
      \___/ \____________/ \____________/
        |          |            \----------- From Game Boy address
        |          \------------------------ As 2000–3FFF bank register
        |                                       (only 4 bits used)
        \----------------------------------- As 4000–5FFF bank register
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mbc2"><a class="header" href="#mbc2">MBC2</a></h1>
<p>(max 256 KiB ROM and 512x4 bits RAM)</p>
<h2 id="memory-1"><a class="header" href="#memory-1">Memory</a></h2>
<h3 id="00003fff--rom-bank-0-read-only"><a class="header" href="#00003fff--rom-bank-0-read-only">0000–3FFF — ROM Bank 0 [read-only]</a></h3>
<p>Contains the first 16 KiB of the ROM.</p>
<h3 id="40007fff--rom-bank-01-0f-read-only"><a class="header" href="#40007fff--rom-bank-01-0f-read-only">4000–7FFF — ROM Bank $01-0F [read-only]</a></h3>
<p>Same as for MBC1, but only a total of 16 ROM banks is supported.</p>
<h3 id="a000a1ff--built-in-ram"><a class="header" href="#a000a1ff--built-in-ram">A000–A1FF — Built-in RAM</a></h3>
<p>The MBC2 doesn’t support external RAM, instead it includes 512 half-bytes of RAM (built into the MBC2 chip itself).
It still requires an external battery to save data during power-off though.
As the data consists of 4-bit values, only the lower 4 bits of the bytes in this memory area are used.
The upper 4 bits of each byte are undefined and should not be relied upon.</p>
<h3 id="a200bfff--15-echoes-of-a000a1ff"><a class="header" href="#a200bfff--15-echoes-of-a000a1ff">A200–BFFF — 15 “echoes” of A000–A1FF</a></h3>
<p>Only the bottom 9 bits of the address are used to index into the internal RAM, so RAM access repeats.
As with the A000–A1FF region, only the lower 4 bits of the “bytes” are used, and the upper 4 bits of each byte are undefined and should not be relied upon.</p>
<h2 id="registers-2"><a class="header" href="#registers-2">Registers</a></h2>
<h3 id="00003fff--ram-enable-rom-bank-number-write-only"><a class="header" href="#00003fff--ram-enable-rom-bank-number-write-only">0000–3FFF — RAM Enable, ROM Bank Number [write-only]</a></h3>
<p>This address range is responsible for both enabling/disabling the RAM and for controlling the ROM bank number.
Bit 8 of the address (the least
significant bit of the upper address byte) determines whether to control
the RAM enable flag or the ROM bank number.</p>
<h4 id="when-bit-8-is-clear"><a class="header" href="#when-bit-8-is-clear">When bit 8 is clear</a></h4>
<p>When the least significant bit of the upper address byte is zero, the value that is written controls whether the RAM is enabled.
When the value written to this address range is equal to <code>$0A</code>, RAM is enabled.
If any other value is written, RAM is disabled.</p>
<p>Examples of addresses that can control RAM: $0000–00FF, $0200–02FF, $0400–04FF, …, $3E00–3EFF.</p>
<p>RAM is disabled by default.</p>
<h4 id="when-bit-8-is-set"><a class="header" href="#when-bit-8-is-set">When bit 8 is set</a></h4>
<p>When the least significant bit of the upper address byte is one, the value that is written controls the selected ROM bank at 4000–7FFF.</p>
<p>Specifically, the lower 4 bits of the value written to this address range specify the ROM bank number.
If bank 0 is written, the resulting bank will be bank 1 instead.</p>
<p>Examples of address that can control ROM: $0100–01FF, $0300–03FF, $0500–05FF, …, $3F00–3FFF.</p>
<p>The ROM bank is set to 1 by default.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mbc3"><a class="header" href="#mbc3">MBC3</a></h1>
<p>(max 2MByte ROM and/or 32KByte RAM and Timer)</p>
<p>Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM
(4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The
RTC requires an external 32.768 kHz Quartz Oscillator, and an external
battery (if it should continue to tick when the Game Boy is turned off).</p>
<h2 id="memory-2"><a class="header" href="#memory-2">Memory</a></h2>
<h3 id="0000-3fff---rom-bank-00-read-only"><a class="header" href="#0000-3fff---rom-bank-00-read-only">0000-3FFF - ROM Bank 00 (Read Only)</a></h3>
<p>Contains the first 16 KiB of the ROM.</p>
<h3 id="4000-7fff---rom-bank-01-7f-read-only"><a class="header" href="#4000-7fff---rom-bank-01-7f-read-only">4000-7FFF - ROM Bank 01-7F (Read Only)</a></h3>
<p>Same as for MBC1, except that accessing banks 20h, 40h, and 60h is
supported now.</p>
<h3 id="a000-bfff---ram-bank-00-03-if-any-readwrite"><a class="header" href="#a000-bfff---ram-bank-00-03-if-any-readwrite">A000-BFFF - RAM Bank 00-03, if any (Read/Write)</a></h3>
<p>Depending on the current Bank Number/RTC Register selection (see below),
this memory space is used to access an 8 KiB external RAM Bank, or a
single RTC Register.</p>
<h2 id="registers-3"><a class="header" href="#registers-3">Registers</a></h2>
<h3 id="a000-bfff---rtc-register-08-0c-readwrite"><a class="header" href="#a000-bfff---rtc-register-08-0c-readwrite">A000-BFFF - RTC Register 08-0C (Read/Write)</a></h3>
<p>Depending on the current Bank Number/RTC Register selection (see below),
this memory space is used to access an 8KByte external RAM Bank, or a
single RTC Register.</p>
<h3 id="0000-1fff---ram-and-timer-enable-write-only"><a class="header" href="#0000-1fff---ram-and-timer-enable-write-only">0000-1FFF - RAM and Timer Enable (Write Only)</a></h3>
<p>Mostly the same as for MBC1, a value of 0Ah will enable reading and
writing to external RAM - and to the RTC Registers! A value of 00h will
disable either.</p>
<h3 id="2000-3fff---rom-bank-number-write-only"><a class="header" href="#2000-3fff---rom-bank-number-write-only">2000-3FFF - ROM Bank Number (Write Only)</a></h3>
<p>Same as for MBC1, except that the whole 7 bits of the ROM Bank Number
are written directly to this address. As for the MBC1, writing a value
of 00h will select Bank 01h instead. All other values 01-7Fh select the
corresponding ROM Banks.</p>
<h3 id="4000-5fff---ram-bank-number---or---rtc-register-select-write-only"><a class="header" href="#4000-5fff---ram-bank-number---or---rtc-register-select-write-only">4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)</a></h3>
<p>As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h
maps the corresponding external RAM Bank (if any) into memory at
A000-BFFF. When writing a value of 08h-0Ch, this will map the
corresponding RTC register into memory at A000-BFFF. That register could
then be read/written by accessing any address in that area, typically
that is done by using address A000.</p>
<h3 id="6000-7fff---latch-clock-data-write-only"><a class="header" href="#6000-7fff---latch-clock-data-write-only">6000-7FFF - Latch Clock Data (Write Only)</a></h3>
<p>When writing 00h, and then 01h to this register, the current time
becomes latched into the RTC registers. The latched data will not change
until it becomes latched again, by repeating the write 00h-&gt;01h
procedure. This provides a way to read the RTC registers while the
clock keeps ticking.</p>
<h3 id="the-clock-counter-registers"><a class="header" href="#the-clock-counter-registers">The Clock Counter Registers</a></h3>
<pre><code>08h  RTC S   Seconds   0-59 (0-3Bh)
09h  RTC M   Minutes   0-59 (0-3Bh)
0Ah  RTC H   Hours     0-23 (0-17h)
0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
      Bit 0  Most significant bit of Day Counter (Bit 8)
      Bit 6  Halt (0=Active, 1=Stop Timer)
      Bit 7  Day Counter Carry Bit (1=Counter Overflow)
</code></pre>
<p>The Halt Flag is supposed to be set before <strong>writing</strong> to the RTC
Registers.</p>
<h3 id="the-day-counter"><a class="header" href="#the-day-counter">The Day Counter</a></h3>
<p>The total 9 bits of the Day Counter allow counting days in range from
0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value
overflows. In that case the Carry Bit remains set until the program does
reset it. Note that you can store an offset to the Day Counter in
battery RAM. For example, every time you read a non-zero Day Counter,
add this Counter to the offset in RAM, and reset the Counter to zero.
This method allows counting any number of days, making your program
Year-10000-Proof, provided that the cartridge gets used at least every
511 days.</p>
<h3 id="delays"><a class="header" href="#delays">Delays</a></h3>
<p>When accessing the RTC Registers it is recommended to execute a 4ms
delay (4 Cycles in Normal Speed Mode) between the separate accesses.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mbc5"><a class="header" href="#mbc5">MBC5</a></h1>
<p>It can map up to 64 Mbits (8 MiB) of ROM.</p>
<p>MBC5 (Memory Bank Controller 5) is the 4th generation MBC. There
apparently was no MBC4, presumably because of the superstition about the
number 4 in Japanese culture. It is the first MBC that is guaranteed to
work properly with GBC double speed mode.</p>
<h2 id="memory-3"><a class="header" href="#memory-3">Memory</a></h2>
<h3 id="0000-3fff---rom-bank-00-read-only-1"><a class="header" href="#0000-3fff---rom-bank-00-read-only-1">0000-3FFF - ROM Bank 00 (Read Only)</a></h3>
<p>Contains the first 16 KiB of the ROM.</p>
<h3 id="4000-7fff---rom-bank-00-1ff-read-only"><a class="header" href="#4000-7fff---rom-bank-00-1ff-read-only">4000-7FFF - ROM bank 00-1FF (Read Only)</a></h3>
<p>Same as for MBC1, except that accessing up to bank $1FF is supported
now. Also, bank 0 is actually bank 0.</p>
<h3 id="a000-bfff---ram-bank-00-0f-if-any-readwrite"><a class="header" href="#a000-bfff---ram-bank-00-0f-if-any-readwrite">A000-BFFF - RAM bank 00-0F, if any (Read/Write)</a></h3>
<p>Same as for MBC1, except that RAM sizes are 8 KiB, 32 KiB and 128 KiB.</p>
<h2 id="registers-4"><a class="header" href="#registers-4">Registers</a></h2>
<h3 id="0000-1fff---ram-enable-write-only"><a class="header" href="#0000-1fff---ram-enable-write-only">0000-1FFF - RAM Enable (Write Only)</a></h3>
<p>Mostly the same as for MBC1. Writing $0A will enable reading and
writing to external RAM. Writing $00 will disable it.</p>
<p>Actual MBCs actually enable RAM when writing any value whose bottom 4 bits equal $A (so $0A, $1A, and so on), and disable it when writing anything else.
Relying on this behavior is not recommended for compatibility reasons.</p>
<h3 id="2000-2fff---8-least-significant-bits-of-rom-bank-number-write-only"><a class="header" href="#2000-2fff---8-least-significant-bits-of-rom-bank-number-write-only">2000-2FFF - 8 least significant bits of ROM bank number (Write Only)</a></h3>
<p>The 8 least significant bits of the ROM bank number go here. Writing 0 will indeed
give bank 0 on MBC5, unlike other MBCs.</p>
<h3 id="3000-3fff---9th-bit-of-rom-bank-number-write-only"><a class="header" href="#3000-3fff---9th-bit-of-rom-bank-number-write-only">3000-3FFF - 9th bit of ROM bank number (Write Only)</a></h3>
<p>The 9th bit of the ROM bank number goes here.</p>
<h3 id="4000-5fff---ram-bank-number-write-only"><a class="header" href="#4000-5fff---ram-bank-number-write-only">4000-5FFF - RAM bank number (Write Only)</a></h3>
<p>As for the MBC1s RAM Banking Mode, writing a value in the range $00-$0F
maps the corresponding external RAM bank (if any) into the memory area at
A000-BFFF.</p>
<p><img src="imgs/MBC5.png" alt="" title="imgs/MBC5.png" /></p>
<h3 id="rumble"><a class="header" href="#rumble">Rumble</a></h3>
<p>On cartridges which feature a rumble motor, bit 3 of the RAM Bank register
is connected to the Rumble circuitry instead of the RAM chip. Setting the
bit to 1 enables the rumble motor and keeps it enabled until the bit is reset again.</p>
<p>To control the rumble’s intensity, it should be turned on and off repeatedly,
as seen with these two examples from Pokémon Pinball:</p>
<img src="imgs/MBC5_Rumble_Mild.svg" width="950px">
<img src="imgs/MBC5_Rumble_Strong.svg" width="950px">
<div style="break-before: page; page-break-before: always;"></div><h1 id="mbc6"><a class="header" href="#mbc6">MBC6</a></h1>
<p>MBC6 (Memory Bank Controller 6) is an unusual MBC that contains two
separately switchable ROM banks ($4000 and $6000) and RAM banks
($A000 and $B000), SRAM and an 8 Mbit Macronix MX29F008TC-14 flash
memory chip. It is only used in one game, Net de Get: Minigame @ 100,
which uses the Mobile Adapter to connect to
the web to download mini-games onto the local flash. Both ROM banks and
both RAM banks are views into the same ROM and RAM, but with separately
adjustable offsets. Since the banked regions are smaller the effective
number of banks is twice what it usually would be; 8 kB ROM banks
instead of 16 kB and 4 kB RAM banks instead of 8 kB.</p>
<h2 id="memory-4"><a class="header" href="#memory-4">Memory</a></h2>
<h3 id="0000-3fff--rom-bank-00-read-only"><a class="header" href="#0000-3fff--rom-bank-00-read-only">0000-3FFF — ROM Bank 00 (Read Only)</a></h3>
<p>Contains the first 16 KiB of the ROM.</p>
<h3 id="4000-5fff--romflash-bank-a-00-7f-readwrite-for-flash-read-only-for-rom"><a class="header" href="#4000-5fff--romflash-bank-a-00-7f-readwrite-for-flash-read-only-for-rom">4000-5FFF — ROM/Flash Bank A 00-7F (Read/Write for flash, Read Only for ROM)</a></h3>
<p>Read-only access to ROM and flash banks 00-7F, switchable independently
of ROM/Flash Bank B.</p>
<h3 id="6000-7fff--romflash-bank-b-00-7f-readwrite-for-flash-read-only-for-rom"><a class="header" href="#6000-7fff--romflash-bank-b-00-7f-readwrite-for-flash-read-only-for-rom">6000-7FFF — ROM/Flash Bank B 00-7F (Read/Write for flash, Read Only for ROM)</a></h3>
<p>Read-only access to ROM and flash banks 00-7F, switchable independently
of ROM/Flash Bank A.</p>
<h3 id="a000-afff--ram-bank-a-00-07-readwrite"><a class="header" href="#a000-afff--ram-bank-a-00-07-readwrite">A000-AFFF — RAM Bank A 00-07 (Read/Write)</a></h3>
<p>Read/write access to RAM banks 00-07, switchable independently of RAM
Bank B.</p>
<h3 id="b000-bfff--ram-bank-b-00-07-readwrite"><a class="header" href="#b000-bfff--ram-bank-b-00-07-readwrite">B000-BFFF — RAM Bank B 00-07 (Read/Write)</a></h3>
<p>Read/write access to RAM banks 00-07, switchable independently of RAM
Bank A.</p>
<h2 id="registers-5"><a class="header" href="#registers-5">Registers</a></h2>
<h3 id="0000-03ff--ram-enable-write-only"><a class="header" href="#0000-03ff--ram-enable-write-only">0000-03FF — RAM Enable (Write Only)</a></h3>
<p>Mostly the same as for MBC1, a value of 0Ah will enable reading and
writing to external RAM. A value of 00h will disable it.</p>
<h3 id="0400-07ff--ram-bank-a-number-write-only"><a class="header" href="#0400-07ff--ram-bank-a-number-write-only">0400-07FF — RAM Bank A Number (Write Only)</a></h3>
<p>Select the active RAM Bank A (A000-AFFF)</p>
<h3 id="0800-0bff--ram-bank-b-number-write-only"><a class="header" href="#0800-0bff--ram-bank-b-number-write-only">0800-0BFF — RAM Bank B Number (Write Only)</a></h3>
<p>Select the active RAM Bank B (B000-BFFF)</p>
<h3 id="0c00-0fff--flash-enable-write-only"><a class="header" href="#0c00-0fff--flash-enable-write-only">0C00-0FFF — Flash Enable (Write Only)</a></h3>
<p>Enable or disable access to the flash chip. Only the lowest bit (0 for
disable, 1 for enable) is used. Flash Write Enable must be active to
change this.</p>
<h3 id="1000--flash-write-enable-write-only"><a class="header" href="#1000--flash-write-enable-write-only">1000 — Flash Write Enable (Write Only)</a></h3>
<p>Enable or disable write mode for the flash chip. Only the lowest bit (0
for disable, 1 for enable) is used. Note that this maps to the /WE pin
on the flash chip, not whether writing to the bus is enabled;
some flash commands (e.g. JEDEC ID query) still work with this off so
long as Flash Enable is on.</p>
<h3 id="2000-27ff--romflash-bank-a-number-write-only"><a class="header" href="#2000-27ff--romflash-bank-a-number-write-only">2000-27FF — ROM/Flash Bank A Number (Write Only)</a></h3>
<p>The number for the active bank in ROM/Flash Bank A.</p>
<h3 id="2800-2fff--romflash-bank-a-select-write-only"><a class="header" href="#2800-2fff--romflash-bank-a-select-write-only">2800-2FFF — ROM/Flash Bank A Select (Write Only)</a></h3>
<p>Selects whether the ROM or the Flash is mapped into ROM/Flash Bank A. A
value of 00 selects the ROM and 08 selects the flash.</p>
<h3 id="3000-37ff--romflash-bank-b-number-write-only"><a class="header" href="#3000-37ff--romflash-bank-b-number-write-only">3000-37FF — ROM/Flash Bank B Number (Write Only)</a></h3>
<p>The number for the active bank in ROM/Flash Bank B.</p>
<h3 id="3800-3fff--romflash-bank-b-select-write-only"><a class="header" href="#3800-3fff--romflash-bank-b-select-write-only">3800-3FFF — ROM/Flash Bank B Select (Write Only)</a></h3>
<p>Selects whether the ROM or the Flash is mapped into ROM/Flash Bank B. A
value of 00 selects the ROM and 08 selects the flash.</p>
<h3 id="flash-commands"><a class="header" href="#flash-commands">Flash Commands</a></h3>
<p>The flash chip is mapped directly into the A or B address space, which
means standard flash access commands are used. To issue a command, you
must write the value $AA to $5555 then $55 to $2AAA and, which are
mapped as 2:5555/1:4AAA for bank A or 2:7555/1:6AAA for bank B followed
by the command at either 2:5555/2:7555, or a relevant address, depending
on the command.</p>
<p>The commands and access sequences are as follows, were X refers to
either 4 or 6 and Y to 5 or 7, depending on the bank region:</p>
<pre><code>------------- ------------- ------------- ------------- ------------- ------------- ------------------------------------------------
2:Y555=$AA    1:XAAA=$55    2:Y555=$80    2:Y555=$AA    1:XAAA=$55    ?:X000=$30    Erase sector\* (set 8 kB region to $FFs)
2:Y555=$AA    1:XAAA=$55    2:Y555=$80    2:Y555=$AA    1:XAAA=$55    ?:Y555=$10    Erase chip\* (set entire flash to $FFs)
2:Y555=$AA    1:XAAA=$55    2:Y555=$90                                                 ID mode (reads out JEDEC ID (C2,81) at $X000)
2:Y555=$AA    1:XAAA=$55    2:Y555=$A0                                                 Program mode\*
2:Y555=$AA    1:XAAA=$55    2:Y555=$F0                                                 Exit ID/erase chip mode
2:Y555=$AA    1:XAAA=$55    ?:X000=$F0                                                 Exit erase sector mode
?:????=$F0                                                                               Exit program mode
------------- ------------- ------------- ------------- ------------- ------------- ------------------------------------------------
</code></pre>
<p>Commands marked with * require the Write Enable bit to be 1. These will
make the flash read out status bytes instead of values. A status of $80
means the operation has finished and you should exit the mode using the
appropriate command. A status of $10 indicates a timeout.</p>
<p>Programming must be done by first erasing a sector, activating write
mode, writing out 128 bytes (aligned), then writing a 0 to the final
address to commit the write, waiting for the status to indicate
completion, and writing $F0 to the final address again to exit program
mode. If a sector is not erased first programming will not work
properly. In some cases it will only allow the stored bytes to be anded
instead of replaced; in others it just won’t work at all. The only way
to set the bits back to 1 is to erase the sector entirely. It is
recommended to check the flash to make sure all bytes were written
properly and re-write (without erasing) the 128 byte block if some bits
didn’t get set to 0 properly. After writing all blocks in a sector
Flash Write Enable should be set to 0.</p>
<h2 id="external-links"><a class="header" href="#external-links">External links</a></h2>
<ul>
<li>Source: <a href="http://gbdev.gg8.se/forums/viewtopic.php?id=544">GBDev Forums thread by endrift</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mbc7"><a class="header" href="#mbc7">MBC7</a></h1>
<p>MBC7 (Memory Bank Controller 7) is an MBC containing a 2-axis
accelerometer (ADXL202E) and a 256 byte EEPROM
(<a href="https://web.archive.org/web/20230115175018/https://www.microchip.com/en-us/product/93LC56">93LC56</a>). A000-BFFF
does not directly address the EEPROM, as most MBCs do, but rather
contains several registers that can be read or written one at a time.
This makes EEPROM access very slow due to needing multiple writes per
address.</p>
<h2 id="memory-5"><a class="header" href="#memory-5">Memory</a></h2>
<h3 id="0000-3fff---rom-bank-00-read-only-2"><a class="header" href="#0000-3fff---rom-bank-00-read-only-2">0000-3FFF - ROM Bank 00 (Read Only)</a></h3>
<p>Contains the first 16 KiB of the ROM.</p>
<h3 id="4000-7fff---rom-bank-00-7f-read-only"><a class="header" href="#4000-7fff---rom-bank-00-7f-read-only">4000-7FFF - ROM Bank 00-7F (Read Only)</a></h3>
<p>Same as for MBC5. (Bank 0 mapping needs confirmation)</p>
<h2 id="registers-6"><a class="header" href="#registers-6">Registers</a></h2>
<h3 id="a000-afff---ram-registers-readwrite"><a class="header" href="#a000-afff---ram-registers-readwrite">A000-AFFF - RAM Registers (Read/Write)</a></h3>
<p>Must be enabled via 0000 and 4000 region writes (see respective
sections), otherwise reads read FFh and writes do nothing. Registers are
addressed through bits 4-7 of the address. Bits 0-3 and 8-11 are
ignored.</p>
<p>Accelerometer data must be latched before reading. Data is 16-bit and
centered at the value 81D0. Earth’s gravity affects the value by
roughly 70h, with larger acceleration providing a larger range. Maximum
range is unknown.</p>
<h3 id="ax0xax1x---latch-accelerometer-write-only"><a class="header" href="#ax0xax1x---latch-accelerometer-write-only">Ax0x/Ax1x - Latch Accelerometer (Write Only)</a></h3>
<p>Write 55h to Ax0x to erase the latched data (reset back to 8000) then
AAh to Ax1x to latch the accelerometer and update the addressable
registers. Reads return FFh. Other writes do not appear to do anything
(Partially unconfirmed). Note that you cannot re-latch the accelerometer
value without first erasing it; attempts to do so yield no change.</p>
<h3 id="ax2xax3x---accelerometer-x-value-read-only"><a class="header" href="#ax2xax3x---accelerometer-x-value-read-only">Ax2x/Ax3x - Accelerometer X value (Read Only)</a></h3>
<p>Ax2x contains the low byte of the X value (lower values are towards the
right and higher values are towards the left), and Ax3x contains the
high byte. Reads 8000 before first latching.</p>
<h3 id="ax4xax5x---accelerometer-y-value-read-only"><a class="header" href="#ax4xax5x---accelerometer-y-value-read-only">Ax4x/Ax5x - Accelerometer Y value (Read Only)</a></h3>
<p>Ax4x contains the low byte of the Y value (lower values are towards the
bottom and higher values are towards the top), and Ax5x contains the
high byte. Reads 8000 before first latching.</p>
<h3 id="ax6xax7x---unknown"><a class="header" href="#ax6xax7x---unknown">Ax6x/Ax7x - Unknown</a></h3>
<p>Ax6x always reads 00h and Ax7x always reads FFh. Possibly reserved for Z
axis, which does not exist on this accelerometer.</p>
<h3 id="ax8x---eeprom-readwrite"><a class="header" href="#ax8x---eeprom-readwrite">Ax8x - EEPROM (Read/Write)</a></h3>
<p>Values in this register correspond to 4 pins on the EEPROM:</p>
<ul>
<li>Bit 0: Data Out (DO)</li>
<li>Bit 1: Data In (DI)</li>
<li>Bit 6: Clock (CLK or SK in existing code)</li>
<li>Bit 7: Chip Select (CS)</li>
</ul>
<p>The other pins (notably ORG, which controls 8-bit vs 16-bit addressing)
do not appear to be connected to this register.</p>
<p>Commands are sent to the EEPROM by shifting in a bitstream to DI while
manually clocking CLK. All commands must be preceded by a 1 bit, and
existing games precede the 1 bit with a 0 bit (though this is not
necessary):</p>
<ul>
<li>Write 00h (lower CS)</li>
<li>Write 80h (raise CS)</li>
<li>Write C0h (shift in 0 bit)</li>
<li>Write 82h (lower CS, raise DI)</li>
<li>Write C2h (shift in 1 bit)</li>
<li>Write command</li>
</ul>
<p>The following commands exist, each 10 bits (excluding data shifted in or
out). “x” means the value of this bit is ignored. “A” means the
relevant bit of the address. All data is shifted in or out MSB first.
Note that data is addressed 16 bits at a time, so address 1 corresponds
to bits 16-31, thus bytes 2-3.</p>
<ul>
<li>READ: 10xAAAAAAAb (then shift out 16 bits)</li>
<li>EWEN (Erase/Write enable): 0011xxxxxxb</li>
<li>EWDS (Erase/Write disable): 0000xxxxxxb</li>
<li>WRITE: 01xAAAAAAAb (then shift in 16 bits)</li>
<li>ERASE (fill address with FFFF): 11xAAAAAAAb</li>
<li>ERAL (fill EEPROM with FFFF): 0010xxxxxxb</li>
<li>WRAL (fill EEPROM with value): 0001xxxxxxb (then shift in 16 bits)</li>
</ul>
<p>All programming operations (WRITE/ERASE/WRAL/ERAL) must be preceded with
EWEN.</p>
<p>According to the datasheet, programming operations take time to settle.
Continue clocking and check the value of DO to verify if command is
still running. Data sheet says that the signal to DO is RDY, thus it
reads a 1 when the command finishes.</p>
<p>Datasheet:
<a href="http://ww1.microchip.com/downloads/en/DeviceDoc/21712C.pdf">1</a></p>
<h3 id="ax9x-axfx---unused"><a class="header" href="#ax9x-axfx---unused">Ax9x-AxFx - Unused</a></h3>
<p>Reads out FFh.</p>
<h3 id="b000-bfff---unknown"><a class="header" href="#b000-bfff---unknown">B000-BFFF - Unknown</a></h3>
<p>Only seems to read out FFh.</p>
<h3 id="0000-1fff---ram-enable-1-write-only"><a class="header" href="#0000-1fff---ram-enable-1-write-only">0000-1FFF - RAM Enable 1 (Write Only)</a></h3>
<p>Mostly the same as for MBC1, a value of 0Ah will enable reading and
writing to RAM registers. A value of 00h will disable it. Please note
that the RAM must second be enabled in the second RAM enable section as
well (4000-5FFF)</p>
<h3 id="2000-3fff---rom-bank-number-write-only-1"><a class="header" href="#2000-3fff---rom-bank-number-write-only-1">2000-3FFF - ROM Bank Number (Write Only)</a></h3>
<p>The ROM bank number goes here.</p>
<h3 id="4000-5fff---ram-enable-2-write-only"><a class="header" href="#4000-5fff---ram-enable-2-write-only">4000-5FFF - RAM Enable 2 (Write Only)</a></h3>
<p>Writing 40h to this region enables access to the RAM registers. Writing
any other value appears to disable access to RAM, but this is not fully
tested. Please note that the RAM must first be enabled in the first RAM
enable section as well (0000-1FFF)</p>
<h2 id="external-links-1"><a class="header" href="#external-links-1">External links</a></h2>
<ul>
<li>Source: <a href="http://gbdev.gg8.se/forums/viewtopic.php?id=448">GBDev Forums thread by endrift</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mmm01"><a class="header" href="#mmm01">MMM01</a></h1>
<p>The MMM01 is a mapper specific to multi-game compilation cartridges. It emulates an MBC1 for the contained games, and supports containing a mix of games from 32 KiB ROMs with no RAM, up to the same maximum memory <em>per game</em> as the MBC1:</p>
<ul>
<li>max 512 KiB ROM with banked 8, 16, or 32 KiB RAM (default configuration)</li>
<li>max 2 MiB ROM with unbanked 8 KiB RAM (“multiplex” mode, never used commercially)</li>
</ul>
<p>Regardless of the size or number of the games in the compilation, the maximum total cartridge size supported by the MMM01 is the same: up to 8 MiB ROM and 128 KiB RAM.</p>
<p>The ROM and RAM banking numbers are extended compared to the MBC1 to allow for game selection, and
the lower bits (equivalent to the MBC1 bank registers) can be masked so some of those bits can also be used for game selection (for smaller games).
This allows up to 255x 32 KiB games, plus a 32 KiB menu, in an 8 MiB ROM.
RAM is more limited at only up to 16x 8 KiB RAM banks.
However, despite these generous capabilities, no MMM01 cartridge was released with more than 4 games, and only <em>one</em> contains any RAM at all.</p>
<p>The ROM and RAM “game select” banking bits do not have to be set to the same value, this allows an MMM01 cartridge to not waste RAM space on games that do not have RAM, or mix and match games that have differently-sized ROM or RAM by packing them in tightly in the overall ROM/RAM of the cartridge.</p>
<div class="box warning">
<p>The MMM01 can’t completely block access to RAM for a game, so if the cartridge contains RAM it’s recommended to assign any no-RAM games to the same single RAM bank to prevent no-RAM games from accessing or corrupting other games’ save RAM.</p>
</div>
<p>MMM01 starts up in a unique mode (“unmapped”) which always maps the <strong>last</strong> 32 KiB of the ROM to the 0000-7FFF address region regardless of the values in the bank/mode registers.
The correct ROM header (with Nintendo logo) therefore needs to be located at offset <code>(size - 32 KiB) + $100</code> in the ROM rather than the usual <code>$0000 + $100</code> (which contains the header of the first game in the collection instead).
MMM01 cartridges have a simple menu program in this last 32 KiB, which manipulates the additional MMM01 control bits, allowing game selection and setting the game size, before entering “mapped” mode and booting the selected game (see “Mapping Enable” below).</p>
<p>As the last 32 KiB of the ROM are reserved for the cartridge menu, it’s best to pack games into the ROM from largest to smallest to avoid having a game overlap the menu.
For example, the Taito Variety Pack contains three 128 KiB games and one 64 KiB game in a 512 KiB ROM chip, leaving 32 KiB unused and 32 KiB for the menu.</p>
<h2 id="memory-6"><a class="header" href="#memory-6">Memory</a></h2>
<h3 id="0000-3fff---rom-bank-x0-read-only"><a class="header" href="#0000-3fff---rom-bank-x0-read-only">0000-3FFF - ROM Bank $X0 (Read Only)</a></h3>
<p>On startup (in “unmapped” mode), this is mapped to the first half of the menu program in the last 32 KiB of the ROM.</p>
<p>When a game is mapped, this area normally contains the first 16 KiB (bank 00) of the game ROM.</p>
<p>If [multiplex is enabled[(&lt;#Multiplex Enable&gt;)], entering mode 1 allows mapping game ROM banks $20, $40, and $60 to this region.</p>
<h4 id="addressing-diagrams-1"><a class="header" href="#addressing-diagrams-1">Addressing diagrams</a></h4>
<p>When “unmapped”:</p>
<pre><code>                                    /------------- In a smaller cartridge, only the needed
                                    |              bits are used (e.g 512 KiB uses 19 bits)
                  /---------------------------\
Bits: 22 21 20 19 18 17 16 15 14 13 12 .. 01 00
      \_____________________/  | \____________/
                 |             |      \----------- From Game Boy address
                 |             \------------------ Always 0
                 \-------------------------------- Always 1
</code></pre>
<p>Mapped, multiplex disabled:</p>
<pre><code>Bits: 22 21 20 19 18 17 16 15 14 13 12 .. 01 00
      \___/ \___/ \____________/ \____________/
        |     |          |            \----------- From Game Boy address
        |     |          \------------------------ bitwise and of ROM Bank Low &amp; ROM Bank Mask
        |     \----------------------------------- ROM Bank Mid
        \----------------------------------------- ROM Bank High
</code></pre>
<h3 id="4000-7fff---rom-bank-01-7f-read-only-1"><a class="header" href="#4000-7fff---rom-bank-01-7f-read-only-1">4000-7FFF - ROM Bank $01-7F (Read Only)</a></h3>
<p>On startup (in “unmapped” mode), this is mapped to the second half of the menu program in the last 32 KiB of the ROM.</p>
<p>When a game is mapped, this area may contain any of the further 16 KiB banks of the game ROM, except for game banks $00, $20, $40, or $60.
If one of those banks is selected, the low bit is forced to 1 and that bank is mapped instead ($01, $21, $41, or $61).</p>
<p>i.e. in mapped mode, if <code>(ROM Bank Low) &amp; ~(ROM Bank Mask)</code> is equal to $00 (indicating bank $00 within the game ROM), <code>(ROM Bank Low) | 1</code> is used instead.
As an example, if ROM Bank Low is set to $10, and the ROM Bank Mask is set to $30, then the bank within the game ROM would be <code>($10) &amp; ~($30) = $00</code>.
As game bank $00 is disallowed, the low bit is forced on, mapping bank $11 instead of $10.</p>
<p>If [multiplex is enabled[(&lt;#Multiplex Enable&gt;)], the MMM01 has the same limitation as MBC1 regarding accessing game ROM banks $20, $40, and $60 - they can only be mapped to 0000-3FFF (in mode 1), and not to 4000-7FFF.</p>
<h4 id="addressing-diagrams-2"><a class="header" href="#addressing-diagrams-2">Addressing diagrams</a></h4>
<p>When “unmapped”:</p>
<pre><code>Bits: 22 21 20 19 18 17 16 15 14 13 12 .. 01 00
      \_____________________/  | \____________/
                 |             |      \----------- From Game Boy address
                 |             \------------------ Always 1? See note
                 \-------------------------------- Always 1
</code></pre>
<div class="box warning">
<p class="box-title">TO BE VERIFIED</p><p>It’s suspected the lowest bit of ROM Bank Low (post $00 -&gt; $01 remapping) still affects the bank mapped to the 4000-7FFF region in “unmapped” mode the same as it does in mapped mode.
Most of the time this would still be a 1, but during game selection it could momentarily go to 0 in between setting the game select bits in <a href="#bits-0-4-rom-bank-low">ROM Bank Low</a> and masking them as such in <a href="#bits-1-5-rom-bank-mask">ROM Bank Mask</a>.</p>
</div>
<p>Mapped, multiplex disabled:</p>
<pre><code>Bits: 22 21 20 19 18 17 16 15 14 13 12 .. 01 00
      \___/ \___/ \____________/ \____________/
        |     |          |            \----------- From Game Boy address
        |     |          \------------------------ ROM Bank Low (complete value, not masked)
        |     |                                     anti-masked $00 is remapped to $01 (see explanation above)
        |     \----------------------------------- ROM Bank Mid
        \----------------------------------------- ROM Bank High
</code></pre>
<h3 id="a000-bfff---ram-bank-00-03-if-any-readwrite-1"><a class="header" href="#a000-bfff---ram-bank-00-03-if-any-readwrite-1">A000-BFFF - RAM Bank $00-03, if any (Read/Write)</a></h3>
<p>This area is used to address external SRAM in the cartridge (if any).
The RAM is only accessible <a href="#0000-1fff---ram-enable-write-only">if RAM is enabled</a>, otherwise reads return open bus values (often $FF, but not guaranteed) and writes are ignored.</p>
<p>External RAM is often battery-backed, allowing for the storage of game data while the Game Boy is turned off, or if the cartridge is removed from the Game Boy.</p>
<p>It is currently unknown whether RAM access is possible while in unmapped mode.</p>
<h4 id="addressing-diagrams-3"><a class="header" href="#addressing-diagrams-3">Addressing diagrams</a></h4>
<p>In mode 0:</p>
<pre><code>Bits: 16 15 14 13 12 .. 01 00
      \___/ \___/ \_________/
        |     |        \-------- From Game Boy address
        |     \----------------- bitwise and of RAM Bank Low &amp; RAM Bank Mask
        \----------------------- RAM Bank High
</code></pre>
<p>In mode 1:</p>
<pre><code>Bits: 16 15 14 13 12 .. 01 00
      \___/ \___/ \_________/
        |     |        \-------- From Game Boy address
        |     \----------------- RAM Bank Low (complete value, not masked)
        \----------------------- RAM Bank High
</code></pre>
<h2 id="registers-7"><a class="header" href="#registers-7">Registers</a></h2>
<p>The MMM01 registers are extensions of the MBC1 registers.
In “mapped” mode, the extra bits cannot be written to, and the MMM01 emulates an MBC1.
In “unmapped” mode, the extra bits are writeable, allowing the menu program to select which game to play and configure its size and RAM access.</p>
<p>All the MMM01 registers are 7-bits in size and set to $00 on power-up.
For the ROM Bank Number register, this behaves as if it was set to $01.</p>
<h3 id="0000-1fff---ram-enable-write-only-1"><a class="header" href="#0000-1fff---ram-enable-write-only-1">0000-1FFF - RAM Enable (Write Only)</a></h3>
<pre><code>Bits: X 6 5 4 3 2 1 0
        | \_/ \_____/
        |  |      \----- Bits 0-3: RAM Enable
        |  \------------ Bits 4-5: RAM Bank Mask
        \--------------- Bit 6: Mapping Enable
</code></pre>
<h4 id="bits-0-3-ram-enable"><a class="header" href="#bits-0-3-ram-enable">Bits 0-3: RAM Enable</a></h4>
<p>As per MBC1, writing $Ah to the lower 4 bits enables the external RAM, and any other value disables it.
The external RAM is automatically disabled when the Game Boy is powered off or the cartridge is removed.</p>
<h4 id="bits-4-5-ram-bank-mask"><a class="header" href="#bits-4-5-ram-bank-mask">Bits 4-5: RAM Bank Mask</a></h4>
<p><em>Can only be changed in “unmapped” mode.</em></p>
<p>These two bits act as “write locks” to the matching bits in the RAM Bank Low register.
Any attempt to write to those bits while its matching bit in this register is 1 is prevented.
Writes to masked bits are prevented even in “unmapped” mode.</p>
<p>The purpose of the mask is to lock some RAM banking bits as “game selection”, instead of letting games freely toggle them.
Setting these bits effectively reduces the size of the ram available to the game that’s about to be booted:</p>
<div class="table-wrapper"><table><thead><tr><th>Mask</th><th>Game RAM</th></tr></thead><tbody>
<tr><td>00</td><td>32 KiB</td></tr>
<tr><td>10</td><td>16 KiB</td></tr>
<tr><td>11</td><td>8 KiB</td></tr>
</tbody></table>
</div>
<p>If [multiplex is enabled[(&lt;#Multiplex Enable&gt;)], this mask still applies to the RAM Bank Low register, even though that register is used as part of the <strong>ROM</strong> bank number in multiplex mode.
This has the effect of reducing the ROM size instead of the RAM size, as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Mask</th><th>Game ROM</th></tr></thead><tbody>
<tr><td>00</td><td>2 MiB</td></tr>
<tr><td>10</td><td>1 MiB</td></tr>
<tr><td>11</td><td>512 KiB*</td></tr>
</tbody></table>
</div>
<p>Setting the RAM Bank Mask to 11 when multiplex is enabled is pointless - the whole point of multiplex mode is to support 1 MiB or larger MBC1 games.</p>
<h4 id="bit-6-mapping-enable"><a class="header" href="#bit-6-mapping-enable">Bit 6: Mapping Enable</a></h4>
<p><em>Can only be changed in “unmapped” mode.</em></p>
<p>When writing 1 to this bit, the MMM01 enters “mapped” mode. This immediately begins MBC1 emulation, mapping in the selected banks of the game ROM (typically $00 and $01 within the game’s subsection of the cartridge ROM) and prevents write access to any of the MMM01 extended control bits.</p>
<p>It is unknown if setting bit 6 to enter “mapped” mode will honor or ignore the value simultaneously being written to bits 4-5 (RAM Bank Mask).
The only released MMM01 cartridge containing RAM performs two separate writes to set the bank mask before enabling mapping, with the same mask set in both writes.</p>
<h3 id="2000-3fff---rom-bank-number-write-only-2"><a class="header" href="#2000-3fff---rom-bank-number-write-only-2">2000-3FFF - ROM Bank Number (Write Only)</a></h3>
<pre><code>Bits: X 6 5 4 3 2 1 0
        \_/ \_______/
         |       \------ Bits 0-4: ROM Bank Low
         \-------------- Bits 5-6: ROM Bank Mid
</code></pre>
<h4 id="bits-0-4-rom-bank-low"><a class="header" href="#bits-0-4-rom-bank-low">Bits 0-4: ROM Bank Low</a></h4>
<p>This is equivalent to the MBC1 ROM Bank register, and primarily selects which bank of the game ROM is visible in the 4000-7FFF region.
It can be masked to reduce its size, reserving some bits for game select (see <a href="#bits-1-5-rom-bank-mask">ROM Bank Mask</a>).</p>
<p>If the <em>unmasked</em> bits are all 0, it behaves as if the lowest bit is set to 1 (as per MBC1 behaviour, attempting to map bank $00 of the game ROM maps bank $01 instead).
However, the actual value of the register doesn’t change, as changes to <a href="#bits-1-5-rom-bank-mask">ROM Bank Mask</a> can undo this remapping.</p>
<h4 id="bits-5-6-rom-bank-mid"><a class="header" href="#bits-5-6-rom-bank-mid">Bits 5-6: ROM Bank Mid</a></h4>
<p><em>Can only be changed in “unmapped” mode.</em></p>
<p>This register represents an additional two bits of ROM bank number, for game selection.
Affects both the 0000-3FFF and 4000-7FFF region.
Can only be used for game selection, as it’s not writeable once entering a game (mapped mode).</p>
<p>If [multiplex is enabled[(&lt;#Multiplex Enable&gt;)], functionality is swapped with <a href="#bits-0-1-ram-bank-low">RAM Bank Low</a> allowing for larger game ROM.</p>
<h3 id="4000-5fff---ram-bank-number-write-only-1"><a class="header" href="#4000-5fff---ram-bank-number-write-only-1">4000-5FFF - RAM Bank Number (Write Only)</a></h3>
<pre><code>Bits: X 6 5 4 3 2 1 0
        | \_/ \_/ \_/
        |  |   |   \---- Bits 0-1: RAM Bank Low
        |  |   \-------- Bits 2-3: RAM Bank High
        |  \------------ Bits 4-5: ROM Bank High
        \--------------- Bit 6: MBC1 Mode Write Disable
</code></pre>
<h4 id="bits-0-1-ram-bank-low"><a class="header" href="#bits-0-1-ram-bank-low">Bits 0-1: RAM Bank Low</a></h4>
<p>This is equivalent to the MBC1 RAM Bank register.
It can be masked to reduce its size, reserving some bits for game select (see <a href="#bits-4-5-ram-bank-mask">RAM Bank Mask</a>).</p>
<p>If [multiplex is enabled[(&lt;#Multiplex Enable&gt;)], functionality is swapped with <a href="#bits-5-6-rom-bank-mid">ROM Bank Mid</a> allowing for larger game ROM.</p>
<h4 id="bits-1-2-ram-bank-high"><a class="header" href="#bits-1-2-ram-bank-high">Bits 1-2: RAM Bank High</a></h4>
<p><em>Can only be changed in “unmapped” mode.</em></p>
<p>This register represents an additional two bits of RAM bank number, for game selection.
Can only be used for game selection, as it’s not writeable once entering a game (mapped mode).</p>
<h4 id="bits-4-5-rom-bank-high"><a class="header" href="#bits-4-5-rom-bank-high">Bits 4-5: ROM Bank High</a></h4>
<p><em>Can only be changed in “unmapped” mode.</em></p>
<p>This register represents <em>another</em> two bits of ROM bank number, for game selection.
Affects both the 0000-3FFF and 4000-7FFF region.
Can only be used for game selection, as it’s not writeable once entering a game (mapped mode).</p>
<h4 id="bit-6-mbc1-mode-write-lock"><a class="header" href="#bit-6-mbc1-mode-write-lock">Bit 6: MBC1 Mode Write Lock</a></h4>
<p><em>Can only be changed in “unmapped” mode.</em></p>
<p>When set to 1, prevents changes to the <a href="#bit-0-mbc1-mode-select">MBC1 Mode Select</a>.
This might be for compatibility with games designed for non-MBC1 mappers that don’t expect the MBC1 mode select register to exist.</p>
<h3 id="6000-7fff---banking-mode-select-write-only"><a class="header" href="#6000-7fff---banking-mode-select-write-only">6000-7FFF - Banking Mode Select (Write Only)</a></h3>
<pre><code>Bits: X 6 5 4 3 2 X 0
        | \_______/ |
        |    |      \--- MBC1 Mode Select
        |    \---------- ROM Bank Mask
        \--------------- Multiplex Enable
</code></pre>
<h4 id="bit-0-mbc1-mode-select"><a class="header" href="#bit-0-mbc1-mode-select">Bit 0: MBC1 Mode Select</a></h4>
<p>This is equivalent to the MBC1 Mode Select register.</p>
<p>This 1-bit register selects between the two MBC1 banking modes.
The behaviour varies depending on whether multiplex is enabled or disabled.</p>
<p><strong>Multiplex disabled</strong></p>
<ul>
<li>0 = RAM Banking Disabled (default)</li>
<li>1 = RAM Banking Enabled</li>
</ul>
<p>In mode 0, the A000-BFFF region is locked to bank 0 of the game RAM.
The unmasked bits of <a href="#bits-0-1-ram-bank-low">RAM Bank Low</a> are treated as 0.</p>
<p>In mode 1, the A000-BFFF region can be bank-switched by the game as the full RAM Bank Low register is used.</p>
<p><strong>Multiplex enabled</strong></p>
<ul>
<li>0 = Simple ROM Banking Mode (default)</li>
<li>1 = Advanced ROM Banking Mode</li>
</ul>
<p>In mode 0, the 0000-3FFF region is locked to bank 0 of the game ROM.
The unmasked bits of <a href="#bits-0-1-ram-bank-low">RAM Bank Low</a> are treated as 0 for accesses to the 0000-3FFF region, matching the behaviour of <a href="#bits-0-4-rom-bank-low">ROM Bank Low</a>.</p>
<p>In mode 1, the 0000-3FFF region can be bank-switched using the RAM Bank Low register — allowing access to game ROM banks $20, $40, and $60.</p>
<h4 id="bits-1-5-rom-bank-mask"><a class="header" href="#bits-1-5-rom-bank-mask">Bits 1-5: ROM Bank Mask</a></h4>
<p><em>Can only be changed in “unmapped” mode.</em></p>
<p>These five bits act as “write locks” to the matching bits in the <a href="#bits-0-4-rom-bank-low">ROM Bank Low</a> register.
Any attempt to write to the bits in ROM Bank Low while its matching bit in this register is 1 is prevented.
Writes to masked bits are prevented even in “unmapped” mode.</p>
<p>The value written to the lowest bit of the mask is ignored, and treated as always zero.
As a result, the lowest bit of ROM Bank Low is always writeable.</p>
<p>The purpose of the mask is to lock some ROM banking bits as “game selection”, instead of letting games freely toggle them.
Setting these bits effectively reduces the size of the ROM accessible to the game that’s about to be booted:</p>
<div class="table-wrapper"><table><thead><tr><th>Mask</th><th>Game ROM</th></tr></thead><tbody>
<tr><td>00000</td><td>512 KiB</td></tr>
<tr><td>10000</td><td>256 KiB</td></tr>
<tr><td>11000</td><td>128 KiB</td></tr>
<tr><td>11100</td><td>64 KiB</td></tr>
<tr><td>11110</td><td>32 KiB</td></tr>
</tbody></table>
</div>
<p>Note: changing the mask can alter which bank would be mapped.
Only the <em>unmasked</em> bits of <a href="#bits-0-4-rom-bank-low">ROM Bank Low</a> are used for the “<a href="#4000-7fff---rom-bank-01-7f-read-only">attempting to map bank 0 maps bank 1</a>” logic, and it updates live if the ROM Bank Mask changes.
ROM Bank Low itself doesn’t change when this happens — only the value used for calculating the bank number.</p>
<p>If [multiplex is enabled[(&lt;#Multiplex Enable&gt;)], the <a href="#bits-4-5-ram-bank-mask">RAM Bank Mask</a> affects ROM banking as well.
In this case the ROM Bank Mask should be set to 00000 to avoid masking bits in the <em>middle</em> of the full game ROM bank number.</p>
<h4 id="multiplex-enable"><a class="header" href="#multiplex-enable">Multiplex Enable</a></h4>
<p><em>Can only be changed in “unmapped” mode.</em></p>
<p>When set to 1, swaps the functionality of <a href="#bits-0-1-ram-bank-low">RAM Bank Low</a> and <a href="#bits-5-6-rom-bank-mid">ROM Bank Mid</a>.
As RAM Bank Low is writeable in mapped mode, this allows for the contained game to control (up to, if unmasked in “RAM Bank Mask”) two extra bits of the full ROM bank number, allowing for larger game ROMs at the cost of only 8 KiB of external RAM.</p>
<p>This is equivalent to the <a href="#mbc1">“large ROM” wiring of an MBC1 cartridge</a>.</p>
<h2 id="multiplex-addressing-diagrams"><a class="header" href="#multiplex-addressing-diagrams">Multiplex addressing diagrams</a></h2>
<p>If [multiplex is enabled[(&lt;#Multiplex Enable&gt;)], the addressing diagrams change as follows (changes marked with <code>*</code>):</p>
<h3 id="0000-3fff---rom-bank-x0"><a class="header" href="#0000-3fff---rom-bank-x0">0000-3FFF - ROM Bank X0</a></h3>
<p>No change to “unmapped” mode.</p>
<p>Mapped, Multiplexed, Mode 0:</p>
<pre><code>Bits: 22 21 20 19 18 17 16 15 14 13 12 .. 01 00
      \___/ \___/ \____________/ \____________/
        |     |          |            \----------- From Game Boy address
        |     |          \------------------------ bitwise and of ROM Bank Low &amp; ROM Bank Mask
        |     \----------------------------------- * bitwise and of RAM Bank Low &amp; RAM Bank Mask
        \----------------------------------------- ROM Bank High
</code></pre>
<p>Mapped, Multiplexed, Mode 1:</p>
<pre><code>Bits: 22 21 20 19 18 17 16 15 14 13 12 .. 01 00
      \___/ \___/ \____________/ \____________/
        |     |          |            \----------- From Game Boy address
        |     |          \------------------------ bitwise and of ROM Bank Low &amp; ROM Bank Mask
        |     \----------------------------------- * RAM Bank Low (complete value, not masked)
        \----------------------------------------- ROM Bank High
</code></pre>
<h5 id="4000-7fff---rom-bank-01-7f"><a class="header" href="#4000-7fff---rom-bank-01-7f">4000-7FFF - ROM Bank 01-7F</a></h5>
<p>No change to “unmapped” mode.</p>
<p>Mapped, Multiplexed, Mode 0 or 1:</p>
<pre><code>Bits: 22 21 20 19 18 17 16 15 14 13 12 .. 01 00
      \___/ \___/ \____________/ \____________/
        |     |          |            \----------- From Game Boy address
        |     |          \------------------------ ROM Bank Low (complete value, not masked)
        |     \----------------------------------- * RAM Bank Low (complete value, not masked)
        \----------------------------------------- ROM Bank High
</code></pre>
<h5 id="a000-bfff---ram-bank-00-03"><a class="header" href="#a000-bfff---ram-bank-00-03">A000-BFFF - RAM Bank 00-03</a></h5>
<p>Multiplexed, Mode 0 or 1:</p>
<pre><code>Bits: 16 15 14 13 12 .. 01 00
      \___/ \___/ \_________/
        |     |        \-------- From Game Boy address
        |     \----------------- * ROM Bank Mid
        \----------------------- RAM Bank High
</code></pre>
<h2 id="operation-notes"><a class="header" href="#operation-notes">Operation Notes</a></h2>
<p>Because the MMM01 has registers which disable write access to other registers, it is optimal to set the value of certain registers before others. The optimal order is:</p>
<ol>
<li>ROM Bank Register ($2000) — contains ROM Bank</li>
<li>Mode Register ($6000) — contains ROM Bank Mask, and Mode</li>
<li>RAM Register ($4000) — contains Mode Write Disable, and RAM Bank</li>
<li>RAM Enable ($0000) — contains RAM Bank Mask, and Mapping Enable</li>
</ol>
<p>The majority of released MMM01 cartridges stick to this order.</p>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<ul>
<li>Source: <a href="https://wiki.tauwasser.eu/view/MMM01">MMM01</a> on tauwasser wiki</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m161"><a class="header" href="#m161">M161</a></h1>
<p>The M161 is a simple multi-cart mapper by Mani (Nintendo’s official Chinese distributor). 
This mapper only allows for 8 separate 32 KiB banks, with a limit of 1 bankswitch, preventing any bankswitches afterward.
This gives 1 bank for the main menu, and a maximum of 7 different 32 KiB games.
This mapper does not support SRAM, so only purely MBC-less titles can be used.</p>
<p>This mapper is only known to be used in a single cartridge: Mani’s 4 in 1 cartridge, which contains Tetris, Tennis, Alleyway, and Yakuman.
All later Mani 4 in 1 cartridges use <a href="#mmm01">the MMM01 mapper</a>, so the M161 mapper could be considered the predecessor to the MMM01.</p>
<p>The mapper is really just a simple off-the-shelf 74HC161A used a flip-flop.
The 74HC161A contains 4 input pins and 4 output pins, and another pin for latching the input pins to the output pins.
The first 3 of the input pins are connected to the lower 3 bits of incoming write data, with the 4th pin kept high.
The first 3 of the output pins are connected to the ROM addressing pins (RA15-RA17).
The 4th output pin (which corresponds to the always high input pin) is connected to the latching pin.
Bit 15 of the write address is also connected to (OR’d with) the latching pin.
The latching pin latches the input pins to the output pins on a transition from high to low, so when a ROM write comes through (bit 15 = 0), the input pins will be latched to the output pins.
Since 4th output pin will be high, the signal cannot become low anymore, thus preventing further bankswitches.</p>
<h2 id="memory-7"><a class="header" href="#memory-7">Memory</a></h2>
<h3 id="0000-7fff--rom-bank-00-07-read-only"><a class="header" href="#0000-7fff--rom-bank-00-07-read-only">0000-7FFF — ROM Bank $00-$07 [read only]</a></h3>
<p>This area contains a 32 KiB bank of ROM.
On startup, this will contain the first 32 KiB of ROM (bank 0).</p>
<h2 id="registers-8"><a class="header" href="#registers-8">Registers</a></h2>
<h3 id="0000-7fff--rom-bank-number-write-only"><a class="header" href="#0000-7fff--rom-bank-number-write-only">0000-7FFF — ROM Bank Number [write only]</a></h3>
<p>This 3-bit register (range $00-$07) selects the ROM bank number for the $0000-$7FFF region.
Like other mappers, the high bits are discarded.</p>
<p>Only 1 bankswitch is allowed per session, once any write to this register occurs (even if set to 0), all future writes will be ignored until the mapper is powered down.</p>
<h2 id="operation-notes-1"><a class="header" href="#operation-notes-1">Operation Notes</a></h2>
<p>Because the full 32 KiB range is switched over, caution should be taken, as the entire ROM range will change.
It may be best to have the bankswitch code placed right before $0100, so as to fall through to <a href="#0100-0103--entry-point">the game’s init sequence</a>.</p>
<h3 id="references-1"><a class="header" href="#references-1">References</a></h3>
<ul>
<li>Source: <a href="https://pics.tauwasser.eu/image/schematic-dmg-m161-m01-v10.pdDz">M161 Schematic</a> on tauwasser pics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="huc1"><a class="header" href="#huc1">HuC1</a></h1>
<p>HuC1 is an MBC developed by Hudson Soft. It implements ROM and RAM
banking, and also provides infrared communication.
Despite many sources on the internet claiming that HuC1 is “similar to MBC1”, it actually differs from MBC1 significantly.</p>
<h2 id="memory-map-1"><a class="header" href="#memory-map-1">Memory Map</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Address range</th><th>Feature</th></tr></thead><tbody>
<tr><td>$0000–1FFF</td><td>RAM/IR select (when writing only)</td></tr>
<tr><td>$2000–3FFF</td><td>ROM bank select (when writing only)</td></tr>
<tr><td>$4000–5FFF</td><td>RAM bank select (when writing only)</td></tr>
<tr><td>$6000–7FFF</td><td>Nothing?</td></tr>
<tr><td>$A000–BFFF</td><td>Cart RAM or IR register</td></tr>
</tbody></table>
</div>
<h3 id="00001fff--ir-select-write-only"><a class="header" href="#00001fff--ir-select-write-only">0000–1FFF — IR Select [write-only]</a></h3>
<p>Most MBCs can disable the cartridge RAM to prevent accidental writes.
HuC1 doesn’t do this. Instead, this register swtiches the $A000–BFFF
region between “RAM mode” and “IR mode” (described below). Write $0E to
switch to IR mode, or anything else to switch to RAM mode.</p>
<p>Some HuC1 games still write $0A and $00 to this region as if it would
enable/disable cart RAM.</p>
<h3 id="20003fff--rom-bank-number-write-only-1"><a class="header" href="#20003fff--rom-bank-number-write-only-1">2000–3FFF — ROM Bank Number [write-only]</a></h3>
<p>HuC1 can accept a bank number of at least 6 bits here.</p>
<h3 id="40005fff--ram-bank-select-write-only"><a class="header" href="#40005fff--ram-bank-select-write-only">4000–5FFF — RAM Bank Select [write-only]</a></h3>
<p>HuC1 can accept a bank number of at least 2 bits here.</p>
<h3 id="60007fff--nothing-write-only"><a class="header" href="#60007fff--nothing-write-only">6000–7FFF — Nothing? [write-only]</a></h3>
<p>Writes to this region seem to have no effect. Even so, some games do
write to this region, as if it had the same effect as on MBC1. You may
safely ignore these writes.</p>
<h3 id="a000bfff--cart-ram-or-ir-register-readwrite"><a class="header" href="#a000bfff--cart-ram-or-ir-register-readwrite">A000–BFFF — Cart RAM or IR register [read/write]</a></h3>
<p>When in “IR mode” (wrote $0E to $0000), the IR register is visible
here. Write to this region to control the IR transmitter. $01 turns it
on, $00 turns it off. Read from this region to see either $C1 (saw
light) or $C0 (did not see light).</p>
<p>When in “RAM mode” (wrote something other than $0E to $0000) this region
behaves like normal cart RAM.</p>
<h2 id="external-links-2"><a class="header" href="#external-links-2">External links</a></h2>
<ul>
<li><a href="http://jrra.zone/blog/huc1.html">Source on jrra.zone</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="huc-3"><a class="header" href="#huc-3">HuC-3</a></h1>
<p>HuC-3 is an MBC developed by Hudson Soft. Besides ROM and RAM banking,
it also provides a real-time clock, speaker, and infrared communication.
The CR2025 coin cell is user-replaceable. It is a successor to the
<a href="./HuC1.html">HuC1</a>.</p>
<p>The HuC-3 is poorly understood. Observed behavior suggests the
real-time clock and tone generator are implemented using a 4-bit
microcontroller core with internal program ROM.</p>
<h2 id="memory-8"><a class="header" href="#memory-8">Memory</a></h2>
<h3 id="00003fff--rom-bank-00-read-only"><a class="header" href="#00003fff--rom-bank-00-read-only">0000–3FFF — ROM Bank 00 [read-only]</a></h3>
<p>Contains the first 16 KiB of the ROM.</p>
<h3 id="40007fff--rom-bank-007f-read-only"><a class="header" href="#40007fff--rom-bank-007f-read-only">4000–7FFF — ROM Bank 00–7F [read-only]</a></h3>
<p>This area may contain any of the further 16 KiB banks of the ROM. Like the MBC5,
bank $00 can also be mapped to this region.</p>
<h3 id="a000bfff--ram-bank-0003-or-rtcir-register-readwrite"><a class="header" href="#a000bfff--ram-bank-0003-or-rtcir-register-readwrite">A000–BFFF — RAM Bank 00–03, or RTC/IR register [read/write]</a></h3>
<p>Depending on the current register selection and RAM Bank Number (see
below), this memory space is used to access an 8 KiB external RAM Bank,
or a single I/O Register.</p>
<h2 id="memory-control-registers"><a class="header" href="#memory-control-registers">Memory Control Registers</a></h2>
<h3 id="00001fff--ramrtcir-select-readwrite"><a class="header" href="#00001fff--ramrtcir-select-readwrite">0000–1FFF — RAM/RTC/IR Select [read/write]</a></h3>
<p>Writing to this register maps cart RAM, RTC registers or IR registers
into memory at $A000–BFFF. Only the lower 4 bits are significant.</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Feature</th></tr></thead><tbody>
<tr><td>$0</td><td>Cart RAM (read-only)</td></tr>
<tr><td>$A</td><td>Cart RAM (read/write)</td></tr>
<tr><td>$B</td><td>RTC command/argument (write)</td></tr>
<tr><td>$C</td><td>RTC command/response (read)</td></tr>
<tr><td>$D</td><td>RTC semaphore (read/write)</td></tr>
<tr><td>$E</td><td>IR (read/write)</td></tr>
</tbody></table>
</div>
<p>If any other value is written, reads from $A000–BFFF return open bus
values (often $FF, but not guaranteed), and writes are ignored.</p>
<h3 id="20003fff--rom-bank-number-write-only-2"><a class="header" href="#20003fff--rom-bank-number-write-only-2">2000–3FFF — ROM Bank Number [write-only]</a></h3>
<p>HuC-3 can accept a 7-bit bank number here.</p>
<h3 id="40005fff--ram-bank-select-write-only-1"><a class="header" href="#40005fff--ram-bank-select-write-only-1">4000–5FFF — RAM Bank Select [write-only]</a></h3>
<p>HuC-3 can accept a bank number of at least 2 bits here.</p>
<h3 id="60007fff--nothing-write-only-1"><a class="header" href="#60007fff--nothing-write-only-1">6000–7FFF — Nothing? [write-only]</a></h3>
<p>Games write $01 here on startup, but it doesn’t seem to have any
observable effect.</p>
<h2 id="io-registers"><a class="header" href="#io-registers">I/O Registers</a></h2>
<p>These registers are accessed by reading or writing in the $A000–BFFF
range after setting the RAM/RTC/IR Select register. Address lines
A12–A0 are not connected to the HuC-3 chip, so the offset within the
range is ignored. Data line D7 is not connected to the HuC-3 chip, so
the most significant bit of reads always returns an open bus value
(usually high), and the most significant bit of writes is always
ignored.</p>
<p>The RTC MCU communication protocol is described below.</p>
<h3 id="b--rtc-commandargument-write"><a class="header" href="#b--rtc-commandargument-write">$B — RTC Command/Argument [write]</a></h3>
<p>The value written consists of a command in bits 6-4, and an argument
value in bits 3–0. For example the value $62 is command $6 with argument
value $2. Writing to this register just sets the values in the mailbox
registers – it does not cause the command to be executed.</p>
<h3 id="c--rtc-commandresponse-read"><a class="header" href="#c--rtc-commandresponse-read">$C — RTC Command/Response [read]</a></h3>
<p>When read, bits 6–4 return the last command written to register $B, and
bits 3–0 contain the result from the last command executed.</p>
<h3 id="d--rtc-semaphore-readwrite"><a class="header" href="#d--rtc-semaphore-readwrite">$D — RTC Semaphore [read/write]</a></h3>
<p>When reading, the least significant bit is high when the RTC MCU is
ready to receive a command, or low when the RTC MCU is busy.</p>
<p>Writing with the least significant bit clear requests that the RTC MCU
execute the last command written to register $B.</p>
<h3 id="e--ir-readwrite"><a class="header" href="#e--ir-readwrite">$E — IR [read/write]</a></h3>
<p>Similar to the equivalent register of the HuC1. The least significant
bit is used for infrared communication.</p>
<h2 id="rtc-communication-protocol"><a class="header" href="#rtc-communication-protocol">RTC Communication Protocol</a></h2>
<p>The HuC-3 chip provides read and write access to a 256-nybble window
into the RTC MCU’s internal memory. Multi-nybble values are stored with
the least significant nybble at the lowest address (little Endian).
There are commands for setting the access address, reading and writing
values, and a few higher-level operations.</p>
<p>Games use the following sequence to execute a command:</p>
<ul>
<li>Write $0D to $0000 (select RTC Semaphore register)</li>
<li>Poll $A000 until least significant bit is set (wait until ready)</li>
<li>Write $0B to $0000 (select RTC Command/Argument register)</li>
<li>Write command and argument to $A000</li>
<li>Write $0D to $0000 (select RTC semaphore register)</li>
<li>Write $FE to $A000 (clear semaphore, requesting MCU execute command)</li>
<li>Poll $A000 until least significant bit is set (wait for completion)</li>
<li>Write $0C to $0000 (select RTC Command/Response register)</li>
<li>Read $A000 and use value from 4 least significant bits</li>
</ul>
<p>(The last two steps are not applicable for commands that don’t produce a
response.)</p>
<p>Known commands:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>$1</td><td>Read value and increment access address</td></tr>
<tr><td>$3</td><td>Write value and increment access address</td></tr>
<tr><td>$4</td><td>Set access address least significant nybble</td></tr>
<tr><td>$5</td><td>Set access address most significant nybble</td></tr>
<tr><td>$6</td><td>Execute extended command specified by argument</td></tr>
</tbody></table>
</div>
<p>Pocket Family GB2 uses command $2 with argument $0, its purpose is
unknown. Commands $0 and $7 have not been observed.</p>
<p>The following extended commands have been observed:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>$0</td><td>Copy current time to locations $00–06</td></tr>
<tr><td>$1</td><td>Copy locations $00–06 to current time, and update event time</td></tr>
<tr><td>$2</td><td>Seems to be some kind of status request</td></tr>
<tr><td>$E</td><td>Executing twice triggers tone generator</td></tr>
</tbody></table>
</div>
<p>Commands $0 and $1 are used to read and write the current time
atomically. Writing the current time in this way also updates the event
time to maintain the remaining duration until the event occurs.</p>
<p>Command $2 is used on start and seems to be some kind of status
request. The games will not start if the result is not $1.</p>
<h3 id="rtc-location-map"><a class="header" href="#rtc-location-map">RTC Location Map</a></h3>
<p>The purpose of some locations has been inferred by observing behavior:</p>
<div class="table-wrapper"><table><thead><tr><th>Location</th><th>Purpose</th></tr></thead><tbody>
<tr><td>$00–06</td><td>Output or input space for reading or writing current time</td></tr>
<tr><td>$10–12</td><td>Minute of day counter (rolls over at 1440)</td></tr>
<tr><td>$13–15</td><td>Day counter</td></tr>
<tr><td>$26</td><td>Tone selection in two least significant bits</td></tr>
<tr><td>$27</td><td>Tone generator enabled if value is 1 (all bits checked)</td></tr>
<tr><td>$58–5A</td><td>Event time minutes</td></tr>
<tr><td>$5B–5D</td><td>Event time days</td></tr>
</tbody></table>
</div>
<h2 id="external-links-3"><a class="header" href="#external-links-3">External links</a></h2>
<ul>
<li>Source: <a href="https://gbdev.gg8.se/forums/viewtopic.php?id=744">GBDev Forums thread</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-mbcs"><a class="header" href="#other-mbcs">Other MBCs</a></h1>
<h2 id="multicart-mbcs"><a class="header" href="#multicart-mbcs">Multicart MBCs</a></h2>
<p><strong>MBC1M</strong> uses the MBC1 IC, but the board does not connect the MBC1’s
A18 address output to the ROM. This allows including multiple 2 Mbit (16
bank) games, with SRAM bank select ($4000) to select which of up to
four games is switched in. In theory, a MBC1M board could be made for 1
Mbit or 512 kbit games by additionally not connecting A17 and A16
outputs, but this appears not to have been done in licensed games.</p>
<p><strong>Bung</strong> and <strong>EMS</strong> MBCs are reported to exist.</p>
<h2 id="ems"><a class="header" href="#ems">EMS</a></h2>
<div class="box warning">
<p class="box-title">To be verified</p><p>Take the following with a grain of salt, as it hasn’t been verified on authentic EMS hardware. See related github issue to contribute: <a href="https://github.com/gbdev/pandocs/issues/423">#423</a>.</p>
</div>
<p>A <a href="#the-cartridge-header">header</a> matching any of the following is detected as EMS mapper:</p>
<ul>
<li>Header name is “EMSMENU”, NUL-padded</li>
<li>Header name is “GB16M”, NUL-padded</li>
<li>Cartridge type ($0147) = $1B and region ($014A) = $E1</li>
</ul>
<p>Registers:</p>
<ul>
<li>$2000 write: Normal behavior, plus save written value in $2000 latch</li>
<li>$1000 write: $A5 enables configure mode, $98 disables it, and other values have no known effect</li>
<li>$7000 write while configure mode is on: Copy $2000 latch to OR mask</li>
</ul>
<p>After the OR mask has been set, all reads from ROM will OR A21-A14 (the
bank number) with the OR mask. This chooses which game is visible to the
CPU. If the OR mask is not aligned to the game size, the results may be
nonsensical.</p>
<p>The mapper does not support an outer bank for battery SRAM.</p>
<p>To start a game, perform the following steps with code running from RAM:</p>
<ol>
<li>Write $A5 to $1000</li>
<li>Write game’s first bank number to $2000</li>
<li>Write any value to $7000</li>
<li>Write $98 to $1000</li>
<li>Write $01 to $2000 (so that 32K games work)</li>
<li>Jump to $0100</li>
</ol>
<h2 id="wisdom-tree"><a class="header" href="#wisdom-tree">Wisdom Tree</a></h2>
<p>The Wisdom Tree mapper is a simple, cost-optimized one-chip design
consisting of a 74LS377 octal latch in addition to the ROM chip. Because
the mapper consists of a single standard 74 series logic chip, it has
two unusual properties:</p>
<p>First, unlike a usual MBC, it switches the whole 32 KiB ROM area instead
of just the $4000-$7FFF area. Therefore, if you want to use <a href="#interrupt-handling">the interrupt vectors</a>
with this cart, you should duplicate them across all banks.
Additionally, since the 74LS377’s contents can’t be guaranteed when powering on,
the ROM header and some code for switching to a known bank should also
be included in every bank. This also means that the Wisdom Tree mapper
could be used as a multicart mapper for 32 KiB ROMs, assuming there is
enough ROM space in each bank for some small initialization code, and
none of the ROMs wrote to the $0000-$7FFF area. For example, if the
last 5 bytes of all banks are unused, games can be patched as follows:</p>
<pre><code class="language-rgbasm">; At $0100 in all banks but the first
    nop
    jp $7FFB
</code></pre>
<pre><code class="language-rgbasm">; At $7FFB in all banks
    ld hl, $0100
    ld [hl], a
    jp hl
</code></pre>
<p>Second, because the 74LS377 latches data on the <a href="https://www.allaboutcircuits.com/textbook/digital/chpt-10/edge-triggered-latches-flip-flops/"><em>positive</em> write pulse edge</a>,
and the value on the Game Boy data bus is no longer valid when the
positive edge arrives, the designer of this mapper chose to use the
A7-A0 address lines for selecting a bank instead of the data lines.
Thus, the value you write is ignored, and the lower 8 bits of the
address is used. For example, to select bank $XX, you would write any
value to address $YYXX, where $YY is in the range $00-$7F.</p>
<h2 id="magic-values-for-detection-of-multicarts-in-emulators"><a class="header" href="#magic-values-for-detection-of-multicarts-in-emulators">Magic values for detection of multicarts in emulators</a></h2>
<div class="box tip">
<p class="box-title">proposal</p><p>The following information should not be considered a universally adopted
standard, but it’s instead just a proposed solution. Actual adoption may vary.</p>
</div>
<p>Sometimes it may be useful to allow a ROM to be detected as a multicart
in emulator, for example for development of a menu for physical
multicart hardware. </p>
<p>Emulator authors who are interested in supporting the other multicart
mappers are also encouraged to support detection of the following values.</p>
<ul>
<li>Detect as Wisdom Tree mapper
<ul>
<li><a href="#0134-0143--title">ROM title</a> is “WISDOM TREE” (the space may be a
$00 NUL character instead), $0147 = $00, $0148 = $00, size &gt; 32k.
This method works for the games released by Wisdom Tree, Inc.</li>
<li>$0147 = $C0, $014A = $D1.</li>
</ul>
</li>
<li>Detect as EMS multicart
<ul>
<li>$0147 = $1b, $014a = $e1</li>
</ul>
</li>
<li>Detect as Bung multicart
<ul>
<li>$0147 = $be</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-boy-printer"><a class="header" href="#game-boy-printer">Game Boy Printer</a></h1>
<p>The Game Boy Printer is a portable thermal printer made by
<a href="https://en.wikipedia.org/wiki/Seiko_Instruments">SII</a> for Nintendo, which a few games used to
print out bonus artwork, certificates, pictures (<a href="#game-boy-camera">Game Boy
Camera</a>).</p>
<p>It can use standard 38mm paper and interfaces with the Game Boy through
the Link port.</p>
<p>It is operated by an embedded 8-bit microcontroller which has its own
8 KiB of RAM to buffer incoming graphics data. Those 8 KiB allow a maximum
bitmap area of 160*200 (8192/160*4) pixels between prints.</p>
<h2 id="communication"><a class="header" href="#communication">Communication</a></h2>
<p>The Game Boy Printer doesn’t use the full-duplex capability of the Link
port. It accepts variable length data packets and then answers back its
status after two $00 writes.</p>
<p>The packets all follow this format:</p>
<div class="table-wrapper"><table><thead><tr><th>Content</th><th>Size (bytes)</th><th>GB -&gt; Printer</th><th>Printer -&gt; GB</th></tr></thead><tbody>
<tr><td>Magic bytes</td><td>2</td><td>$88, $33</td><td>$00</td></tr>
<tr><td>Command</td><td>1</td><td>See below</td><td>$00</td></tr>
<tr><td>Compression flag</td><td>1</td><td>0/1</td><td>$00</td></tr>
<tr><td>Length of data</td><td>2</td><td>LSB, MSB</td><td>$00</td></tr>
<tr><td>Command-specific data</td><td>Variable</td><td>See below</td><td>$00</td></tr>
<tr><td>Checksum</td><td>2</td><td>LSB, MSB</td><td>$00</td></tr>
<tr><td>Alive indicator</td><td>1</td><td></td><td>$00</td></tr>
<tr><td>Status</td><td>1</td><td>See below</td><td>$00</td></tr>
</tbody></table>
</div>
<p>The checksum is simply a sum of every byte sent except the magic bytes
and obviously, the checksum itself.</p>
<h2 id="detection"><a class="header" href="#detection">Detection</a></h2>
<p>Send these 9 bytes: $88,$33,$0F,$00,$00,$00,$0F,$00 (Command
$0F, no data).</p>
<p>Send $00 and read input, if the byte is $81, then the printer is
there. Send a last $00, just for good measure. Input can be ignored.</p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<h3 id="command-1-initialize"><a class="header" href="#command-1-initialize">Command 1: Initialize</a></h3>
<p>This clears the printer’s buffer RAM.</p>
<p>No data required. The normal status replied should be $00.</p>
<h3 id="command-2-start-printing"><a class="header" href="#command-2-start-printing">Command 2: Start printing</a></h3>
<p>Data length: 4 bytes</p>
<ul>
<li>Byte 1: Number of sheets to print (0-255). 0 means line feed only.</li>
<li>Byte 2: Margins, high nibble is the feed before printing, low nibble
is after printing. GB Camera sends $13 by default.</li>
<li>Byte 3: Palette, typically $E4 (%11100100)</li>
<li>Byte 4: 7 bits exposure value, sets the burning time for the print
head. GB Camera sends $40 by default. Official manual mentions -25%
darkness for $00 and +25% for $7F.</li>
</ul>
<h3 id="command-4-fill-buffer"><a class="header" href="#command-4-fill-buffer">Command 4: Fill buffer</a></h3>
<p>Data length: max. $280 (160*16 pixels in 2BPP) To transfer more than
$280 bytes, multiple “command 4 packets” have to be sent.</p>
<p>The graphics are organized in the normal tile format (16 bytes per
tile), and the tiles are sent in the same order they occur on your
tilemap (do keep in mind though that the printer does *not* have 32x32
tiles space for a map, but only 20x18).</p>
<p>An empty data packet must be sent before sending command 2 to print the
data, otherwise the print command will be ignored.</p>
<h3 id="command-f-read-status"><a class="header" href="#command-f-read-status">Command $F: Read status</a></h3>
<p>No data required, this is a “nop” command used only to read the Status
byte.</p>
<h4 id="status-byte"><a class="header" href="#status-byte">Status byte</a></h4>
<p>A non-zero value for the higher nibble indicates something went wrong.</p>
<div class="table-wrapper"><table><thead><tr><th>Bit #</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>7</td><td>Low Battery</td><td>Set when the voltage is below threshold</td></tr>
<tr><td>6</td><td>Other error</td><td></td></tr>
<tr><td>5</td><td>Paper jam</td><td>Set when the encoder gives no pulses when the motor is powered</td></tr>
<tr><td>4</td><td>Packet error</td><td></td></tr>
<tr><td>3</td><td>Unprocessed data</td><td>Set when there’s unprocessed data in memory - AKA ready to print</td></tr>
<tr><td>2</td><td>Image data full</td><td></td></tr>
<tr><td>1</td><td>Currently printing</td><td>Set as long as the printer’s burnin’ paper</td></tr>
<tr><td>0</td><td>Checksum error</td><td>Set when the calculated checksum doesn’t match the received one</td></tr>
</tbody></table>
</div>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<ul>
<li>Send command 1, the answer should be $81, $00</li>
<li>Send command 4 with $280 of your graphics, the answer should still
be $81, $00</li>
<li>Ask for status with command $F, the answer should now be $81, $08
(ready to print)</li>
<li>Send an empty command 4 packet, the answer should still be $81,
$08</li>
<li>Send command 2 with your arguments (margins, palette, exposure), the
answer should still be $81, $08</li>
<li>Ask for status with command $F until it changes to $81, $06
(printing !)</li>
<li>Ask for status with command $F until it changes to $81, $04
(printing done)</li>
<li>Optionally send 16 zero bytes to clear the printer’s receive buffer
(GB Camera does it)</li>
</ul>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ul>
<li><strong>The printer has a timeout of 100ms for packets. If no packet is
received within that time, the printer will return to an initialized
state (meaning the link and graphics buffers are reset).</strong></li>
<li><strong>There appears to be an undocumented timeout for the bytes of a
packet. It’s best to send a packet completely or with very little
delay between the individual bytes, otherwise the packet may not be
accepted.</strong></li>
<li>To print things larger than 20x18 (like GB Camera images with big
borders), multiple data packets with a following print command need
to be sent. The print command should be set to no linefeed (neither
before nor after) to allow for continuous printing.</li>
</ul>
<h2 id="compression"><a class="header" href="#compression">Compression</a></h2>
<p>Some sort of RLE? The GB Camera doesn’t use it.</p>
<p>(<a href="http://furrtek.free.fr/?a=gbprinter&amp;i=2">Details and pictures</a>, need
to be copied here)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-boy-camera"><a class="header" href="#game-boy-camera">Game Boy Camera</a></h1>
<div class="box tip">
<p class="box-title">SOURCE</p><p>This section was originally compiled by Antonio Niño Díaz during his work on reverse engineering the Game Boy Camera. The upstream source can be found <a href="https://github.com/AntonioND/gbcam-rev-engineer">here</a>.</p>
</div>
<h2 id="camera-cartridge"><a class="header" href="#camera-cartridge">Camera Cartridge</a></h2>
<p>The Game Boy Camera cartridge contains 4 ICs: the usual ROM and RAM ICs, a big controller IC (like a MBC) and a sensor (M64282FP “retina” chip).</p>
<p>The main board contains all ICs except from the sensor.</p>
<div class="table-wrapper"><table><thead><tr><th>Component#</th><th>Part#/inscription</th><th>Description</th></tr></thead><tbody>
<tr><td>U1</td><td>MAC-GBD Nintendo 9807 SA</td><td>I/O, memory control.</td></tr>
<tr><td>U2</td><td>GBD-PCAX-0 F M538011-E - 08 8145507</td><td>1MB ROM</td></tr>
<tr><td>U3</td><td>52CV1000SF85LL SHARP JAPAN 9805 5 0A</td><td>128KB RAM</td></tr>
</tbody></table>
</div>
<p>The U1 is the only one connected to the GB cartridge pins (besides some address pins of the ROM IC). The U2 and U3 (ROM and RAM) are connected to U1. The M64282FP “retina” chip is in a separate PCB, and is connected to the U1.
The M64282FP handles most of the configuration of the capturing process. The U1 transforms the commands from the Game Boy CPU into the correct signals needed for the M64282FP. The detailed timings are described below.
It is a good idea to have the datasheet of the M64282FP, but it is very poorly explained, so this document will try to explain everything about it (except from limits like voltage or signal timings). There are datasheets of similar sensors (M64283FP and M64285FP) that can be very useful to understand some things about the sensor of the GB Camera.</p>
<h2 id="game-boy-camera-mbc"><a class="header" href="#game-boy-camera-mbc">Game Boy Camera MBC</a></h2>
<p>The Game Boy Camera controller works pretty much the same as a MBC3.</p>
<h3 id="0000-3fff---rom-bank-00-read-only-3"><a class="header" href="#0000-3fff---rom-bank-00-read-only-3">0000-3FFF - ROM Bank 00 (Read Only)</a></h3>
<p>First 16 KB of the ROM.</p>
<h3 id="4000-7fff---rom-bank-01-3f-read-only"><a class="header" href="#4000-7fff---rom-bank-01-3f-read-only">4000-7FFF - ROM Bank 01-3F (Read Only)</a></h3>
<p>This area may contain any ROM bank (0 included). The initial mapped bank is 01.</p>
<!-- #### A000-BFFF - RAM Bank 00-0F (Read/Write) -->
<h3 id="a000-bfff---cam-registers-readwrite"><a class="header" href="#a000-bfff---cam-registers-readwrite">A000-BFFF - CAM Registers (Read/Write)</a></h3>
<p>Depending on the current RAM Bank Number, this memory space is used to access the cartridge RAM or the CAM registers. RAM can only be read if the capture unit is not working, it returns 00h otherwise.</p>
<h3 id="0000-1fff---ram-enable-write-only-2"><a class="header" href="#0000-1fff---ram-enable-write-only-2">0000-1FFF - RAM Enable (Write Only)</a></h3>
<p>A value of 0Ah will enable writing to RAM, 00h will disable it. Reading from RAM or registers is always enabled. Writing to registers is always enabled. Disabled on reset.</p>
<h3 id="2000-3fff---rom-bank-number-write-only-3"><a class="header" href="#2000-3fff---rom-bank-number-write-only-3">2000-3FFF - ROM Bank Number (Write Only)</a></h3>
<p>Writing a value of 00-3Fh selects the corresponding ROM Bank for area 4000-7FFF.</p>
<h3 id="4000-5fff---ram-bank-numbercam-registers-select-write-only"><a class="header" href="#4000-5fff---ram-bank-numbercam-registers-select-write-only">4000-5FFF - RAM Bank Number/CAM Registers Select (Write Only)</a></h3>
<p>Writing a value in range for 00h-0Fh maps the corresponding external RAM Bank to memory at A000-BFFF. Writing any value with bit 4 set to ‘1’ will select CAM registers. Usually bank 10h is used to select the registers. All registers are mirrored every 80h bytes. RAM bank 0 selected on reset.</p>
<div class="box tip">
<p class="box-title">NOTE</p><p>Unlike most games, the GB Camera RAM can only be written when PHI pin = ‘1’. It’s an enable signal for the RAM chip. Most cartridge readers and writers can’t handle PHI pin, so they can’t restore a saved backup. It isn’t needed to change ROM banks.</p>
</div>
<h2 id="io-registers-1"><a class="header" href="#io-registers-1">I/O Registers</a></h2>
<p>The Game Boy Camera I/O registers are mapped to all banks with bit 4 set to ‘1’. The GB Camera ROM usually changes to bank 16 (10h) to use the registers.</p>
<p>There are 3 groups of registers:</p>
<ul>
<li>The first group is composed by the trigger register A000. This register starts the capture process and returns the current status (working/capture finished).</li>
<li>The second group is composed by registers A001-A005, used to configure most parameters of the M64282FP sensor.</li>
<li>The third group is composed by 48 registers that form a 4×4 matrix. Each element of the matrix is formed by 3 bytes. This matrix is used by the controller for contrast and dithering.</li>
</ul>
<p>All registers are write-only, except the register A000. The others return 00h when read. The initial values of all registers on reset is 00h.</p>
<h3 id="register-a000"><a class="header" href="#register-a000">Register A000</a></h3>
<p>The lower 3 bits of this register can be read and write. The other bits return ‘0’. Writing any value with bit 0 set to ‘1’ will start the capturing process. Any write with bit 0 set to ‘0’ is a normal write and won’t trigger the capture. The value of bits 1 and 2 affects the value written to registers 4, 5 and 6 of the M64282FP, which are used in 1-D filtering mode (effects described in following chapters).
Bit 0 of this register is also used to verify if the capturing process is finished. It returns ‘1’ when the hardware is working and ‘0’ if the capturing process is over.
When the capture process is active all RAM banks will return 00h when read (and writes are ignored), but the register A000 can still be read to know when the transfer is finished.
The capturing process can be stopped by writing a ‘0’ to bit 0. When a ‘1’ is written again it will continue the previous capture process with the old capture parameters, even if the registers are changed in between. If the process is stopped RAM can be read again.</p>
<h3 id="register-a001"><a class="header" href="#register-a001">Register A001</a></h3>
<p>This register is mapped to register 1 of M64282FP. It controls the output gain and the edge operation mode.</p>
<h3 id="register-a002-a003"><a class="header" href="#register-a002-a003">Register A002, A003</a></h3>
<p>These registers are mapped to registers 2 and 3 of M64282FP. They control the exposure time. Register 2 is the MSB, register 3 is the LSB.</p>
<pre><code>u16 exposure_steps = [A003] | ([A002]&lt;&lt;8);
</code></pre>
<h3 id="register-a004"><a class="header" href="#register-a004">Register A004</a></h3>
<p>This register is mapped to register 7 of M64282FP. It sets the output voltage reference, the edge enhancement ratio, and it can invert the image.</p>
<h3 id="register-a005"><a class="header" href="#register-a005">Register A005</a></h3>
<p>This register is mapped to register 0 of M64282FP. It sets the output reference voltage and enables the zero point calibration.</p>
<h3 id="register-a006-a035"><a class="header" href="#register-a006-a035">Register A006-A035</a></h3>
<p>Those registers form a 4×4 matrix with 3 bytes per element. They handle dithering and contrast, and they are sorted by rows:</p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-0pky" colspan="4">X</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky" rowspan="4">Y</td>
    <td class="tg-0pky">00</td>
    <td class="tg-0pky">10</td>
    <td class="tg-0lax">20</td>
    <td class="tg-0lax">30</td>
  </tr>
  <tr>
    <td class="tg-0pky">01</td>
    <td class="tg-0pky">11</td>
    <td class="tg-0lax">21</td>
    <td class="tg-0lax">31</td>
  </tr>
  <tr>
    <td class="tg-0pky">02</td>
    <td class="tg-0pky">12</td>
    <td class="tg-0lax">23</td>
    <td class="tg-0lax">33</td>
  </tr>
  <tr>
    <td class="tg-0lax">03</td>
    <td class="tg-0lax">13</td>
    <td class="tg-0lax">23</td>
    <td class="tg-0lax">33</td>
  </tr>
</tbody>
</table>
<figure>
  <img src="imgs/gbcamera/fig1.png" alt="Horizontal edge processing modes.">
  <figcaption>Horizontal edge processing modes</figcaption>
</figure> 
<figure>
  <img src="imgs/gbcamera/fig2.png" alt="Vertical edge processing modes.">
  <figcaption>Vertical edge processing modes.</figcaption>
</figure> 
<figure>
  <img src="imgs/gbcamera/fig3.png" alt="2D edge processing modes.">
  <figcaption>2D edge processing modes.</figcaption>
</figure> 
<figure>
  <img src="imgs/gbcamera/fig4.png" alt="1-D filtering hardware.">
  <figcaption>1-D filtering hardware.</figcaption>
</figure> 
<figure>
  <img src="imgs/gbcamera/fig5.png" alt="Positive image.">
  <figcaption>Positive image.</figcaption>
</figure> 
<figure>
  <img src="imgs/gbcamera/fig6.png" alt="Negative image.">
  <figcaption>Negative image.</figcaption>
</figure> 
<figure>
  <img src="imgs/gbcamera/fig7.png" alt="Edge extraction.">
  <figcaption>Edge extraction.</figcaption>
</figure> 
<h2 id="sample-code-for-emulators"><a class="header" href="#sample-code-for-emulators">Sample code for emulators</a></h2>
<p>The following code is used to convert a greyscale image to the Game Boy Camera format. <code>GB_CameraTakePicture()</code> should be called when bit 0 of A000 register is st to ‘1’. The emulator should wait CAM_CLOCKS_LEFT until the bit 0 is cleared. The gain and level control are not needed to emulate the Game Boy Camera because webcams do that automatically. In fact, trying to emulate that will probably break the image. The code is not very clean because it has been extracted from <a href="https://github.com/AntonioND/giibiiadvance">GiiBiiAdvance</a>, but it seems to handle all used configurations of edge handling.</p>
<p>Note that the actual Game Boy Camera sensor is affected by infrared so the emulation can’t be perfect anyway. A good way of converting a RGB image into grayscale is to do:</p>
<pre><code class="language-c">
//--------------------------------------------------------------------

// The actual sensor image is 128x126 or so.
#define GBCAM_SENSOR_EXTRA_LINES (8)
#define GBCAM_SENSOR_W (128)
#define GBCAM_SENSOR_H (112+GBCAM_SENSOR_EXTRA_LINES) 

#define GBCAM_W (128)
#define GBCAM_H (112)

#define BIT(n) (1&lt;&lt;(n))

// Webcam image
static int gb_camera_webcam_output[GBCAM_SENSOR_W][GBCAM_SENSOR_H];
// Image processed by sensor chip
static int gb_cam_retina_output_buf[GBCAM_SENSOR_W][GBCAM_SENSOR_H];

//--------------------------------------------------------------------

static inline int clamp(int min, int value, int max)
{
    if(value &lt; min) return min;
    if(value &gt; max) return max;
    return value;
}

static inline int min(int a, int b) { return (a &lt; b) ? a : b; }

static inline int max(int a, int b) { return (a &gt; b) ? a : b; }

//--------------------------------------------------------------------

static inline u32 gb_cam_matrix_process(u32 value, u32 x, u32 y)
{
    x = x &amp; 3;
    y = y &amp; 3;

    int base = 6 + (y*4 + x) * 3;

    u32 r0 = CAM_REG[base+0];
    u32 r1 = CAM_REG[base+1];
    u32 r2 = CAM_REG[base+2];

    if(value &lt; r0) return 0x00;
    else if(value &lt; r1) return 0x40;
    else if(value &lt; r2) return 0x80;
    return 0xC0;
}

static void GB_CameraTakePicture(void)
{
    int i, j;

    //------------------------------------------------

    // Get webcam image
    // ----------------

    GB_CameraWebcamCapture();

    //------------------------------------------------

    // Get configuration
    // -----------------

    // Register 0
    u32 P_bits = 0;
    u32 M_bits = 0;

    switch( (CAM_REG[0]&gt;&gt;1)&amp;3 )
    {
        case 0: P_bits = 0x00; M_bits = 0x01; break;
        case 1: P_bits = 0x01; M_bits = 0x00; break;
        case 2: case 3: P_bits = 0x01; M_bits = 0x02; break;
        default: break;
    }

    // Register 1
    u32 N_bit = (CAM_REG[1] &amp; BIT(7)) &gt;&gt; 7;
    u32 VH_bits = (CAM_REG[1] &amp; (BIT(6)|BIT(5))) &gt;&gt; 5;

    // Registers 2 and 3
    u32 EXPOSURE_bits = CAM_REG[3] | (CAM_REG[2]&lt;&lt;8);

    // Register 4
    const float edge_ratio_lut[8] = { 0.50, 0.75, 1.00, 1.25, 2.00, 3.00, 4.00, 5.00 };

    float EDGE_alpha = edge_ratio_lut[(CAM_REG[4] &amp; 0x70)&gt;&gt;4];

    u32 E3_bit = (CAM_REG[4] &amp; BIT(7)) &gt;&gt; 7;
    u32 I_bit = (CAM_REG[4] &amp; BIT(3)) &gt;&gt; 3;

    //------------------------------------------------

    // Calculate timings
    // -----------------

    CAM_CLOCKS_LEFT = 4 * ( 32446 + ( N_bit ? 0 : 512 ) + 16 * EXPOSURE_bits );

    //------------------------------------------------

    // Sensor handling
    // ---------------

    //Copy webcam buffer to sensor buffer applying color correction and exposure time
    for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
    {
        int value = gb_camera_webcam_output[i][j];
        value = ( (value * EXPOSURE_bits ) / 0x0300 ); // 0x0300 could be other values
        value = 128 + (((value-128) * 1)/8); // &quot;adapt&quot; to &quot;3.1&quot;/5.0 V
        gb_cam_retina_output_buf[i][j] = gb_clamp_int(0,value,255);
    }

    if(I_bit) // Invert image
    {
        for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
        {
            gb_cam_retina_output_buf[i][j] = 255-gb_cam_retina_output_buf[i][j];
        }
    }

    // Make signed
    for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
    {
        gb_cam_retina_output_buf[i][j] = gb_cam_retina_output_buf[i][j]-128;
    }

    int temp_buf[GBCAM_SENSOR_W][GBCAM_SENSOR_H];

    u32 filtering_mode = (N_bit&lt;&lt;3) | (VH_bits&lt;&lt;1) | E3_bit;
    switch(filtering_mode)
    {
        case 0x0: // 1-D filtering
        {
            for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
            {
                temp_buf[i][j] = gb_cam_retina_output_buf[i][j];
            }
            for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
            {
                int ms = temp_buf[i][gb_min_int(j+1,GBCAM_SENSOR_H-1)];
                int px = temp_buf[i][j];

                int value = 0;
                if(P_bits&amp;BIT(0)) value += px;
                if(P_bits&amp;BIT(1)) value += ms;
                if(M_bits&amp;BIT(0)) value -= px;
                if(M_bits&amp;BIT(1)) value -= ms;
                gb_cam_retina_output_buf[i][j] = gb_clamp_int(-128,value,127);
            }
            break;
        }
        case 0x2: //1-D filtering + Horiz. enhancement : P + {2P-(MW+ME)} * alpha
        {
            for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
            {
                int mw = gb_cam_retina_output_buf[gb_max_int(0,i-1)][j];
                int me = gb_cam_retina_output_buf[gb_min_int(i+1,GBCAM_SENSOR_W-1)][j];
                int px = gb_cam_retina_output_buf[i][j];

                temp_buf[i][j] = gb_clamp_int(0,px+((2*px-mw-me)*EDGE_alpha),255);
            }
            for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
            {
                int ms = temp_buf[i][gb_min_int(j+1,GBCAM_SENSOR_H-1)];
                int px = temp_buf[i][j];

                int value = 0;
                if(P_bits&amp;BIT(0)) value += px;
                if(P_bits&amp;BIT(1)) value += ms;
                if(M_bits&amp;BIT(0)) value -= px;
                if(M_bits&amp;BIT(1)) value -= ms;
                gb_cam_retina_output_buf[i][j] = gb_clamp_int(-128,value,127);
            }
            break;
        }
        case 0xE: //2D enhancement : P + {4P-(MN+MS+ME+MW)} * alpha
        {
            for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
            {
                int ms = gb_cam_retina_output_buf[i][gb_min_int(j+1,GBCAM_SENSOR_H-1)];
                int mn = gb_cam_retina_output_buf[i][gb_max_int(0,j-1)];
                int mw = gb_cam_retina_output_buf[gb_max_int(0,i-1)][j];
                int me = gb_cam_retina_output_buf[gb_min_int(i+1,GBCAM_SENSOR_W-1)][j];
                int px  = gb_cam_retina_output_buf[i][j];

                temp_buf[i][j] = gb_clamp_int(-128,px+((4*px-mw-me-mn-ms)*EDGE_alpha),127);
            }
            for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
            {
                gb_cam_retina_output_buf[i][j] = temp_buf[i][j];
            }
            break;
        }
        case 0x1:
        {
            // In my GB Camera cartridge this is always the same color. The datasheet of the
            // sensor doesn't have this configuration documented. Maybe this is a bug?
            for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
            {
                gb_cam_retina_output_buf[i][j] = 0;
            }
            break;
        }
        default:
        {
            // Ignore filtering
            printf(&quot;Unsupported GB Cam mode: 0x%X\n&quot;
                   &quot;%02X %02X %02X %02X %02X %02X&quot;,
                   filtering_mode,
                   CAM_REG[0],CAM_REG[1],CAM_REG[2],
                   CAM_REG[3],CAM_REG[4],CAM_REG[5]);
            break;
        }
    }
  
  // Make unsigned
    for(i = 0; i &lt; GBCAM_SENSOR_W; i++) for(j = 0; j &lt; GBCAM_SENSOR_H; j++)
    {
        gb_cam_retina_output_buf[i][j] = gb_cam_retina_output_buf[i][j]+128;
    }
    
    //------------------------------------------------

    // Controller handling
    // -------------------

    int fourcolorsbuffer[GBCAM_W][GBCAM_H]; // buffer after controller matrix

    // Convert to Game Boy colors using the controller matrix
    for(i = 0; i &lt; GBCAM_W; i++) for(j = 0; j &lt; GBCAM_H; j++)
        fourcolorsbuffer[i][j] =
            gb_cam_matrix_process(
                gb_cam_retina_output_buf[i][j+(GBCAM_SENSOR_EXTRA_LINES/2)],i,j);

    // Convert to tiles
    u8 finalbuffer[14][16][16]; // final buffer
    memset(finalbuffer,0,sizeof(finalbuffer));
    for(i = 0; i &lt; GBCAM_W; i++) for(j = 0; j &lt; GBCAM_H; j++)
    {
        u8 outcolor = 3 - (fourcolorsbuffer[i][j] &gt;&gt; 6);

        u8 * tile_base = finalbuffer[j&gt;&gt;3][i&gt;&gt;3];
        tile_base = &amp;tile_base[(j&amp;7)*2];

        if(outcolor &amp; 1) tile_base[0] |= 1&lt;&lt;(7-(7&amp;i));
        if(outcolor &amp; 2) tile_base[1] |= 1&lt;&lt;(7-(7&amp;i));
    }

    // Copy to cart ram...
    memcpy(&amp;(SRAM[0][0x0100]),finalbuffer,sizeof(finalbuffer));
}

//--------------------------------------------------------------------
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-player-adapter"><a class="header" href="#4-player-adapter">4-Player Adapter</a></h1>
<p>The 4-Player Adapter (DMG-07) is an accessory that allows 4 Game Boys
to connect for multiplayer via <a href="./Serial_Data_Transfer_(Link_Cable).html">serial data transfer</a>.
The device is primarily designed for DMG consoles, with later models
requiring Link Cable adapters.</p>
<h2 id="communication-1"><a class="header" href="#communication-1">Communication</a></h2>
<p>The DMG-07 protocol can be divided into 2 sections, the “ping” phase, and
the “transmission” phase. The initial ping phase involves sending packets
back and forth between connected Game Boys probing for their current
connection status. Afterwards, the DMG-07 enters into transmission mode
where the Game Boys exchange data across the network.</p>
<p>A very important thing to note is that all Game Boys transfer data across
the DMG-07 via an external clock source. Apparently, the clock source is
provided by the DMG-07 itself. Trying to send data via an internal clock
results in garbage data.</p>
<h3 id="ping-phase"><a class="header" href="#ping-phase">Ping Phase</a></h3>
<p>When a “master” Game Boy (Player 1) is first connected to the adapter,
setting Bit 7 of SC to 1 and setting Bit 0 of SC to 0 causes the accessory
to send out “ping” packets periodically. All connected Game Boys will
receive 4 bytes as part of the ping packet at a rate of about 2048 bits
per second, or about 256 bytes per second. Essentially, the ping seems to
run 1/4 as fast as the clock used for normal serial transfers on the DMG
(1KB/s). The ping data looks like this:</p>
<div class="table-wrapper"><table><thead><tr><th>Byte</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>1</td><td>0xFE</td><td>ID Byte</td></tr>
<tr><td>2</td><td>0x??</td><td>STAT1</td></tr>
<tr><td>3</td><td>0x??</td><td>STAT2</td></tr>
<tr><td>4</td><td>0x??</td><td>STAT3</td></tr>
</tbody></table>
</div>
<p>3 “STAT” bytes are sent indicating the current connection status of the other
Game Boys. Each byte is usually the same, however, sometimes the status can
change midway through a ping, typically on STAT2 or STAT3. Each STAT byte
looks like such:</p>
<div class="table-wrapper"><table><thead><tr><th>Bit</th><th>Name</th></tr></thead><tbody>
<tr><td>7</td><td>Player 4 Connected</td></tr>
<tr><td>6</td><td>Player 3 Connected</td></tr>
<tr><td>5</td><td>Player 2 Connected</td></tr>
<tr><td>4</td><td>Player 1 Connected</td></tr>
<tr><td>0-2</td><td>Player ID (1-4)</td></tr>
</tbody></table>
</div>
<p>The Player ID’s value is determined by whichever port a Game Boy is connected
to. As more Game Boys connect, the upper bits of the STAT bytes are turned on.</p>
<p>When talking about Game Boys and the “connection”, this refers to a Game Boy
properly responding to STAT1 and STAT2 bytes when receiving a ping packet from
the DMG-07. In this way, the Game Boy broadcasts across the Link Cable network
that it is an active participant in communications. It also acts as a sort of
acknowledgement signal, where software can drop a Game Boy if the DMG-07
detects an improper response during a ping, or a Game Boy simply quits the
network. The proper response is to send 0x88 <em>after</em> receiving the ID Byte and
STAT1, in which case the upper-half of STAT1, STAT2, and STAT3 are updated to
show that a Game Boy is “connected”. If for whatever reason, the
acknowledgement codes are not sent, the above bits are unset.</p>
<p>Some examples of ping packets are shown below:</p>
<div class="table-wrapper"><table><thead><tr><th>Packet</th><th>Description</th></tr></thead><tbody>
<tr><td><code>0xFE 0x01 0x01 0x01</code></td><td>Ping packet received by Player 1 with no other Game Boys connected.</td></tr>
<tr><td><code>0xFE 0x11 0x11 0x11</code></td><td>Ping packet received by Player 1 when Player 1 has connected.</td></tr>
<tr><td><code>0xFE 0x31 0x31 0x31</code></td><td>Ping packet received by Player 1 when Players 1 &amp; 2 have connected.</td></tr>
<tr><td><code>0xFE 0x71 0x71 0x71</code></td><td>Ping packet received by Player 1 when Players 1, 2, &amp; 3 have connected.</td></tr>
<tr><td><code>0xFE 0x62 0x62 0x62</code></td><td>Ping packet received by Player 2 when Players 2 &amp; 3 are connected (but not Player 1).</td></tr>
</tbody></table>
</div>
<p>It’s possible to have situations where some players are connected but others
are not; the gaps don’t matter. For example, Player 1 and Player 4 can be
connected, while Player 2 and Player 3 can be disconnected (or non-existent,
same thing); most games do not care so long as Player 1 is active, as that
Game Boy acts as master and orchestrates the multiplayer session from a
software point of view. Because of the way the DMG-07 hardcodes player IDs
based on which port a Game Boy is physically connected to, in the above
situation Player 4 wouldn’t suddenly become Player 2.</p>
<p>During the ping phase, the master Game Boy is capable of setting up two
parameters that will be used during the transmission phase. The clock rate for
the transmission phase can be adjusted, as well as the packet size each Game
Boy will use. The master Game Boy needs to respond with one byte for STAT2
and STAT3 respectively. The chart below illustrates how a master Game Boy
should respond to all bytes in a ping packet:</p>
<pre><code>----------------------------
DMG-07		Game Boy
----------------------------
0xFE	&lt;--&gt;	(ACK1) = 0x88
STAT1	&lt;--&gt;	(ACK2) = 0x88	
STAT2	&lt;--&gt;	(RATE) = Link Cable Speed 
STAT3	&lt;--&gt;	(SIZE) = Packet Size
</code></pre>
<p>The new clock rate is only applied when entering the transmission phase; the
ping phase runs at a constant 2048 bits-per-second. The formula for the new
clock rate is as follows:</p>
<pre><code>DMG-07 Bits-Per-Second --&gt; 4194304 / ((6 * RATE) + 512)
</code></pre>
<p>The lowest setting (RATE = 0) runs the DMG-07 at the normal speed DMGs usually
transfer data (1KB/s), while setting it to 0xFF runs it close to the slowest
speed (2042 bits-per-second).</p>
<p>SIZE sets the length of packets exchanged between all Game Boys. Nothing fancy,
just the number of bytes in each packet. It probably shouldn’t be set to zero.</p>
<h3 id="transmission-phase"><a class="header" href="#transmission-phase">Transmission Phase</a></h3>
<p>When the master Game Boy (Player 1) is ready, it should send 4 bytes
(<code>0xAA 0xAA 0xAA 0xAA</code>, if those are actually required should be investigated further).
This alerts the DMG-07 to start the transmission phase. The RATE and SIZE parameters 
are applied at this point. The protocol is simple: Each Game Boy sends a packet to
the DMG-07 simultaneously, then the DMG-07 outputs each packet to all connected
Game Boys. All data is buffered, so there is a 4 packet delay after each Game
Boy submits their data (the delay is still 4 packets long even if some Game Boys
are not connected). For example, say the packet size is 4 bytes; the flow of
data would look like this when sending:</p>
<div class="table-wrapper"><table><thead><tr><th>P1 send</th><th>P2 send</th><th>P3 send</th><th>P4 send</th><th>Transfer count</th></tr></thead><tbody>
<tr><td>P1 (byte 1)</td><td>P2 (byte 1)</td><td>P3 (byte 1)</td><td>P4 (byte 1)</td><td>0</td></tr>
<tr><td>P1 (byte 2)</td><td>P2 (byte 2)</td><td>P3 (byte 2)</td><td>P4 (byte 2)</td><td>1</td></tr>
<tr><td>P1 (byte 3)</td><td>P2 (byte 3)</td><td>P3 (byte 3)</td><td>P4 (byte 3)</td><td>2</td></tr>
<tr><td>P1 (byte 4)</td><td>P2 (byte 4)</td><td>P3 (byte 4)</td><td>P4 (byte 4)</td><td>3</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>4 (Typically supposed to be zero, but DMG-07 ignores anything here)</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>5</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>6</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>7</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>8</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>9</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>10</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>11</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>12</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>13</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>14</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>15</td></tr>
</tbody></table>
</div>
<p>And when receiving, the flow of data would look like this:</p>
<div class="table-wrapper"><table><thead><tr><th>P1 receive</th><th>P2 receive</th><th>P3 receive</th><th>P4 receive</th><th>Transfer count</th></tr></thead><tbody>
<tr><td>P1 (byte 1)</td><td>P1 (byte 1)</td><td>P1 (byte 1)</td><td>P1 (byte 1)</td><td>16</td></tr>
<tr><td>P1 (byte 2)</td><td>P1 (byte 2)</td><td>P1 (byte 2)</td><td>P1 (byte 2)</td><td>17</td></tr>
<tr><td>P1 (byte 3)</td><td>P1 (byte 3)</td><td>P1 (byte 3)</td><td>P1 (byte 3)</td><td>18</td></tr>
<tr><td>P1 (byte 4)</td><td>P1 (byte 4)</td><td>P1 (byte 4)</td><td>P1 (byte 4)</td><td>19</td></tr>
<tr><td>P2 (byte 1)</td><td>P2 (byte 1)</td><td>P2 (byte 1)</td><td>P2 (byte 1)</td><td>20</td></tr>
<tr><td>P2 (byte 2)</td><td>P2 (byte 2)</td><td>P2 (byte 2)</td><td>P2 (byte 2)</td><td>21</td></tr>
<tr><td>P2 (byte 3)</td><td>P2 (byte 3)</td><td>P2 (byte 3)</td><td>P2 (byte 3)</td><td>22</td></tr>
<tr><td>P2 (byte 4)</td><td>P2 (byte 4)</td><td>P2 (byte 4)</td><td>P2 (byte 4)</td><td>23</td></tr>
<tr><td>P3 (byte 1)</td><td>P3 (byte 1)</td><td>P3 (byte 1)</td><td>P3 (byte 1)</td><td>24</td></tr>
<tr><td>P3 (byte 2)</td><td>P3 (byte 2)</td><td>P3 (byte 2)</td><td>P3 (byte 2)</td><td>25</td></tr>
<tr><td>P3 (byte 3)</td><td>P3 (byte 3)</td><td>P3 (byte 3)</td><td>P3 (byte 3)</td><td>26</td></tr>
<tr><td>P3 (byte 4)</td><td>P3 (byte 4)</td><td>P3 (byte 4)</td><td>P3 (byte 4)</td><td>27</td></tr>
<tr><td>P4 (byte 1)</td><td>P4 (byte 1)</td><td>P4 (byte 1)</td><td>P4 (byte 1)</td><td>28</td></tr>
<tr><td>P4 (byte 2)</td><td>P4 (byte 2)</td><td>P4 (byte 2)</td><td>P4 (byte 2)</td><td>29</td></tr>
<tr><td>P4 (byte 3)</td><td>P4 (byte 3)</td><td>P4 (byte 3)</td><td>P4 (byte 3)</td><td>30</td></tr>
<tr><td>P4 (byte 4)</td><td>P4 (byte 4)</td><td>P4 (byte 4)</td><td>P4 (byte 4)</td><td>31</td></tr>
</tbody></table>
</div>
<p>Again, due to buffering, data output to the DMG-07 is actually delayed by
several transfers according to the size of the packets. All connected Game
Boys should send their data into the buffer during the first few transfers.
Here, the packet size is 4 bytes, so each Game Boy should submit their data
during the first 4 transfers. The other 12 transfers don’t care what the
Game Boys send; it won’t enter into the buffer. The next 16 transfers return
the packets each Game Boy previously sent (if no Game Boy exists for player,
that slot is filled with zeroes).</p>
<p>With the buffering system, Game Boys would normally be reading data from
previous packets during transfers 0-15, in addition to sending new packets.
Likewise, during transfers 16-19 each Game Boy is sending new packets. In
effect, while receiving old data, Game Boys are supposed to pump new data into
the network.</p>
<p>When the DMG-07 enters the transmission phase, the buffer is initially filled
with garbage data that is based on output the master Game Boy had sent during
the ping phase. At this time, it is recommended to ignore the earliest packets
received, however, it is safe to start putting new, relevant data into the
buffer.</p>
<h3 id="restarting-ping-phase"><a class="header" href="#restarting-ping-phase">Restarting Ping Phase</a></h3>
<p>It’s possible to restart the ping phase while operating in the transmission
phase. To do so, the master Game Boy should send 4 or more bytes
(<code>0xFF 0xFF 0xFF 0xFF</code>, it’s possible fewer 0xFF bytes need to be sent,
but this has not been extensively investigated yet). The bytes alert the DMG-07
that the ping phase should begin again, after which it sends ping packets after
a brief delay. During this delay, the transmission protocol is still working as
intended until the switch happens.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Game Shark and Game Genie are external cartridge adapters that can be
plugged in between the Game Boy and the actual game cartridge.</p>
<h2 id="game-genie-rom-patches"><a class="header" href="#game-genie-rom-patches">Game Genie (ROM patches)</a></h2>
<p>Game Genie codes consist of nine-digit hex numbers, formatted as
<code>ABC-DEF-GHI</code>, the meaning of the separate digits is:</p>
<ul>
<li><code>AB</code>, new data</li>
<li><code>FCDE</code>, memory address, XORed by 0F000h</li>
<li><code>GI</code>, old data, XORed by 0BAh and rotated left by two</li>
<li><code>H</code>, Unknown, maybe checksum and/or else</li>
</ul>
<p>The address should be located in ROM area 0000h-7FFFh, the adapter
permanently compares address/old data with address/data being read by
the game, and replaces that data by new data if necessary. That method
(more or less) prohibits unwanted patching of wrong memory banks.
Eventually it is also possible to patch external RAM ? Newer devices
reportedly allow to specify only the first six digits (optionally). 
Three codes can be used at once.</p>
<p>Check the <a href="http://www.digitpress.com/library/manuals/gameboy/game%20genie.pdf">Game Genie manual</a> for reference.</p>
<h2 id="game-shark-ram-patches"><a class="header" href="#game-shark-ram-patches">Game Shark (RAM patches)</a></h2>
<p>Game Shark codes consist of eight-digit hex numbers, formatted as
ABCDEFGH, the meaning of the separate digits is:</p>
<p><code> AB    External RAM bank number</code><br />
<code> CD    New Data</code><br />
<code> GHEF  Memory Address (internal or external RAM, A000-DFFF)</code></p>
<p>As far as it is understood, patching is implemented by hooking the original
VBlank interrupt handler, and re-writing RAM values each frame. The
downside is that this method steals some CPU time, also, it cannot be
used to patch program code in ROM. 10-25 codes can be used simultaneously.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="power-up-sequence"><a class="header" href="#power-up-sequence">Power-Up Sequence</a></h1>
<p>When the Game Boy is powered up, the CPU actually does not start executing instructions at $0100, but actually at $0000.
A program called the <em>boot ROM</em>, burned inside the CPU, is mapped “over” the cartridge ROM at first.
This program is responsible for the boot-up animation played before control is handed over to the cartridge’s ROM.
Since the boot ROM hands off control to the game ROM at address $0100, and developers typically need not care about the boot ROM, the “start address” is usually documented as $0100 and not $0000.</p>
<p>9 different known official boot ROMs are known to exist:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Size (bytes)</th><th>Notes</th></tr></thead><tbody>
<tr><td>DMG0</td><td>256</td><td>Blinks on failed checks, no ®</td></tr>
<tr><td>DMG</td><td>256</td><td></td></tr>
<tr><td>MGB</td><td>256</td><td>One-byte difference to DMG</td></tr>
<tr><td>SGB</td><td>256</td><td>Only forwards logo to SGB BIOS, performs no checks</td></tr>
<tr><td>SGB2</td><td>256</td><td>Same difference to SGB than between MGB and DMG</td></tr>
<tr><td>CGB0</td><td>256 + 1792</td><td>Does not init <a href="#ff30ff3f--wave-pattern-ram">wave RAM</a></td></tr>
<tr><td>CGB</td><td>256 + 1792</td><td>Split in two parts, with the cartridge header in the middle</td></tr>
<tr><td>AGB0</td><td>256 + 1792</td><td>Increments B register for GBA identification</td></tr>
<tr><td>AGB</td><td>256 + 1792</td><td>Fixes <a href="#bypass">“logo TOCTTOU”</a></td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/ISSOtm/gb-bootroms">A disassembly of all of them is available online.</a></p>
<h2 id="monochrome-models-dmg0-dmg-mgb"><a class="header" href="#monochrome-models-dmg0-dmg-mgb">Monochrome models (DMG0, DMG, MGB)</a></h2>
<p>The monochrome boot ROMs read <a href="#0104-0133--nintendo-logo">the logo from the header</a>, unpack it into VRAM, and then start slowly scrolling it down.
Since reads from an absent cartridge usually return $FF, this explains why powering the console on without a cartridge scrolls a black box.
Additionally, fauly or dirty connections can cause the data read to be corrupted, resulting in a jumbled-up logo.</p>
<p><em>Once the logo has finished scrolling</em>, the boot ROM plays the famous “ba-ding!” sound, and reads the logo <strong>again</strong>, this time comparing it to a copy it stores.
Then, it also computes the header checksum, and compares it to <a href="#014d--header-checksum">the checksum stored in the header</a>.
If either of these checks fail, the boot ROM <strong>locks up</strong>, and control is never passed to the cartridge ROM.</p>
<p>Finally, the boot ROM writes to the <code>BANK</code> register at $FF50, which unmaps the boot ROM.
The <code>ldh [$FF50], a</code> instruction being located at $00FE (and being two bytes long), <a href="#0100-0103--entry-point">the first instruction executed from the cartridge ROM is at $0100</a>.</p>
<p>Since the A register is used to write to $FF50, its value is passed to the cartridge ROM; the only difference between the DMG and MGB boot ROMs is that the former writes $01, and the latter uses $FF.</p>
<h3 id="dmg0"><a class="header" href="#dmg0">DMG0</a></h3>
<p>The DMG0 is a rare “early bird” variant of the DMG boot ROM present in few early DMGs.
The behavior of the boot ROM is globally the same, but significant portions of the code have been rearranged.</p>
<p>Interestingly, the DMG0 boot ROM performs both the logo and checksum checks before displaying anything.
If either verification fails, the screen is made to blink while the boot ROM locks up, alternating between solid white and solid black.</p>
<p>The DMG0 boot ROM also lacks the ® symbol next to the Nintendo logo.</p>
<h2 id="super-game-boy-sgb-sgb2"><a class="header" href="#super-game-boy-sgb-sgb2">Super Game Boy (SGB, SGB2)</a></h2>
<p>These boot ROMs are fairly unique in that they do <em>not</em> perform header checks.
Instead, they set up the Nintendo logo in VRAM from the header just like the monochrome boot ROMs, but then they send the entire header to the SGB BIOS via <a href="#command-packet-transfers">the standard packet-transferring procedure</a>, using packet header bytes $F1, $F3, $F5, $F7, $F9, and $FB, in that order.
(These packet IDs are otherwise invalid and never used in regular SGB operation, though it seems that not all SGB BIOS revisions filter them out.)</p>
<p>The boot ROM then unmaps itself and hands off execution to the cartridge ROM without performing any checks.
The SGB BIOS, the program running on the SNES, actually verifies the Nintendo logo and header checksum itself.
If either verification fails, the BIOS itself locks up, repeatedly resetting the SGB CPU within the cartridge.</p>
<p>As the DMG and MGB boot ROMs, the SGB and SGB2 boot ROMs write $01 and $FF respectively to $FF50, and this is also the only difference between these two boot ROMs.</p>
<p>The way the packet-sending routine works makes transferring a set bit <em>one cycle</em> faster than transferring a reset bit; this means that the time taken by the SGB boot ROMs <em>depends on the cartridge’s header</em>.
The relationship between the header and the time taken is made more complex by the fact that the boot ROM waits for 4 VBlanks after transferring each packet, mostly but not entirely grouping the timings.</p>
<h2 id="color-models-cgb0-cgb-agb0-agb"><a class="header" href="#color-models-cgb0-cgb-agb0-agb">Color models (CGB0, CGB, AGB0, AGB)</a></h2>
<p>The color boot ROMs are much more complicated, notably because of the compatibility behavior.</p>
<h3 id="size"><a class="header" href="#size">Size</a></h3>
<p>The boot ROM is larger, as indicated in the table at the top: 2048 bytes total.
It still has to be mapped starting at $0000, since this is where the CPU starts, but it must also access the cartridge header at $0100-014F.
Thus, the boot ROM is actually split in two parts, a $0000-00FF one, and a $0200-08FF one.</p>
<h3 id="behavior"><a class="header" href="#behavior">Behavior</a></h3>
<p>First, the boot ROMs unpack the Nintendo logo to VRAM like the monochrome models, likely for compatibility, and copies the logo to a buffer in HRAM at the same time.
(It is speculated that HRAM was used due to it being embedded within the CPU, unlike WRAM, so that it couldn’t be tampered with.)</p>
<p>Then, the logo is read and decompressed <em>again</em>, but with no resizing, yielding the much smaller logo placed below the big “GAME BOY” one.
The boot ROM then sets up compatibility palettes, as described further below, and plays the logo animation with the “ba-ding!” sound.</p>
<p>During the logo animation, and if bit 7 of <a href="#0143--cgb-flag">the CGB compatibility byte</a> is reset (indicating a monochrome-only game), the user is allowed to pick a palette to override the one chosen for compatibility.
Each new choice prevents the animation from ending for 30 frames, potentially delaying the checks and fade-out.</p>
<p>Then, like the monochrome boot ROMs, the header logo is checked <em>from the buffer in HRAM</em>, and the header checksum is verified.
For unknown reasons, however, only the first half of the logo is checked, despite the full logo being present in the HRAM buffer.</p>
<p>Finally, the boot ROM fades all BG palettes to white, and sets the hardware to compatibility mode.
If <a href="#0143--cgb-flag">the CGB compatibility byte</a> indicates CGB compatibility, the byte is written directly to <code>KEY0</code> ($FF4C), potentially enabling PGB mode; otherwise, $04 is written to <code>KEY0</code> (enabling DMG compatibility mode in the CPU), $01 is written to <a href="#ff6c--opri-cgb-mode-only-object-priority-mode"><code>OPRI</code></a> (enabling <a href="#object-priority-and-conflicts">DMG OBJ priority</a>), and the <a href="#compatibility-palettes">compatibility palettes</a> are written.
Additionally, the DMG logo tilemap is written <a href="#compatibility-palettes">if the compatibility requests it</a>.</p>
<p>Like all other boot ROMs, the last thing the color boot ROMs do is hand off execution at the same time as they unmap themselves, though they write $11 instead of $01 or $FF.</p>
<h3 id="cgb0"><a class="header" href="#cgb0">CGB0</a></h3>
<p>Like the DMG0 boot ROM, some early CGBs contain a different boot ROM.
Unlike DMG0 and DMG, the differences between the CGB0 and CGB boot ROM are very minor, with no change in the layout of the ROM.</p>
<p>The most notable change is that the CGB0 boot ROM does <em>not</em> init <a href="#ff30ff3f--wave-pattern-ram">wave RAM</a>.
This is known to cause, for example, a different title screen music in the game <em>R-Type</em>.</p>
<p>The CGB0 boot ROM also writes copies of other variables to some locations in WRAM that are not otherwise read anywhere.
It is speculated that this may be debug remnants.</p>
<h3 id="compatibility-palettes"><a class="header" href="#compatibility-palettes">Compatibility palettes</a></h3>
<p>The boot ROM is responsible for the automatic colorization of monochrome-only games when run on a GBC.</p>
<p>When in DMG compatibility mode, the <a href="#lcd-color-palettes-cgb-only">CGB palettes</a> are still being used: the background uses BG palette 0 (likely because the entire <a href="#bg-map-attributes-cgb-mode-only">attribute map</a> is set to all zeros), and objects use OBJ palette 0 or 1 depending on bit 4 of <a href="#byte-3--attributesflags">their attribute</a>.
<a href="#lcd-monochrome-palettes"><code>BGP</code>, <code>OBP0</code>, and <code>OBP1</code></a> actually index into the CGB palettes instead of the DMG’s shades of grey.</p>
<p>The boot ROM picks a compatibility palette using an ID computed using the following algorithm:</p>
<ol>
<li>
<p>Check if the <a href="#014b--old-licensee-code">old licensee code</a> is $33.</p>
<ul>
<li>If yes, the <a href="#0144-0145--new-licensee-code">new licensee code</a> must be used. Check that it equals the ASCII string <code>&quot;01&quot;</code>.</li>
<li>If not, check that it equals $01.</li>
</ul>
<p>In effect, this checks that the licensee in the header is Nintendo.</p>
<ul>
<li>If this check fails, palettes ID $00 is used.</li>
<li>Otherwise, the algorithm proceeds.</li>
</ul>
</li>
<li>
<p>Compute the sum of all 16 <a href="#0134-0143--title">game title</a> bytes, storing this as the “title checksum”.</p>
</li>
<li>
<p>Find the title checksum <a href="https://github.com/ISSOtm/gb-bootroms/blob/443d7f057ae06e8d1d76fa8083650cf0be2cd0ae/src/cgb.asm#L1221-L1230">in a table</a>, and record its index within the table.</p>
<p>An almost-complete list of titles corresponding to the different checksums can be found in <a href="https://github.com/LIJI32/SameBoy/blob/1d7692cff5552e296be5e1ab075c4f187f57132c/BootROMs/cgb_boot.asm#L230-L328">Liji’s free CGB boot ROM reimplementation</a>.</p>
<ul>
<li>If not found, palettes ID $00 is used.</li>
<li>If the index is 64 or below, the index is used as-is as the palettes ID, and the algorithm ends.</li>
<li>Otherwise, it must be further corrected based on the title’s fourth letter; proceed to the step below.</li>
</ul>
</li>
<li>
<p>The fourth letter is searched for in <a href="https://github.com/ISSOtm/gb-bootroms/blob/443d7f057ae06e8d1d76fa8083650cf0be2cd0ae/src/cgb.asm#L1232-L1240">another table</a>.</p>
<ul>
<li>If the letter can’t be found, palettes ID $00 is used.</li>
<li>If the letter is found, the index obtained in the previous step is increased by 14 times the row index to get the palettes ID.
(So, if the letter was found in the first row, the index is unchanged; if it’s found in the second row, it’s increased by 14, and so on.)</li>
</ul>
</li>
</ol>
<p>The resulting palettes ID is used to pick 3 palettes out of a table via a fairly complex mechanism.
The user can override this choice using certain button combinations during the logo animation; some of these manual choices are identical to auto-colorizations, <a href="https://tcrf.net/Notes:Game_Boy_Color_Bootstrap_ROM#Manual_Select_Palette_Configurations">but others are unique</a>.</p>
<div class="box tip">
<p class="box-title">Available palettes</p><p>A table of checksums (and tie-breaker fourth letters when applicable) and the corresponding palettes can be found <a href="https://tcrf.net/Notes:Game_Boy_Color_Bootstrap_ROM#Assigned_Palette_Configurations">on TCRF</a>.</p>
</div>
<p>If the ID is either $43 or $58, then the Nintendo logo’s tilemap is written to VRAM.
This is intended for games that perform some kind of animation with the Nintendo logo; it suddenly appears in the middle of the screen, though, so it may look better for homebrew not to use this mechanism.</p>
<h3 id="scrapped-palette-switching-menu"><a class="header" href="#scrapped-palette-switching-menu">Scrapped palette switching menu</a></h3>
<p>Remnants of a functionality designed to allow switching the CGB palettes while the game is running exist in the CGB CPU.</p>
<h2 id="stadium-2"><a class="header" href="#stadium-2">Stadium 2</a></h2>
<p>Pokémon Stadium 2’s “GB Tower” emulator contains a very peculiar boot ROM.
It can be found at offset $015995F0 in the US release, and is only 1008 bytes long.
Its purpose is unknown.</p>
<p>This boot ROM does roughly the same setup as a regular CGB boot ROM, but writes to $FF50 very early, and said write is followed by a lock-up loop.
Further, the boot ROM contains a valid header, which is mostly blank save for the logo, compatibility flag (which indicates dual compatibility), and header checksum.</p>
<h2 id="logo-check"><a class="header" href="#logo-check">Logo check</a></h2>
<p>While it may make sense for the boot ROM to at least partially verify the ROM’s integrity via the header check, one may wonder why the logo is checked more stringently.</p>
<h3 id="legal-implications"><a class="header" href="#legal-implications">Legal implications</a></h3>
<div class="box danger">
<p class="box-title">Caution</p><p>The following is advisory, but <strong>is not legal advice</strong>.
If necessary (e.g. commercial releases with logos on the boxes), consult a lawyer.</p>
</div>
<p>The logo check was meant to deter piracy using trademark law.
Unlike nowadays, the Game Boy’s technology was not sufficient to require Nintendo’s approval to make a game run on it, and Nintendo decided against hardware protection like the NES’ <a href="https://wiki.nesdev.org/w/index.php/CIC_lockout_chip">lockout chip</a> likely for cost and/or power consumption reasons.</p>
<p>Instead, the boot ROM’s logo check forces each ROM intended to run on the system to contain an (encoded) copy of the Nintendo logo, which is displayed on startup.
Nintendo’s strategy was to threaten pirate developers with suing for trademark infringement.</p>
<p>Fortunately, <a href="https://en.wikipedia.org/wiki/Sega_v._Accolade"><em>Sega v. Accolade</em></a> ruled (in the US) that use of a trademarked logo is okay if it is <em>necessary</em> for running programs on the console, so there is no danger for homebrew developers.</p>
<p>That said, if you want to explicitly mark the lack of licensing from Nintendo, you can add some text to the logo screen once the boot ROM hands off control, for example like this:</p>
<p><img src="imgs/not_licensed.png" alt="Mockup screenshot of an endorsement disambiguation screen" /></p>
<h3 id="bypass"><a class="header" href="#bypass">Bypass</a></h3>
<p>The Nintendo logo check has been <a href="http://fuji.drillspirits.net/?post=87">circumvented many times</a>, be it to avoid legal action from Nintendo or for the swag, and there are basically two ways of doing so.</p>
<p>One is to exploit a <a href="https://en.wikipedia.org/wiki/TOCTTOU">TOCTTOU</a> vulnerability in the way the console reads the logo (doing so once to draw it, and the other time to check it), which has however been patched on later revisons of the AGB.
This requires custom hardware in the cartridge, however, and is made difficult by the timing and order of the reads varying greatly between boot ROMs.
Some implementations use a custom mapper, others use a capacitor holding some of the address lines to redirect reads to a separate region of ROM containing the modified logo.</p>
<p>The other way is Game Boy Color (and Advance) exclusive: for some reason, the boot ROM copies the full logo into HRAM, but only compares the first half.
Thus, a logo whose top half is correct but not the bottom half will get a pass from the CGB boot ROM.
Strangely, despite correcting the TOCTTOU vulnerability in its later revision, the CGB-AGB boot ROM does <em>not</em> fix this mistake.</p>
<h2 id="console-state-after-boot-rom-hand-off"><a class="header" href="#console-state-after-boot-rom-hand-off">Console state after boot ROM hand-off</a></h2>
<p>Regardless of the console you intend for your game to run on, it is prudent to rely on as little of the following as possible, barring what is mentioned elsewhere in this documentation to detect which system you are running on.
This ensures maximum compatibility, both across consoles and cartridges (especially flashcarts, which typically run their own menu code before your game), increases reliability, and is generally considered good practice.</p>
<div class="box warning">
<p class="box-title">Use it at your own risk</p><p>Some of the information below is highly volatile, due to the complexity of some of the boot ROM behaviors; thus, some of it may contain errors.
Rely on it at your own risk.</p>
</div>
<h3 id="common-remarks"><a class="header" href="#common-remarks">Common remarks</a></h3>
<p>The console’s WRAM and HRAM are random on power-up.
<a href="https://twitter.com/CasualPkPlayer/status/1409752977812852736">Different models tend to exhibit different patterns</a>, but they are random nonetheless, even depending on factors such as the ambient temperature.
Besides, turning the system off and on again has proven reliable enough <a href="https://www.youtube.com/watch?v=xayxmTLljr8">to carry over RAM from one game to another</a>, so it’s not a good idea to rely on it at all.</p>
<p>Emulation of uninitialized RAM is inconsistent: some emulators fill RAM with a constant on startup (typically $00 or $FF), some emulators fully randomize RAM, and others attempt to reproduce the patterns observed on hardware.
It is a good idea to enable your favorite emulator’s “break on uninitialized RAM read” exception (and if it doesn’t have one, to consider using an emulator that does).</p>
<p>While technically not related to power-on, it is worth noting that external RAM in the cartridge, when present, usually contains random garbage data when first powered on.
It is strongly advised for the game to put a large enough known sequence of bytes at a fixed location in SRAM, and check its presence before accessing any saved data.</p>
<h3 id="cpu-registers"><a class="header" href="#cpu-registers">CPU registers</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Register</th><th style="text-align: center">DMG0</th><th style="text-align: center">DMG</th><th style="text-align: center">MGB</th><th style="text-align: center">SGB</th><th style="text-align: center">SGB2</th></tr></thead><tbody>
<tr><td style="text-align: right"><strong>A</strong></td><td style="text-align: center">$01</td><td style="text-align: center">$01</td><td style="text-align: center">$FF</td><td style="text-align: center">$01</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><strong>F</strong></td><td style="text-align: center">Z=0 N=0 H=0 C=0</td><td style="text-align: center">Z=1 N=0 H=? C=?<sup class="footnote-reference"><a href="#dmg_c">1</a></sup></td><td style="text-align: center">Z=1 N=0 H=? C=?<sup class="footnote-reference"><a href="#dmg_c">1</a></sup></td><td style="text-align: center">Z=0 N=0 H=0 C=0</td><td style="text-align: center">Z=0 N=0 H=0 C=0</td></tr>
<tr><td style="text-align: right"><strong>B</strong></td><td style="text-align: center">$FF</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><strong>C</strong></td><td style="text-align: center">$13</td><td style="text-align: center">$13</td><td style="text-align: center">$13</td><td style="text-align: center">$14</td><td style="text-align: center">$14</td></tr>
<tr><td style="text-align: right"><strong>D</strong></td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><strong>E</strong></td><td style="text-align: center">$C1</td><td style="text-align: center">$D8</td><td style="text-align: center">$D8</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><strong>H</strong></td><td style="text-align: center">$84</td><td style="text-align: center">$01</td><td style="text-align: center">$01</td><td style="text-align: center">$C0</td><td style="text-align: center">$C0</td></tr>
<tr><td style="text-align: right"><strong>L</strong></td><td style="text-align: center">$03</td><td style="text-align: center">$4D</td><td style="text-align: center">$4D</td><td style="text-align: center">$60</td><td style="text-align: center">$60</td></tr>
<tr><td style="text-align: right"><strong>PC</strong></td><td style="text-align: center">$0100</td><td style="text-align: center">$0100</td><td style="text-align: center">$0100</td><td style="text-align: center">$0100</td><td style="text-align: center">$0100</td></tr>
<tr><td style="text-align: right"><strong>SP</strong></td><td style="text-align: center">$FFFE</td><td style="text-align: center">$FFFE</td><td style="text-align: center">$FFFE</td><td style="text-align: center">$FFFE</td><td style="text-align: center">$FFFE</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="dmg_c"><sup class="footnote-definition-label">1</sup>
<p>If the <a href="#014d--header-checksum">header checksum</a> is $00, then the carry and half-carry flags are clear; otherwise, they are both set.</p>
</div>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Register</th><th style="text-align: center">CGB (DMG mode)</th><th style="text-align: center">AGB (DMG mode)</th><th style="text-align: center">CGB</th><th style="text-align: center">AGB</th></tr></thead><tbody>
<tr><td style="text-align: right"><strong>A</strong></td><td style="text-align: center">$11</td><td style="text-align: center">$11</td><td style="text-align: center">$11</td><td style="text-align: center">$11</td></tr>
<tr><td style="text-align: right"><strong>F</strong></td><td style="text-align: center">Z=1 N=0 H=0 C=0</td><td style="text-align: center">Z=? N=0 H=? C=0<sup class="footnote-reference"><a href="#agbdmg_f">2</a></sup></td><td style="text-align: center">Z=1 N=0 H=0 C=0</td><td style="text-align: center">Z=0 N=0 H=0 C=0</td></tr>
<tr><td style="text-align: right"><strong>B</strong></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#cgbdmg_b">3</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#cgbdmg_b">3</a></sup> + 1</td><td style="text-align: center">$00</td><td style="text-align: center">$01</td></tr>
<tr><td style="text-align: right"><strong>C</strong></td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><strong>D</strong></td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><strong>E</strong></td><td style="text-align: center">$08</td><td style="text-align: center">$08</td><td style="text-align: center">$56</td><td style="text-align: center">$56</td></tr>
<tr><td style="text-align: right"><strong>H</strong></td><td style="text-align: center">$??<sup class="footnote-reference"><a href="#cgbdmg_hl">4</a></sup></td><td style="text-align: center">$??<sup class="footnote-reference"><a href="#cgbdmg_hl">4</a></sup></td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><strong>L</strong></td><td style="text-align: center">$??<sup class="footnote-reference"><a href="#cgbdmg_hl">4</a></sup></td><td style="text-align: center">$??<sup class="footnote-reference"><a href="#cgbdmg_hl">4</a></sup></td><td style="text-align: center">$0D</td><td style="text-align: center">$0D</td></tr>
<tr><td style="text-align: right"><strong>PC</strong></td><td style="text-align: center">$0100</td><td style="text-align: center">$0100</td><td style="text-align: center">$0100</td><td style="text-align: center">$0100</td></tr>
<tr><td style="text-align: right"><strong>SP</strong></td><td style="text-align: center">$FFFE</td><td style="text-align: center">$FFFE</td><td style="text-align: center">$FFFE</td><td style="text-align: center">$FFFE</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="agbdmg_f"><sup class="footnote-definition-label">2</sup>
<p>To determine the flags, take the B register you would have gotten on CGB<sup class="footnote-reference"><a href="#cgbdmg_b">3</a></sup>, and <code>inc</code> it.
(To be precise: an <code>inc b</code> is the last operation to touch the flags.)
The carry and direction flags are always clear, though.</p>
</div>
<div class="footnote-definition" id="cgbdmg_b"><sup class="footnote-definition-label">3</sup>
<p>If the <a href="#014b--old-licensee-code">old licensee code</a> is $01, or the old licensee code is $33 and the <a href="#0144-0145--new-licensee-code">new licensee code</a> is <code>&quot;01&quot;</code> ($30 $31), then B is the sum of all 16 <a href="#0134-0143--title">title</a> bytes.
Otherwise, B is $00.
As indicated by the “+ 1” in the “AGB (DMG mode)” column, if on AGB, that value is increased by 1<sup class="footnote-reference"><a href="#agbdmg_f">2</a></sup>.</p>
</div>
<div class="footnote-definition" id="cgbdmg_hl"><sup class="footnote-definition-label">4</sup>
<p>There are two possible cases:</p>
<ul>
<li><strong>The B register is $43 or $58 (on CGB) / $44 or $59 (on AGB)</strong>: HL = $991A</li>
<li><strong>Neither of the above</strong>: HL = $007C</li>
</ul>
<!-- How else do I prevent the footnote definition from being too greedy? >_< -->
</div>
<p>The tables above were obtained from analysis of <a href="https://github.com/ISSOtm/gb-bootroms">the boot ROM’s disassemblies</a>, and confirmed using Mooneye-GB tests <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/acceptance/boot_regs-dmg0.s"><code>acceptance/boot_regs-dmg0</code></a>, <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/acceptance/boot_regs-dmgABC.s"><code>acceptance/boot_regs-dmgABC</code></a>, <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/acceptance/boot_regs-mgb.s"><code>acceptance/boot_regs-mgb</code></a>, <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/acceptance/boot_regs-sgb.s"><code>acceptance/boot_regs-sgb</code></a>, <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/acceptance/boot_regs-sgb2.s"><code>acceptance/boot_regs-sgb2</code></a>, <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/misc/boot_regs-cgb.s"><code>misc/boot_regs-cgb</code></a>, and <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/misc/boot_regs-A.s"><code>misc/boot_regs-A</code></a>, plus some extra testing.</p>
<h2 id="hardware-registers-1"><a class="header" href="#hardware-registers-1">Hardware registers</a></h2>
<p>As far as timing-sensitive values are concerned, these values are recorded at PC = $0100.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Name</th><th style="text-align: center">Address</th><th style="text-align: center">DMG0</th><th style="text-align: center">DMG / MGB</th><th style="text-align: center">SGB / SGB2</th><th style="text-align: center">CGB / AGB</th></tr></thead><tbody>
<tr><td style="text-align: right"><a href="#ff00--p1joyp-joypad"><code>P1</code></a></td><td style="text-align: center">$FF00</td><td style="text-align: center">$CF</td><td style="text-align: center">$CF</td><td style="text-align: center">$C7 or $CF</td><td style="text-align: center">$C7 or $CF</td></tr>
<tr><td style="text-align: right"><a href="#ff01--sb-serial-transfer-data"><code>SB</code></a></td><td style="text-align: center">$FF01</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff02--sc-serial-transfer-control"><code>SC</code></a></td><td style="text-align: center">$FF02</td><td style="text-align: center">$7E</td><td style="text-align: center">$7E</td><td style="text-align: center">$7E</td><td style="text-align: center">$7F</td></tr>
<tr><td style="text-align: right"><a href="#ff04--div-divider-register"><code>DIV</code></a></td><td style="text-align: center">$FF04</td><td style="text-align: center">$18</td><td style="text-align: center">$AB</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#unk">5</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#unk_pad">6</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff05--tima-timer-counter"><code>TIMA</code></a></td><td style="text-align: center">$FF05</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff06--tma-timer-modulo"><code>TMA</code></a></td><td style="text-align: center">$FF06</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff07--tac-timer-control"><code>TAC</code></a></td><td style="text-align: center">$FF07</td><td style="text-align: center">$F8</td><td style="text-align: center">$F8</td><td style="text-align: center">$F8</td><td style="text-align: center">$F8</td></tr>
<tr><td style="text-align: right"><a href="#ff0f--if-interrupt-flag"><code>IF</code></a></td><td style="text-align: center">$FF0F</td><td style="text-align: center">$E1</td><td style="text-align: center">$E1</td><td style="text-align: center">$E1</td><td style="text-align: center">$E1</td></tr>
<tr><td style="text-align: right"><a href="#ff10--nr10-channel-1-sweep"><code>NR10</code></a></td><td style="text-align: center">$FF10</td><td style="text-align: center">$80</td><td style="text-align: center">$80</td><td style="text-align: center">$80</td><td style="text-align: center">$80</td></tr>
<tr><td style="text-align: right"><a href="#ff11--nr11-channel-1-length-timer--duty-cycle"><code>NR11</code></a></td><td style="text-align: center">$FF11</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td></tr>
<tr><td style="text-align: right"><a href="#ff12--nr12-channel-1-volume--envelope"><code>NR12</code></a></td><td style="text-align: center">$FF12</td><td style="text-align: center">$F3</td><td style="text-align: center">$F3</td><td style="text-align: center">$F3</td><td style="text-align: center">$F3</td></tr>
<tr><td style="text-align: right"><a href="#ff13--nr13-channel-1-wavelength-low-write-only"><code>NR13</code></a></td><td style="text-align: center">$FF13</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff14--nr14-channel-1-wavelength-high--control"><code>NR14</code></a></td><td style="text-align: center">$FF14</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td></tr>
<tr><td style="text-align: right"><a href="#sound-channel-2--pulse"><code>NR21</code></a></td><td style="text-align: center">$FF16</td><td style="text-align: center">$3F</td><td style="text-align: center">$3F</td><td style="text-align: center">$3F</td><td style="text-align: center">$3F</td></tr>
<tr><td style="text-align: right"><a href="#sound-channel-2--pulse"><code>NR22</code></a></td><td style="text-align: center">$FF17</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#sound-channel-2--pulse"><code>NR23</code></a></td><td style="text-align: center">$FF18</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#sound-channel-2--pulse"><code>NR24</code></a></td><td style="text-align: center">$FF19</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td></tr>
<tr><td style="text-align: right"><a href="#ff1a--nr30-channel-3-dac-enable"><code>NR30</code></a></td><td style="text-align: center">$FF1A</td><td style="text-align: center">$7F</td><td style="text-align: center">$7F</td><td style="text-align: center">$7F</td><td style="text-align: center">$7F</td></tr>
<tr><td style="text-align: right"><a href="#ff1b--nr31-channel-3-length-timer-write-only"><code>NR31</code></a></td><td style="text-align: center">$FF1B</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff1c--nr32-channel-3-output-level"><code>NR32</code></a></td><td style="text-align: center">$FF1C</td><td style="text-align: center">$9F</td><td style="text-align: center">$9F</td><td style="text-align: center">$9F</td><td style="text-align: center">$9F</td></tr>
<tr><td style="text-align: right"><a href="#ff1d--nr33-channel-3-wavelength-low-write-only"><code>NR33</code></a></td><td style="text-align: center">$FF1D</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff1e--nr34-channel-3-wavelength-high--control"><code>NR34</code></a></td><td style="text-align: center">$FF1E</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td></tr>
<tr><td style="text-align: right"><a href="#ff20--nr41-channel-4-length-timer-write-only"><code>NR41</code></a></td><td style="text-align: center">$FF20</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff21--nr42-channel-4-volume--envelope"><code>NR42</code></a></td><td style="text-align: center">$FF21</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff22--nr43-channel-4-frequency--randomness"><code>NR43</code></a></td><td style="text-align: center">$FF22</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff23--nr44-channel-4-control"><code>NR44</code></a></td><td style="text-align: center">$FF23</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td><td style="text-align: center">$BF</td></tr>
<tr><td style="text-align: right"><a href="#ff24--nr50-master-volume--vin-panning"><code>NR50</code></a></td><td style="text-align: center">$FF24</td><td style="text-align: center">$77</td><td style="text-align: center">$77</td><td style="text-align: center">$77</td><td style="text-align: center">$77</td></tr>
<tr><td style="text-align: right"><a href="#ff25--nr51-sound-panning"><code>NR51</code></a></td><td style="text-align: center">$FF25</td><td style="text-align: center">$F3</td><td style="text-align: center">$F3</td><td style="text-align: center">$F3</td><td style="text-align: center">$F3</td></tr>
<tr><td style="text-align: right"><a href="#ff26--nr52-sound-onoff"><code>NR52</code></a></td><td style="text-align: center">$FF26</td><td style="text-align: center">$F1</td><td style="text-align: center">$F1</td><td style="text-align: center">$F0</td><td style="text-align: center">$F1</td></tr>
<tr><td style="text-align: right"><a href="#ff40--lcdc-lcd-control"><code>LCDC</code></a></td><td style="text-align: center">$FF40</td><td style="text-align: center">$91</td><td style="text-align: center">$91</td><td style="text-align: center">$91</td><td style="text-align: center">$91</td></tr>
<tr><td style="text-align: right"><a href="#ff41--stat-lcd-status"><code>STAT</code></a></td><td style="text-align: center">$FF41</td><td style="text-align: center">$81</td><td style="text-align: center">$85</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#unk">5</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#unk_pad">6</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff42ff43--scy-scx-viewport-y-position-x-position"><code>SCY</code></a></td><td style="text-align: center">$FF42</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff42ff43--scy-scx-viewport-y-position-x-position"><code>SCX</code></a></td><td style="text-align: center">$FF43</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff44--ly-lcd-y-coordinate-read-only"><code>LY</code></a></td><td style="text-align: center">$FF44</td><td style="text-align: center">$91</td><td style="text-align: center">$00</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#unk">5</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#unk_pad">6</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff45--lyc-ly-compare"><code>LYC</code></a></td><td style="text-align: center">$FF45</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff46--dma-oam-dma-source-address--start"><code>DMA</code></a></td><td style="text-align: center">$FF46</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff47--bgp-non-cgb-mode-only-bg-palette-data"><code>BGP</code></a></td><td style="text-align: center">$FF47</td><td style="text-align: center">$FC</td><td style="text-align: center">$FC</td><td style="text-align: center">$FC</td><td style="text-align: center">$FC</td></tr>
<tr><td style="text-align: right"><a href="#ff48ff49--obp0-obp1-non-cgb-mode-only-obj-palette-0-1-data"><code>OBP0</code></a></td><td style="text-align: center">$FF48</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#obp">7</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#obp">7</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#obp">7</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#obp">7</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff48ff49--obp0-obp1-non-cgb-mode-only-obj-palette-0-1-data"><code>OBP1</code></a></td><td style="text-align: center">$FF49</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#obp">7</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#obp">7</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#obp">7</a></sup></td><td style="text-align: center">??<sup class="footnote-reference"><a href="#obp">7</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff4aff4b--wy-wx-window-y-position-x-position-plus-7"><code>WY</code></a></td><td style="text-align: center">$FF4A</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff4aff4b--wy-wx-window-y-position-x-position-plus-7"><code>WX</code></a></td><td style="text-align: center">$FF4B</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
<tr><td style="text-align: right"><a href="#ff4d--key1-cgb-mode-only-prepare-speed-switch"><code>KEY1</code></a></td><td style="text-align: center">$FF4D</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff4f--vbk-cgb-mode-only-vram-bank"><code>VBK</code></a></td><td style="text-align: center">$FF4F</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff51ff52--hdma1-hdma2-cgb-mode-only-vram-dma-source-high-low-write-only"><code>HDMA1</code></a></td><td style="text-align: center">$FF51</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff51ff52--hdma1-hdma2-cgb-mode-only-vram-dma-source-high-low-write-only"><code>HDMA2</code></a></td><td style="text-align: center">$FF52</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff53ff54--hdma3-hdma4-cgb-mode-only-vram-dma-destination-high-low-write-only"><code>HDMA3</code></a></td><td style="text-align: center">$FF53</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff53ff54--hdma3-hdma4-cgb-mode-only-vram-dma-destination-high-low-write-only"><code>HDMA4</code></a></td><td style="text-align: center">$FF54</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff55--hdma5-cgb-mode-only-vram-dma-lengthmodestart"><code>HDMA5</code></a></td><td style="text-align: center">$FF55</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff56--rp-cgb-mode-only-infrared-communications-port"><code>RP</code></a></td><td style="text-align: center">$FF56</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ff68--bcpsbgpi-cgb-mode-only-background-color-palette-specification--background-palette-index"><code>BCPS</code></a></td><td style="text-align: center">$FF68</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#compat">8</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff69--bcpdbgpd-cgb-mode-only-background-color-palette-data--background-palette-data"><code>BCPD</code></a></td><td style="text-align: center">$FF69</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#compat">8</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff6aff6b--ocpsobpi-ocpdobpd-cgb-mode-only-obj-color-palette-specification--obj-palette-index-obj-color-palette-data--obj-palette-data"><code>OCPS</code></a></td><td style="text-align: center">$FF6A</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#compat">8</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff6aff6b--ocpsobpi-ocpdobpd-cgb-mode-only-obj-color-palette-specification--obj-palette-index-obj-color-palette-data--obj-palette-data"><code>OCPD</code></a></td><td style="text-align: center">$FF6B</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">??<sup class="footnote-reference"><a href="#compat">8</a></sup></td></tr>
<tr><td style="text-align: right"><a href="#ff70--svbk-cgb-mode-only-wram-bank"><code>SVBK</code></a></td><td style="text-align: center">$FF70</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td><td style="text-align: center">$FF</td></tr>
<tr><td style="text-align: right"><a href="#ffff--ie-interrupt-enable"><code>IE</code></a></td><td style="text-align: center">$FFFF</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td><td style="text-align: center">$00</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="unk"><sup class="footnote-definition-label">5</sup>
<p>Since this boot ROM’s duration depends on the header’s contents, a general answer can’t be given.
The value should be static for a given header, though.</p>
</div>
<div class="footnote-definition" id="unk_pad"><sup class="footnote-definition-label">6</sup>
<p>Since this boot ROM’s duration depends on the header’s contents (and the player’s inputs in compatibility mode), an answer can’t be given.
Just don’t rely on these.</p>
</div>
<div class="footnote-definition" id="obp"><sup class="footnote-definition-label">7</sup>
<p>These registers are left entirely uninitialized.
Their value tends to be most often $00 or $FF, but the value is especially not reliable if your software runs after e.g. a flashcart or multicart selection menu.
Make sure to always set those before displaying objects for the first time.</p>
</div>
<div class="footnote-definition" id="compat"><sup class="footnote-definition-label">8</sup>
<p>These depend on whether compatibility mode is enabled.</p>
</div>
<p>The table above was obtained from Mooneye-GB tests <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/acceptance/boot_hwio-dmg0.s"><code>acceptance/boot_hwio-dmg0</code></a>, <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/acceptance/boot_hwio-dmgABCmgb.s"><code>acceptance/boot_hwio-dmgABCmgb</code></a>, <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/acceptance/boot_hwio-S.s"><code>acceptance/boot_hwio-S</code></a>, and <a href="https://github.com/Gekkio/mooneye-gb/blob/ca7ff30b52fd3de4f1527397f27a729ffd848dfa/tests/misc/boot_hwio-C.s"><code>misc/boot_hwio-C</code></a>, plus some extra testing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reducing-power-consumption"><a class="header" href="#reducing-power-consumption">Reducing Power Consumption</a></h1>
<p>The following programming techniques can be used to reduce the power
consumption of the Game Boy hardware and extend the life of the
batteries.</p>
<h2 id="using-the-halt-instruction"><a class="header" href="#using-the-halt-instruction">Using the HALT Instruction</a></h2>
<p>The HALT instruction should be used whenever possible to reduce power
consumption.</p>
<p>The CPU will remain halted until an interrupt <em>enabled by <a href="#ffff--ie-interrupt-enable">the IE register ($FFFF)</a></em> is
flagged in IF, at which point the interrupt is serviced if IME is enabled,
and then execution continues at the instruction immediately following the
HALT.</p>
<p>Depending on how much CPU time is required by a game, the HALT
instruction can extend battery life anywhere from 5% to 50% or possibly
more.</p>
<p>When waiting for a VBlank event, this would be a BAD example:</p>
<pre><code class="language-rgbasm">.wait
    ld   a, [$FF44] ; LY
    cp   a, 144
    jr   nz, .wait
</code></pre>
<p>A better example would be a procedure as shown below. In this case the
VBlank interrupt must be enabled, and your VBlank interrupt handler
must set <code>vblank_flag</code> (a one-byte variable allocated in RAM) to a non-zero value.</p>
<pre><code class="language-rgbasm">  ld   hl, vblank_flag  ; hl = pointer to vblank_flag
  xor  a                ; a = 0
.wait
  halt                  ; suspend CPU - wait for ANY enabled interrupt
  cp   a, [hl]          ; is the vblank_flag still zero?
  jr   z, .wait         ; keep waiting if zero
  ld   [hl], a          ; set the vblank_flag back to zero
</code></pre>
<p>The <code>vblank_flag</code> variable is used to determine whether the HALT period has been
terminated by a VBlank interrupt or by another interrupt. Note though
that a VBlank interrupt might happen after the cp instruction
and before the jr, in which case the interrupt would go unnoticed by the
procedure, which would jump again into a halt.</p>
<p>Another possibility is, if your game uses no other interrupt than VBlank
(or uses no interrupts), to only enable VBlank interrupts and simply use
a HALT instruction, which will only resume main code execution when a
VBlank occurs.</p>
<p>Remember, when using HALT to wait between VBlanks, that your interrupt
handlers MUST enable interrupts (using EI before returning, or
better, using the RETI instruction)</p>
<h2 id="using-the-stop-instruction"><a class="header" href="#using-the-stop-instruction">Using the STOP Instruction</a></h2>
<p>The STOP instruction is intended to switch the Game Boy into VERY low
power standby mode. For example, a program may use this feature when it
hasn’t sensed keyboard input for a longer period (for example, when
somebody forgot to turn off the Game Boy).</p>
<p>No licensed rom makes use of STOP outside of CGB speed switching.
Special care needs to be taken if you want to make use of the STOP
instruction.</p>
<p>On a DMG, disabling the LCD before invoking STOP leaves the LCD enabled,
drawing a horizontal black line on the screen and very likely damaging the
hardware.</p>
<p>On CGB, leaving the LCD enabled when invoking STOP will result in a
black screen. Except if the LCD is in Mode 3, where it will keep drawing
the current screen.</p>
<p>STOP is terminated by one of the P10 to P13 lines going low. For this
reason, d-pad and/or button inputs should be enabled by writing $00,
$10 or $20 to the <code>P1</code> register before entering STOP (depending on which
buttons you want to terminate the STOP on).</p>
<p align="center">
<img src="imgs/gb_stop.png">
<br>
  <i>Source: Lior Halphon</i>
</p>
<h2 id="disabling-the-sound-controller"><a class="header" href="#disabling-the-sound-controller">Disabling the Sound Controller</a></h2>
<p>If your program doesn’t use sound at all (or during some periods) then
write 00h to register FF26 to save 16% or more on GB power consumption.
Sound can be turned back on by writing 80h to the same register, all
sound registers must be then re-initialized. When the Game Boy is turned
on, sound is enabled by default, and must be turned off manually when
not used.</p>
<h2 id="not-using-cgb-double-speed-mode"><a class="header" href="#not-using-cgb-double-speed-mode">Not using CGB Double Speed Mode</a></h2>
<p>Because CGB Double Speed mode consumes more power, it’s recommended to
use normal speed when possible. There’s limited ability to switch
between both speeds, for example, a game might use normal speed in the
title screen, and double speed in the game, or vice versa. However,
during speed switch, the display collapses for a short moment, so it’s
not a good idea to alter speeds within active game or title screen
periods.</p>
<h2 id="using-the-skills"><a class="header" href="#using-the-skills">Using the Skills</a></h2>
<p>Most of the above power saving methods will produce best results when
using efficient and tight assembler code which requires as little CPU
power as possible. Using a high level language will require more CPU
power and these techniques will not have as big as an effect.</p>
<p>To optimize your code, it might be a good idea to look at <a href="http://wikiti.brandonw.net/index.php?title=Z80_Optimization">this
page</a>,
although it applies to the original Z80 CPU, so one must adapt the
optimizations to the GBZ80.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accessing-vram-and-oam"><a class="header" href="#accessing-vram-and-oam">Accessing VRAM and OAM</a></h1>
<div class="box warning">
<p class="box-title">Warning</p><p>When the PPU is drawing the screen it is directly reading
from Video Memory (VRAM) and from the Sprite Attribute Table (OAM).
During these periods the Game Boy CPU may not access VRAM and OAM.
That means that any attempts to write to VRAM or OAM are ignored (data
remains unchanged). And any attempts to read from VRAM or OAM will return
undefined data (typically $FF).</p>
<p>For this reason the program should verify if VRAM/OAM is accessible
before actually reading or writing to it. This is usually done by
reading the Mode bits from the STAT Register (FF41). When doing this (as
described in the examples below) you should take care that no interrupts
occur between the wait loops and the following memory access - the
memory is guaranteed to be accessible only for a few cycles just
after the wait loops have completed.</p>
</div>
<h2 id="vram-memory-area-at-8000-9fff-is-accessible-during-modes-0-2"><a class="header" href="#vram-memory-area-at-8000-9fff-is-accessible-during-modes-0-2">VRAM (memory area at $8000-$9FFF) is accessible during Modes 0-2</a></h2>
<pre><code>Mode 0 - HBlank Period,
Mode 1 - VBlank Period, and
Mode 2 - Searching OAM Period
</code></pre>
<p>A typical procedure that waits for accessibility of VRAM would be:</p>
<pre><code class="language-rgbasm">    ld   hl, $FF41     ; STAT Register
.wait
    bit  1, [hl]       ; Wait until Mode is 0 or 1
    jr   nz, .wait
</code></pre>
<p>Even if the procedure gets executed at the <em>end</em> of Mode 0 or 1, it is
still safe to assume that VRAM can be accessed for a few more cycles
because in either case the following period is Mode 2, which allows
access to VRAM also. However, be careful about STAT interrupts or
other interrupts that could cause the PPU to be back in Mode 3 by the
time it returns. In CGB Mode an alternate method to write data to VRAM
is to use the HDMA Function (FF51-FF55).</p>
<p>If you do not require any STAT interrupts, another way to synchronize to the
start of Mode 0 is to disable all the individual STAT interrupts except Mode 0
(STAT bit 3), enable STAT interrupts (IE bit 1), disable IME (by executing <code>di</code>),
and use the <code>halt</code> instruction. This allows
use of the entire Mode 0 on one line and Mode 2 on the following line,
which sum to 165 to 288 dots. For comparison, at single speed (4 dots
per machine cycle), a copy from stack that takes
9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which
fits within the worst case timing for mode 0+2.</p>
<h2 id="oam-memory-area-at-fe00-fe9f-is-accessible-during-modes-0-1"><a class="header" href="#oam-memory-area-at-fe00-fe9f-is-accessible-during-modes-0-1">OAM (memory area at $FE00-$FE9F) is accessible during Modes 0-1</a></h2>
<pre><code>Mode 0 - HBlank Period
Mode 1 - VBlank Period
</code></pre>
<p>During those modes, OAM can be accessed directly or by doing a DMA
transfer (FF46). Outside those modes, DMA out-prioritizes the PPU in
accessing OAM, and the PPU will read $FF from OAM during that time.</p>
<p>A typical
procedure that waits for accessibility of OAM would be:</p>
<pre><code class="language-rgbasm">    ld   hl, $FF41    ; STAT Register
    ; Wait until Mode is -NOT- 0 or 1
.waitNotBlank
    bit  1, [hl]
    jr   z, .waitNotBlank
    ; Wait until Mode 0 or 1 -BEGINS- (but we know that Mode 0 is what will begin)
.waitBlank
    bit  1, [hl]
    jr   nz, .waitBlank
</code></pre>
<p>The two wait loops ensure that Mode 0 (and Mode 1 if we are at the end
of a frame) will last for a few clock
cycles after completion of the procedure. If we need to wait for the VBlank period, it would be
better to skip the whole procedure, and use a STAT interrupt instead. In any case,
doing a DMA transfer is more efficient than writing to OAM directly.</p>
<div class="box tip">
<p class="box-title">NOTE</p><p>While the display is disabled, both VRAM and OAM are accessible.
The downside is that the screen is blank (white) during this
period, so disabling the display would be recommended only during
initialization.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oam-corruption-bug"><a class="header" href="#oam-corruption-bug">OAM Corruption Bug</a></h1>
<p>There is a flaw in the Game Boy hardware that causes rubbish data to be written
to OAM RAM if the following instructions are used while their 16-bit content
(before the operation) is in the range $FE00–$FEFF and the PPU is in mode 2:</p>
<pre><code class="language-rgbasm"> inc rr         dec rr       ; rr = bc, de, or hl
 ld a, [hli]    ld a, [hld]
 ld [hli], a    ld [hld], a
</code></pre>
<p>Sprites 1 &amp; 2 ($FE00 &amp; $FE04) are not affected by this bug.</p>
<p>Game Boy Color and Advance are not affected by this bug, even when
running monochrome software.</p>
<h2 id="accurate-description"><a class="header" href="#accurate-description">Accurate Description</a></h2>
<p>The OAM Corruption Bug (or OAM Bug) actually consists of two different bugs:</p>
<ul>
<li>Attempting to read or write from OAM (Including the $FEA0-$FEFF
region) while the PPU is in mode 2 (OAM mode) will corrupt it.</li>
<li>Performing an increase or decrease operation on any 16-bit register
(BC, DE, HL, SP or PC) while that register is in the OAM range
($FE00 - $FEFF) will trigger a memory write to OAM, causing a
corruption.</li>
</ul>
<h2 id="affected-operations"><a class="header" href="#affected-operations">Affected Operations</a></h2>
<p>The following operations are affected by this bug:</p>
<ul>
<li>Any memory access instruction, if it accesses OAM</li>
<li><code>inc rr</code>, <code>dec rr</code> - if <code>rr</code> is a 16-bit register pointing to OAM,
it will trigger a write and corrupt OAM</li>
<li><code>ld [hli], a</code>, <code>ld [hld], a</code>, <code>ld a, [hli]</code>, <code>ld a, [hld]</code>- these
will trigger a corruption twice if <code>hl</code> points to OAM; once for the
usual memory access, and once for the extra write triggered by the
<code>inc</code>/<code>dec</code></li>
<li><code>pop rr</code>, the <code>ret</code> family - For some reason, <code>pop</code> will trigger the
bug only 3 times (instead of the expected 4 times); one read, one
glitched write, and another read without a glitched write. This also
applies to the <code>ret</code> instructions.</li>
<li><code>push rr</code>, the <code>call</code> family, <code>rst xx</code> and interrupt handling -
Pushing to the stack will trigger the bug 4 times; two usual writes
and two glitched writes caused by the implied <code>dec sp</code>. However, since one
glitched write occurs in the same cycle as a actual write, this will
effectively behave like 3 writes.</li>
<li>Executing code from OAM - If PC is inside OAM (reading $FF,
that is, <code>rst $38</code>) the bug will trigger twice, once for increasing PC
inside OAM (triggering a write), and once for reading from OAM. If a
multi-byte opcode is executed from $FDFF or $FDFE, and bug will
similarly trigger twice for every read from OAM.</li>
</ul>
<h2 id="corruption-patterns"><a class="header" href="#corruption-patterns">Corruption Patterns</a></h2>
<p>The OAM is split into 20 rows of 8 bytes each, and during mode 2 the PPU
reads those rows consecutively; one every 1 M-cycle. The operations
patterns rely on type of operation (read/write/both) used on OAM during
that M-cycle, as well as the row currently accessed by the PPU. The
actual read/write address used, or the written value have no effect.
Additionally, keep in mind that OAM uses a 16-bit data bus, so all
operations are on 16-bit words.</p>
<h3 id="write-corruption"><a class="header" href="#write-corruption">Write Corruption</a></h3>
<p>A “write corruption” corrupts the currently access row in the following
manner, as long as it’s not the first row (containing the first two
sprites):</p>
<ul>
<li>The first word in the row is replaced with this bitwise expression:
<code>((a ^ c) &amp; (b ^ c)) ^ c</code>, where <code>a</code> is the original value of that
word, <code>b</code> is the first word in the preceding row, and <code>c</code> is the
third word in the preceding row.</li>
<li>The last three words are copied from the last three words in the
preceding row.</li>
</ul>
<h3 id="read-corruption"><a class="header" href="#read-corruption">Read Corruption</a></h3>
<p>A “read corruption” works similarly to a write corruption, except the
bitwise expression is <code>b | (a &amp; c)</code>.</p>
<h3 id="write-during-increasedecrease"><a class="header" href="#write-during-increasedecrease">Write During Increase/Decrease</a></h3>
<p>If a register is increased or decreased in the same M-cycle of a write,
this will effectively trigger two writes in a single M-cycle. However,
this case behaves just like a single write.</p>
<h3 id="read-during-increasedecrease"><a class="header" href="#read-during-increasedecrease">Read During Increase/Decrease</a></h3>
<p>If a register is increased or decreased in the same M-cycle of a write,
this will effectively trigger both a read <strong>and</strong> a write in a single
M-cycle, resulting in a more complex corruption pattern:</p>
<ul>
<li>This corruption will not happen if the accessed row is one of the
first four, as well as if it’s the last row:
<ul>
<li>The first word in the row preceding the currently accessed row
is replaced with the following bitwise expression:
<code>(b &amp; (a | c | d)) | (a &amp; c &amp; d)</code> where <code>a</code> is the first word
two rows before the currently accessed row, <code>b</code> is the first
word in the preceding row (the word being corrupted), <code>c</code> is the
first word in the currently accessed row, and <code>d</code> is the third
word in the preceding row.</li>
<li>The contents of the preceding row is copied (after the
corruption of the first word in it) both to the currently
accessed row and to two rows before the currently accessed row</li>
</ul>
</li>
<li>Regardless of whether the previous corruption occurred or not, a
normal read corruption is then applied.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-connectors"><a class="header" href="#external-connectors">External Connectors</a></h1>
<h2 id="cartridge-slot"><a class="header" href="#cartridge-slot">Cartridge Slot</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pin</th><th>Name</th><th>Explanation</th></tr></thead><tbody>
<tr><td>1</td><td>VDD</td><td>Power Supply +5V DC</td></tr>
<tr><td>2</td><td>PHI</td><td>System Clock</td></tr>
<tr><td>3</td><td>/WR</td><td>Write</td></tr>
<tr><td>4</td><td>/RD</td><td>Read</td></tr>
<tr><td>5</td><td>/CS</td><td>Chip Select</td></tr>
<tr><td>6-21</td><td>A0-A15</td><td>Address Lines</td></tr>
<tr><td>22-29</td><td>D0-D7</td><td>Data Lines</td></tr>
<tr><td>30</td><td>/RES</td><td>Reset signal</td></tr>
<tr><td>31</td><td>VIN</td><td>External Sound Input</td></tr>
<tr><td>32</td><td>GND</td><td>Ground</td></tr>
</tbody></table>
</div>
<h2 id="link-port"><a class="header" href="#link-port">Link Port</a></h2>
<p>Pin numbers are arranged as 2,4,6 in upper row, 1,3,5 in lower row;
outside view of Game Boy socket; flat side of socket upside. Colors as
used in most or all standard link cables, because SIN and SOUT are
crossed, colors Red and Orange are exchanged at one cable end.</p>
<div class="table-wrapper"><table><thead><tr><th>Pin</th><th>Name</th><th>Color</th><th>Explanation</th></tr></thead><tbody>
<tr><td>1</td><td>VCC</td><td>-</td><td>+5V DC</td></tr>
<tr><td>2</td><td>SOUT</td><td>red</td><td>Data Out</td></tr>
<tr><td>3</td><td>SIN</td><td>orange</td><td>Data In</td></tr>
<tr><td>4</td><td>P14</td><td>-</td><td>Not used</td></tr>
<tr><td>5</td><td>SCK</td><td>green</td><td>Shift Clock</td></tr>
<tr><td>6</td><td>GND</td><td>blue</td><td>Ground</td></tr>
</tbody></table>
</div>
<p>Note: The original Game Boy used larger plugs than Game Boy Pocket and
newer. Linking between older/newer Game Boy systems is possible by using cables
with one large and one small plug though.</p>
<h2 id="stereo-sound-connector-35mm-female"><a class="header" href="#stereo-sound-connector-35mm-female">Stereo Sound Connector (3.5mm, female)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pin</th><th>Explanation</th></tr></thead><tbody>
<tr><td>Tip</td><td>Sound Left</td></tr>
<tr><td>Middle</td><td>Sound Right</td></tr>
<tr><td>Base</td><td>Ground</td></tr>
</tbody></table>
</div>
<h2 id="external-power-supply"><a class="header" href="#external-power-supply">External Power Supply</a></h2>
<p>…</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gbc-approval-process"><a class="header" href="#gbc-approval-process">GBC Approval Process</a></h1>
<p>Game Boy Color hardware applies automatic colorization to monochrome
games, with one 4-color palette for backgrounds and two 3-color
palettes for sprites.  Because of past under utilization of Super Game Boy
features even in first-party games (as explained in an article by
Christine Love), Nintendo required Game Boy Color games to appear
more colorful than this automatic colorization. Thus, Nintendo
required publishers to keep Nintendo in the loop at three points in
development.  The Mario Club division evaluated games on whether
color was being used appropriately.  Some things Mario Club looked at
were variety of colors, both within a scene and between scenes; choice
of colors appropriate to a game’s art style, such as objects being
distinguishable and trees being colored like trees; and contrast
between foreground and background to emphasize color saturation.</p>
<p>For both original and ported games, the initial written game design
document needed to explain and illustrate how color would be used, as
well as a project schedule, estimated ROM and RAM size, and whether
the ROM was dual compatible or GBC-only.  Ports of a monochrome game
(such as <em>Tetris DX</em>, <em>Link’s Awakening DX</em>, or ICOM’s <em>MacVenture</em>
series) to Game Boy Color were subject to concept pre-approval,
unlike original games.  A port’s proposal needed to explain what new
gameplay content (other than just colorization) it would include,
such as levels, characters, or items.</p>
<p>At 50 percent milestone and near completion, the publisher would
submit a ROM image to Mario Club for feedback on use of color and
other aspects of game design.</p>
<p>References:</p>
<ul>
<li><a href="https://loveconquersallgam.es/post/2487450388/fuck-the-super-game-boy-kirbys-dream-land-2">“F the Super Game Boy: Kirby’s Dream Land 2”</a> by Christine Love</li>
<li><a href="https://sidequestions.medium.com/making-snoopy-tennis-nintendo-gameboy-color-infogrames-mermaid-11bed971526d">“The Making of Snoopy Tennis”</a> by Alexander Hughes</li>
<li><a href="https://web.archive.org/web/20220323183905/https://contracts.onecle.com/thq/nintendo.lic.1999.03.09.shtml">“License Agreement for Game Boy (Western Hemisphere)”</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references-2"><a class="header" href="#references-2">References</a></h1>
<ul>
<li><a href="https://github.com/AntonioND/giibiiadvance/tree/master/docs">Antonio Niño Díaz - The Cycle-Accurate Game Boy Docs</a></li>
<li><a href="https://github.com/AntonioND/gbcam-rev-engineer">Antonio Niño Díaz - Game Boy Camera RE</a></li>
<li><a href="http://www.its.caltech.edu/~costis/sgb_hack/">Costis Sideris. The quest for dumping GameBoy Boot ROMs!</a></li>
<li><a href="https://wiki.tauwasser.eu/view/MBC1">Tauwasser. MBC1 - Tauwasser’s Wiki</a></li>
<li><a href="https://wiki.tauwasser.eu/view/MBC2">Tauwasser. MBC2 - Tauwasser’s Wiki</a></li>
<li><a href="https://web.archive.org/web/20090220190205/http://www.semis.demon.co.uk/Gameboy/Gbmain.htm">MBC5 Schematic</a></li>
<li><a href="https://github.com/Gekkio/gb-ctr">Gekkio. Game Boy: Complete Technical Reference</a></li>
<li><a href="https://gbdev.github.io/gb-opcodes/optables/">Game Boy CPU (SM83) instruction set</a></li>
<li><a href="https://gekkio.fi/blog/2015/dumping-the-super-game-boy-2-boot-rom/">Gekkio. Dumping the Super Game Boy 2 boot ROM</a></li>
<li><a href="https://web.archive.org/web/20210427065258/https://exez.in/gameboy-dma">exezin. OAM DMA tutorial</a></li>
<li><a href="https://github.com/furrtek/DMG-CPU-Inside">Furrtek - Reverse-engineered schematics for DMG-CPU-B</a></li>
<li><a href="http://furrtek.free.fr/?a=gbprinter">Furrtek - Game Boy Printer</a></li>
<li><a href="https://github.com/gbdev/pandocs/tree/master/historical">Pan of ATX, Marat Fayzullin, Felber Pascal, Robson Paul, and Korth Martin - Pan Docs (previous versions and revisions)</a></li>
<li><a href="http://www.devrs.com/gb/hardware.php">Jeff Frohwein - DMG, SGB, MBC schematics</a></li>
<li><a href="http://www.z80.info/z80gboy.txt">Pat Fagan - z80gboy.txt</a></li>
<li><a href="https://loveconquersallgam.es/post/2487450388/fuck-the-super-game-boy-kirbys-dream-land-2">Christine Love - F the Super Game Boy: Kirby’s Dream Land 2</a></li>
<li><a href="https://shonumi.github.io/dandocs.html">Shonumi - Dan Docs</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
